"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[9928],{89928:(e,a,n)=>{n.r(a),n.d(a,{Dispose:()=>l,DumpData:()=>d,DumpDataAsync:()=>u,DumpFramebuffer:()=>m,DumpTools:()=>f});var r=n(84255),t=n(998),s=n(84867),i=n(6315),o=n(51137);let p=null;async function c(){return p||(p=async function(){const e=i.q.LastCreatedEngine?.createCanvas(100,100)??new OffscreenCanvas(100,100);e instanceof OffscreenCanvas&&o.V.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");const{ThinEngine:a}=await Promise.resolve().then(n.bind(n,77008));if(!a.IsSupported){if(!e.getContext("bitmaprenderer"))throw new Error("DumpData: No WebGL or bitmap rendering context available. Cannot dump data.");return{canvas:e}}const t=new a(e,!1,{preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1});i.q.Instances.pop(),i.q.OnEnginesDisposedObservable.add(e=>{t&&e!==t&&!t.isDisposed&&0===i.q.Instances.length&&l()}),t.getCaps().parallelShaderCompile=void 0;const s=new r.J(t),{passPixelShader:p}=await n.e(9820).then(n.bind(n,79820)),c=new r.$({engine:t,name:p.name,fragmentShader:p.shader,samplerNames:["textureSampler"]});return{canvas:e,dumpEngine:{engine:t,renderer:s,wrapper:c}}}()),await p}async function m(e,a,n,r,t="image/png",s,i){const o=await n.readPixels(0,0,e,a);d(e,a,new Uint8Array(o.buffer),r,t,s,!0,void 0,i)}async function u(e,a,n,r="image/png",i,o=!1,p=!1,m){if(n instanceof Float32Array){const e=new Uint8Array(n.length);let a=n.length;for(;a--;){const r=n[a];e[a]=Math.round(255*(0,s.Clamp)(r))}n=e}const u=await c();return await new Promise(async s=>{if(u.dumpEngine){const r=u.dumpEngine;r.engine.setSize(e,a,!0);const t=r.engine.createRawTexture(n,e,a,5,!1,!o,1);r.renderer.setViewport(),r.renderer.applyEffectWrapper(r.wrapper),r.wrapper.effect._bindTexture("textureSampler",t),r.renderer.draw(),t.dispose()}else{const r=u.canvas.getContext("bitmaprenderer");u.canvas.width=e,u.canvas.height=a;const t=new ImageData(e,a);t.data.set(n);const s=await createImageBitmap(t,{premultiplyAlpha:"none",imageOrientation:o?"flipY":"from-image"});r.transferFromImageBitmap(s)}t.S0.ToBlob(u.canvas,e=>{if(!e)throw new Error("DumpData: Failed to convert canvas to blob.");void 0!==i&&t.S0.DownloadBlob(e,i);const a=new FileReader;a.onload=e=>{const a=e.target.result;s(a)},p?a.readAsArrayBuffer(e):a.readAsDataURL(e)},r,m)})}function d(e,a,n,r,t="image/png",s,i=!1,o=!1,p){void 0!==s||r||(s=""),u(e,a,n,t,s,i,o,p).then(e=>{r&&r(e)})}function l(){p&&(p?.then(e=>{e.canvas instanceof HTMLCanvasElement&&e.canvas.remove(),e.dumpEngine&&(e.dumpEngine.engine.dispose(),e.dumpEngine.renderer.dispose(),e.dumpEngine.wrapper.dispose())}),p=null)}const f={DumpData:d,DumpDataAsync:u,DumpFramebuffer:m,Dispose:l};t.S0.DumpData=d,t.S0.DumpDataAsync=u,t.S0.DumpFramebuffer=m}}]);