"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[391],{40391:(e,t,i)=>{i.d(t,{HDRCubeTexture:()=>x});var r=i(79923),s=i(56526),n=i(7481),a=i(82814),h=i(36755),o=i(56552),d=i(99848),c=i(998),l=i(65559),u=i(68571),f=i(62956),_=i(84867),p=i(84255),g=i(89974);class m{constructor(e,t={}){this.quality=4096,this.hdrScale=1,this.useCdf=!1,this._engine=e,this.hdrScale=t.hdrScale||this.hdrScale,this.quality=t.quality||this.quality,this.useCdf=t.useCdf||this.useCdf}_createRenderTarget(e){let t=0;this._engine.getCaps().textureHalfFloatRender?t=2:this._engine.getCaps().textureFloatRender&&(t=1);const i=this._engine.createRenderTargetCubeTexture(e,{format:5,type:t,createMipMaps:!1,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:2,label:"HDR_Irradiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(i.texture,0,0,0),i}_prefilterInternal(e){const t=e.getSize().width,i=(0,_.ILog2)(t),r=this._effectWrapper.effect,n=Math.max(32,1<<(0,_.ILog2)(t>>3)),a=this._createRenderTarget(n);this._effectRenderer.saveStates(),this._effectRenderer.setViewport(),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const h=[[new f.Pq(0,0,-1),new f.Pq(0,-1,0),new f.Pq(1,0,0)],[new f.Pq(0,0,1),new f.Pq(0,-1,0),new f.Pq(-1,0,0)],[new f.Pq(1,0,0),new f.Pq(0,0,1),new f.Pq(0,1,0)],[new f.Pq(1,0,0),new f.Pq(0,0,-1),new f.Pq(0,-1,0)],[new f.Pq(1,0,0),new f.Pq(0,-1,0),new f.Pq(0,0,1)],[new f.Pq(-1,0,0),new f.Pq(0,-1,0),new f.Pq(0,0,-1)]];r.setFloat("hdrScale",this.hdrScale),r.setFloat2("vFilteringInfo",e.getSize().width,i),r.setTexture("inputTexture",e),this._cdfGenerator&&r.setTexture("icdfTexture",this._cdfGenerator.getIcdfTexture());for(let e=0;e<6;e++)r.setVector3("up",h[e][0]),r.setVector3("right",h[e][1]),r.setVector3("front",h[e][2]),this._engine.bindFramebuffer(a,e,void 0,void 0,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper),this._effectRenderer.draw();this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),r.setTexture("inputTexture",null),r.setTexture("icdfTexture",null);const o=new s.t(e.getScene(),a.texture);return o.name=e.name+"_irradiance",o.displayName=e.name+"_irradiance",o.gammaSpace=!1,o}_createEffect(e,t){const r=[];e.gammaSpace&&r.push("#define GAMMA_INPUT"),r.push("#define NUM_SAMPLES "+this.quality+"u");const s=this._engine.isWebGPU,n=["inputTexture"];this._cdfGenerator&&(n.push("icdfTexture"),r.push("#define IBL_CDF_FILTERING"));return new p.$({engine:this._engine,name:"HDRIrradianceFiltering",vertexShader:"hdrIrradianceFiltering",fragmentShader:"hdrIrradianceFiltering",samplerNames:n,uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale"],useShaderStore:!0,defines:r,onCompiled:t,shaderLanguage:s?1:0,extraInitializationsAsync:async()=>{s?await Promise.all([i.e(858).then(i.bind(i,858)),Promise.all([i.e(2703),i.e(4972)]).then(i.bind(i,64972))]):await Promise.all([i.e(4619).then(i.bind(i,94619)),Promise.all([i.e(8481),i.e(8961)]).then(i.bind(i,18961))])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this.useCdf&&(this._cdfGenerator=new g.O(this._engine),this._cdfGenerator.iblSource=e,await this._cdfGenerator.renderWhenReady()),this._effectRenderer=new p.J(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync();const t=this._prefilterInternal(e);return this._effectRenderer.dispose(),this._effectWrapper.dispose(),this._cdfGenerator?.dispose(),t}}var b=i(42683);i(69764);class x extends s.t{set isBlocking(e){this._isBlocking=e}get isBlocking(){return this._isBlocking}set rotationY(e){this._rotationY=e,this.setReflectionTextureMatrix(r.uq.RotationY(this._rotationY))}get rotationY(){return this._rotationY}set boundingBoxSize(e){if(this._boundingBoxSize&&this._boundingBoxSize.equals(e))return;this._boundingBoxSize=e;const t=this.getScene();t&&t.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}constructor(e,t,i,s=!1,a=!0,h=!1,o=!1,l=null,u=null,f=!1,_=!1,p=!1){super(t),this._generateHarmonics=!0,this._onError=null,this._isBlocking=!0,this._rotationY=0,this.boundingBoxPosition=r.Pq.Zero(),this.onLoadObservable=new d.cP,e&&(this._coordinatesMode=n.g.CUBIC_MODE,this.name=e,this.url=e,this.hasAlpha=!1,this.isCube=!0,this._textureMatrix=r.uq.Identity(),this._prefilterOnLoad=o,this._prefilterIrradianceOnLoad=_,this._prefilterUsingCdf=p,this._onLoad=()=>{this.onLoadObservable.notifyObservers(this),l&&l()},this._onError=u,this.gammaSpace=h,this._noMipmap=s,this._size=i,this._supersample=f||p,this._generateHarmonics=a,this._texture=this._getFromCache(e,this._noMipmap,void 0,void 0,void 0,this.isCube),this._texture?this._texture.isReady?c.S0.SetImmediate((()=>this._onLoad())):this._texture.onLoadedObservable.add(this._onLoad):this.getScene()?.useDelayedTextureLoading?this.delayLoadState=4:this._loadTexture())}getClassName(){return"HDRCubeTexture"}_loadTexture(){const e=this._getEngine(),t=e.getCaps();let i=0;t.textureFloat&&t.textureFloatLinearFiltering?i=1:t.textureHalfFloat&&t.textureHalfFloatLinearFiltering&&(i=2);if(e._features.allowTexturePrefiltering&&(this._prefilterOnLoad||this._prefilterIrradianceOnLoad)){const t=this._onLoad,i=new u.F(e);this._onLoad=()=>{let r=Promise.resolve(null),s=Promise.resolve();if(this._prefilterIrradianceOnLoad){r=new m(e,{useCdf:this._prefilterUsingCdf}).prefilter(this)}this._prefilterOnLoad&&(s=i.prefilter(this)),Promise.all([r,s]).then((e=>{const i=e[0];if(this._prefilterIrradianceOnLoad&&i){this.irradianceTexture=i;const e=this.getScene();e&&e.markAllMaterialsAsDirty(1)}t&&t()}))}}this._texture=e.createRawCubeTextureFromUrl(this.url,this.getScene(),this._size,4,i,this._noMipmap,(e=>{this.lodGenerationOffset=0,this.lodGenerationScale=.8;const t=(0,a.VH)(e,this._size,this._supersample);if(this._generateHarmonics){const e=h.d.ConvertCubeMapToSphericalPolynomial(t);this.sphericalPolynomial=e}const r=[];let s=null,n=null;for(let e=0;e<6;e++){2===i?n=new Uint16Array(this._size*this._size*3):0===i&&(s=new Uint8Array(this._size*this._size*3));const a=t[x._FacesMapping[e]];if(this.gammaSpace||n||s)for(let e=0;e<this._size*this._size;e++)if(this.gammaSpace&&(a[3*e+0]=Math.pow(a[3*e+0],l.rv),a[3*e+1]=Math.pow(a[3*e+1],l.rv),a[3*e+2]=Math.pow(a[3*e+2],l.rv)),n&&(n[3*e+0]=(0,b.LZ)(a[3*e+0]),n[3*e+1]=(0,b.LZ)(a[3*e+1]),n[3*e+2]=(0,b.LZ)(a[3*e+2])),s){let t=Math.max(255*a[3*e+0],0),i=Math.max(255*a[3*e+1],0),r=Math.max(255*a[3*e+2],0);const n=Math.max(Math.max(t,i),r);if(n>255){const e=255/n;t*=e,i*=e,r*=e}s[3*e+0]=t,s[3*e+1]=i,s[3*e+2]=r}n?r.push(n):s?r.push(s):r.push(a)}return r}),null,this._onLoad,this._onError)}clone(){const e=new x(this.url,this.getScene()||this._getEngine(),this._size,this._noMipmap,this._generateHarmonics,this.gammaSpace);return e.level=this.level,e.wrapU=this.wrapU,e.wrapV=this.wrapV,e.coordinatesIndex=this.coordinatesIndex,e.coordinatesMode=this.coordinatesMode,e}delayLoad(){4===this.delayLoadState&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,this._noMipmap),this._texture||this._loadTexture())}getReflectionTextureMatrix(){return this._textureMatrix}setReflectionTextureMatrix(e){this._textureMatrix=e,e.updateFlag!==this._textureMatrix.updateFlag&&e.isIdentity()!==this._textureMatrix.isIdentity()&&this.getScene()?.markAllMaterialsAsDirty(1,(e=>-1!==e.getActiveTextures().indexOf(this)))}dispose(){this.onLoadObservable.clear(),super.dispose()}static Parse(e,t,i){let s=null;return e.name&&!e.isRenderTarget&&(s=new x(i+e.name,t,e.size,e.noMipmap,e.generateHarmonics,e.useInGammaSpace),s.name=e.name,s.hasAlpha=e.hasAlpha,s.level=e.level,s.coordinatesMode=e.coordinatesMode,s.isBlocking=e.isBlocking),s&&(e.boundingBoxPosition&&(s.boundingBoxPosition=r.Pq.FromArray(e.boundingBoxPosition)),e.boundingBoxSize&&(s.boundingBoxSize=r.Pq.FromArray(e.boundingBoxSize)),e.rotationY&&(s.rotationY=e.rotationY)),s}serialize(){if(!this.name)return null;const e={};return e.name=this.name,e.hasAlpha=this.hasAlpha,e.isCube=!0,e.level=this.level,e.size=this._size,e.coordinatesMode=this.coordinatesMode,e.useInGammaSpace=this.gammaSpace,e.generateHarmonics=this._generateHarmonics,e.customType="BABYLON.HDRCubeTexture",e.noMipmap=this._noMipmap,e.isBlocking=this._isBlocking,e.rotationY=this._rotationY,e}}x._FacesMapping=["right","left","up","down","front","back"],(0,o.Y5)("BABYLON.HDRCubeTexture",x)},45384:(e,t,i)=>{i.d(t,{a:()=>n});var r=i(998),s=i(16945);class n{constructor(e){this.name=s.v.NAME_PROCEDURALTEXTURE,this.scene=e}register(){this.scene._beforeClearStage.registerStep(s.v.STEP_BEFORECLEAR_PROCEDURALTEXTURE,this,this._beforeClear)}rebuild(){}dispose(){}_beforeClear(){if(this.scene.proceduralTexturesEnabled){r.S0.StartPerformanceCounter("Procedural textures",this.scene.proceduralTextures.length>0);for(let e=0;e<this.scene.proceduralTextures.length;e++){const t=this.scene.proceduralTextures[e];t._shouldRender()&&t.render()}r.S0.EndPerformanceCounter("Procedural textures",this.scene.proceduralTextures.length>0)}}}},48963:(e,t,i)=>{i.d(t,{p:()=>p});var r=i(75524),s=i(79259),n=i(99848),a=i(95616),h=i(16945),o=i(28986),d=i(7481),c=i(75474),l=i(45384),u=i(56552),f=i(6315),_=i(35476);class p extends d.g{get shaderLanguage(){return this._shaderLanguage}constructor(e,t,i,r,s=null,o=!0,c=!1,u=0){super(null,r,!o),this.isEnabled=!0,this.autoClear=!0,this.onGeneratedObservable=new n.cP,this.onBeforeGenerationObservable=new n.cP,this.nodeMaterialSource=null,this.defines="",this._textures={},this._currentRefreshId=-1,this._frameId=-1,this._refreshRate=1,this._vertexBuffers={},this._uniforms=new Array,this._samplers=new Array,this._floats={},this._ints={},this._floatsArrays={},this._colors3={},this._colors4={},this._vectors2={},this._vectors3={},this._vectors4={},this._matrices={},this._fallbackTextureUsed=!1,this._cachedDefines=null,this._contentUpdateId=-1,this._rtWrapper=null,null===s||s instanceof d.g?(this._options={},this._fallbackTexture=s):(this._options=s,this._fallbackTexture=s.fallbackTexture??null),this._shaderLanguage=this._options.shaderLanguage??0;let p=(r=this.getScene()||f.q.LastCreatedScene)._getComponent(h.v.NAME_PROCEDURALTEXTURE);p||(p=new l.a(r),r._addComponent(p)),r.proceduralTextures.push(this),this._fullEngine=r.getEngine(),this.name=e,this.isRenderTarget=!0,this._size=t,this._textureType=u,this._generateMipMaps=o,this._drawWrapper=new _.E(this._fullEngine),this.setFragment(i);const g=this._createRtWrapper(c,t,o,u);this._texture=g.texture;const m=[];m.push(1,1),m.push(-1,1),m.push(-1,-1),m.push(1,-1),this._vertexBuffers[a.R.PositionKind]=new a.R(this._fullEngine,m,a.R.PositionKind,!1,!1,2),this._createIndexBuffer()}_createRtWrapper(e,t,i,r){return e?(this._rtWrapper=this._fullEngine.createRenderTargetCubeTexture(t,{generateMipMaps:i,generateDepthBuffer:!1,generateStencilBuffer:!1,type:r,...this._options}),this.setFloat("face",0)):(this._rtWrapper=this._fullEngine.createRenderTargetTexture(t,{generateMipMaps:i,generateDepthBuffer:!1,generateStencilBuffer:!1,type:r,...this._options}),this._rtWrapper.is3D&&(this.setFloat("layer",0),this.setInt("layerNum",0))),this._rtWrapper}getEffect(){return this._drawWrapper.effect}_setEffect(e){this._drawWrapper.effect=e}getContent(){return this._contentData&&this._frameId===this._contentUpdateId||(this._contentData?this._contentData.then((e=>{this._contentData=this.readPixels(0,0,e),this._contentUpdateId=this._frameId})):(this._contentData=this.readPixels(0,0),this._contentUpdateId=this._frameId)),this._contentData}_createIndexBuffer(){const e=this._fullEngine,t=[];t.push(0),t.push(1),t.push(2),t.push(0),t.push(2),t.push(3),this._indexBuffer=e.createIndexBuffer(t)}_rebuild(){const e=this._vertexBuffers[a.R.PositionKind];e&&e._rebuild(),this._createIndexBuffer(),this.refreshRate===c.$.REFRESHRATE_RENDER_ONCE&&(this.refreshRate=c.$.REFRESHRATE_RENDER_ONCE)}reset(){this._drawWrapper.effect?.dispose(),this._drawWrapper.effect=null,this._cachedDefines=null}_getDefines(){return this.defines}executeWhenReady(e){if(this.isReady())return void e(this);const t=this.getEffect();t&&t.executeWhenCompiled((()=>{e(this)}))}isReady(){const e=this._fullEngine;if(this.nodeMaterialSource)return this._drawWrapper.effect.isReady();if(!this._fragment)return!1;if(this._fallbackTextureUsed)return!0;if(!this._texture)return!1;const t=this._getDefines();if(this._drawWrapper.effect&&t===this._cachedDefines&&this._drawWrapper.effect.isReady())return!0;const r={vertex:"procedural",fragmentElement:this._fragment.fragmentElement,fragmentSource:this._fragment.fragmentSource,fragment:"string"==typeof this._fragment?this._fragment:void 0};return this._cachedDefines!==t&&(this._cachedDefines=t,this._drawWrapper.effect=e.createEffect(r,[a.R.PositionKind],this._uniforms,this._samplers,t,void 0,void 0,(()=>{this._rtWrapper?.dispose(),this._rtWrapper=this._texture=null,this._fallbackTexture&&(this._texture=this._fallbackTexture._texture,this._texture&&this._texture.incrementReferences()),this._fallbackTextureUsed=!0}),void 0,this._shaderLanguage,(async()=>{this._options.extraInitializationsAsync?1===this.shaderLanguage?await Promise.all([i.e(4005).then(i.bind(i,14005)),this._options.extraInitializationsAsync()]):await Promise.all([i.e(7156).then(i.bind(i,17156)),this._options.extraInitializationsAsync()]):1===this.shaderLanguage?await i.e(4005).then(i.bind(i,14005)):await i.e(7156).then(i.bind(i,17156))}))),this._drawWrapper.effect.isReady()}resetRefreshCounter(){this._currentRefreshId=-1}setFragment(e){this._fragment=e}get refreshRate(){return this._refreshRate}set refreshRate(e){this._refreshRate=e,this.resetRefreshCounter()}_shouldRender(){return this.isEnabled&&this.isReady()&&this._texture?!this._fallbackTextureUsed&&(-1===this._currentRefreshId||this.refreshRate===this._currentRefreshId?(this._currentRefreshId=1,this._frameId++,!0):(this._currentRefreshId++,!1)):(this._texture&&(this._texture.isReady=!1),!1)}getRenderSize(){return this._size}resize(e,t){if(this._fallbackTextureUsed||!this._rtWrapper||!this._texture)return;const i=this._texture.isCube;this._rtWrapper.dispose();const r=this._createRtWrapper(i,e,t,this._textureType);this._texture=r.texture,this._size=e,this._generateMipMaps=t}_checkUniform(e){-1===this._uniforms.indexOf(e)&&this._uniforms.push(e)}setTexture(e,t){return-1===this._samplers.indexOf(e)&&this._samplers.push(e),this._textures[e]=t,this}setFloat(e,t){return this._checkUniform(e),this._floats[e]=t,this}setInt(e,t){return this._checkUniform(e),this._ints[e]=t,this}setFloats(e,t){return this._checkUniform(e),this._floatsArrays[e]=t,this}setColor3(e,t){return this._checkUniform(e),this._colors3[e]=t,this}setColor4(e,t){return this._checkUniform(e),this._colors4[e]=t,this}setVector2(e,t){return this._checkUniform(e),this._vectors2[e]=t,this}setVector3(e,t){return this._checkUniform(e),this._vectors3[e]=t,this}setVector4(e,t){return this._checkUniform(e),this._vectors4[e]=t,this}setMatrix(e,t){return this._checkUniform(e),this._matrices[e]=t,this}render(e){const t=this.getScene();if(!t)return;const i=this._fullEngine;if(i.enableEffect(this._drawWrapper),this.onBeforeGenerationObservable.notifyObservers(this),i.setState(!1),!this.nodeMaterialSource){for(const e in this._textures)this._drawWrapper.effect.setTexture(e,this._textures[e]);for(const e in this._ints)this._drawWrapper.effect.setInt(e,this._ints[e]);for(const e in this._floats)this._drawWrapper.effect.setFloat(e,this._floats[e]);for(const e in this._floatsArrays)this._drawWrapper.effect.setArray(e,this._floatsArrays[e]);for(const e in this._colors3)this._drawWrapper.effect.setColor3(e,this._colors3[e]);for(const e in this._colors4){const t=this._colors4[e];this._drawWrapper.effect.setFloat4(e,t.r,t.g,t.b,t.a)}for(const e in this._vectors2)this._drawWrapper.effect.setVector2(e,this._vectors2[e]);for(const e in this._vectors3)this._drawWrapper.effect.setVector3(e,this._vectors3[e]);for(const e in this._vectors4)this._drawWrapper.effect.setVector4(e,this._vectors4[e]);for(const e in this._matrices)this._drawWrapper.effect.setMatrix(e,this._matrices[e])}if(!this._texture||!this._rtWrapper)return;i._debugPushGroup?.(`procedural texture generation for ${this.name}`,1);const r=i.currentViewport;if(this.isCube)for(let e=0;e<6;e++)i.bindFramebuffer(this._rtWrapper,e,void 0,void 0,!0),i.bindBuffers(this._vertexBuffers,this._indexBuffer,this._drawWrapper.effect),this._drawWrapper.effect.setFloat("face",e),this.autoClear&&i.clear(t.clearColor,!0,!1,!1),i.drawElementsType(o.i.TriangleFillMode,0,6),i.unBindFramebuffer(this._rtWrapper,!0);else{let e=1;this._rtWrapper.is3D?e=this._rtWrapper.depth:this._rtWrapper.is2DArray&&(e=this._rtWrapper.layers);for(let r=0;r<e;r++){if(i.bindFramebuffer(this._rtWrapper,0,void 0,void 0,!0,0,r),i.bindBuffers(this._vertexBuffers,this._indexBuffer,this._drawWrapper.effect),this._rtWrapper.is3D||this._rtWrapper.is2DArray){this._drawWrapper.effect?.setFloat("layer",1!==e?r/(e-1):0),this._drawWrapper.effect?.setInt("layerNum",r);for(const e in this._textures)this._drawWrapper.effect.setTexture(e,this._textures[e])}this.autoClear&&i.clear(t.clearColor,!0,!1,!1),i.drawElementsType(o.i.TriangleFillMode,0,6),i.unBindFramebuffer(this._rtWrapper,!this._generateMipMaps)}}r&&i.setViewport(r),this.isCube&&i.generateMipMapsForCubemap(this._texture,!0),i._debugPopGroup?.(1),this.onGenerated&&this.onGenerated(),this.onGeneratedObservable.notifyObservers(this)}clone(){const e=this.getSize(),t=new p(this.name,e.width,this._fragment,this.getScene(),this._fallbackTexture,this._generateMipMaps);return t.hasAlpha=this.hasAlpha,t.level=this.level,t.coordinatesMode=this.coordinatesMode,t}dispose(){const e=this.getScene();if(!e)return;const t=e.proceduralTextures.indexOf(this);t>=0&&e.proceduralTextures.splice(t,1);const i=this._vertexBuffers[a.R.PositionKind];i&&(i.dispose(),this._vertexBuffers[a.R.PositionKind]=null),this._indexBuffer&&this._fullEngine._releaseBuffer(this._indexBuffer)&&(this._indexBuffer=null),this.onGeneratedObservable.clear(),this.onBeforeGenerationObservable.clear(),super.dispose()}}(0,r.Cg)([(0,s.lK)()],p.prototype,"isEnabled",void 0),(0,r.Cg)([(0,s.lK)()],p.prototype,"autoClear",void 0),(0,r.Cg)([(0,s.lK)()],p.prototype,"_generateMipMaps",void 0),(0,r.Cg)([(0,s.lK)()],p.prototype,"_size",void 0),(0,r.Cg)([(0,s.lK)()],p.prototype,"refreshRate",null),(0,u.Y5)("BABYLON.ProceduralTexture",p)},68571:(e,t,i)=>{i.d(t,{F:()=>a});var r=i(62956),s=i(84867),n=i(84255);class a{constructor(e,t={}){this._lodGenerationOffset=0,this._lodGenerationScale=.8,this.quality=4096,this.hdrScale=1,this._engine=e,this.hdrScale=t.hdrScale||this.hdrScale,this.quality=t.quality||this.quality}_createRenderTarget(e){let t=0;this._engine.getCaps().textureHalfFloatRender?t=2:this._engine.getCaps().textureFloatRender&&(t=1);const i=this._engine.createRenderTargetCubeTexture(e,{format:5,type:t,createMipMaps:!0,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:1,label:"HDR_Radiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(i.texture,0,0,0),this._engine.updateTextureSamplingMode(3,i.texture,!0),i}_prefilterInternal(e){const t=e.getSize().width,i=(0,s.ILog2)(t)+1,n=this._effectWrapper.effect,a=this._createRenderTarget(t);this._effectRenderer.saveStates(),this._effectRenderer.setViewport();const h=e.getInternalTexture();h&&this._engine.updateTextureSamplingMode(3,h,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const o=[[new r.Pq(0,0,-1),new r.Pq(0,-1,0),new r.Pq(1,0,0)],[new r.Pq(0,0,1),new r.Pq(0,-1,0),new r.Pq(-1,0,0)],[new r.Pq(1,0,0),new r.Pq(0,0,1),new r.Pq(0,1,0)],[new r.Pq(1,0,0),new r.Pq(0,0,-1),new r.Pq(0,-1,0)],[new r.Pq(1,0,0),new r.Pq(0,-1,0),new r.Pq(0,0,1)],[new r.Pq(-1,0,0),new r.Pq(0,-1,0),new r.Pq(0,0,-1)]];n.setFloat("hdrScale",this.hdrScale),n.setFloat2("vFilteringInfo",e.getSize().width,i),n.setTexture("inputTexture",e);for(let e=0;e<6;e++){n.setVector3("up",o[e][0]),n.setVector3("right",o[e][1]),n.setVector3("front",o[e][2]);for(let r=0;r<i;r++){this._engine.bindFramebuffer(a,e,void 0,void 0,!0,r),this._effectRenderer.applyEffectWrapper(this._effectWrapper);let i=Math.pow(2,(r-this._lodGenerationOffset)/this._lodGenerationScale)/t;0===r&&(i=0),n.setFloat("alphaG",i),this._effectRenderer.draw()}}this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),this._engine._releaseTexture(e._texture);const d=a.texture.type,c=a.texture.format;return a._swapAndDie(e._texture),e._texture.type=d,e._texture.format=c,e.gammaSpace=!1,e.lodGenerationOffset=this._lodGenerationOffset,e.lodGenerationScale=this._lodGenerationScale,e._prefiltered=!0,e}_createEffect(e,t){const r=[];e.gammaSpace&&r.push("#define GAMMA_INPUT"),r.push("#define NUM_SAMPLES "+this.quality+"u");const s=this._engine.isWebGPU;return new n.$({engine:this._engine,name:"hdrFiltering",vertexShader:"hdrFiltering",fragmentShader:"hdrFiltering",samplerNames:["inputTexture"],uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale","alphaG"],useShaderStore:!0,defines:r,onCompiled:t,shaderLanguage:s?1:0,extraInitializationsAsync:async()=>{s?await Promise.all([i.e(2248).then(i.bind(i,92248)),Promise.all([i.e(2703),i.e(274)]).then(i.bind(i,50274))]):await Promise.all([i.e(6109).then(i.bind(i,86109)),Promise.all([i.e(8481),i.e(5779)]).then(i.bind(i,55779))])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this._effectRenderer=new n.J(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync(),this._prefilterInternal(e),this._effectRenderer.dispose(),this._effectWrapper.dispose()}}},73647:(e,t,i)=>{i.d(t,{D:()=>s});var r=i(79923);class s{static ConvertPanoramaToCubemap(e,t,i,r,s=!1){if(!e)throw"ConvertPanoramaToCubemap: input cannot be null";if(e.length!=t*i*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(r,this.FACE_FRONT,e,t,i,s),back:this.CreateCubemapTexture(r,this.FACE_BACK,e,t,i,s),left:this.CreateCubemapTexture(r,this.FACE_LEFT,e,t,i,s),right:this.CreateCubemapTexture(r,this.FACE_RIGHT,e,t,i,s),up:this.CreateCubemapTexture(r,this.FACE_UP,e,t,i,s),down:this.CreateCubemapTexture(r,this.FACE_DOWN,e,t,i,s),size:r,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(e,t,i,r,s,n=!1){const a=new ArrayBuffer(e*e*4*3),h=new Float32Array(a),o=n?Math.max(1,Math.round(r/4/e)):1,d=1/o,c=d*d,l=t[1].subtract(t[0]).scale(d/e),u=t[3].subtract(t[2]).scale(d/e),f=1/e;let _=0;for(let n=0;n<e;n++)for(let a=0;a<o;a++){let a=t[0],p=t[2];for(let t=0;t<e;t++)for(let d=0;d<o;d++){const o=p.subtract(a).scale(_).add(a);o.normalize();const d=this.CalcProjectionSpherical(o,i,r,s);h[n*e*3+3*t+0]+=d.r*c,h[n*e*3+3*t+1]+=d.g*c,h[n*e*3+3*t+2]+=d.b*c,a=a.add(l),p=p.add(u)}_+=f*d}return h}static CalcProjectionSpherical(e,t,i,r){let s=Math.atan2(e.z,e.x);const n=Math.acos(e.y);for(;s<-Math.PI;)s+=2*Math.PI;for(;s>Math.PI;)s-=2*Math.PI;let a=s/Math.PI;const h=n/Math.PI;a=.5*a+.5;let o=Math.round(a*i);o<0?o=0:o>=i&&(o=i-1);let d=Math.round(h*r);d<0?d=0:d>=r&&(d=r-1);const c=r-d-1;return{r:t[c*i*3+3*o+0],g:t[c*i*3+3*o+1],b:t[c*i*3+3*o+2]}}}s.FACE_LEFT=[new r.Pq(-1,-1,-1),new r.Pq(1,-1,-1),new r.Pq(-1,1,-1),new r.Pq(1,1,-1)],s.FACE_RIGHT=[new r.Pq(1,-1,1),new r.Pq(-1,-1,1),new r.Pq(1,1,1),new r.Pq(-1,1,1)],s.FACE_FRONT=[new r.Pq(1,-1,-1),new r.Pq(1,-1,1),new r.Pq(1,1,-1),new r.Pq(1,1,1)],s.FACE_BACK=[new r.Pq(-1,-1,1),new r.Pq(-1,-1,-1),new r.Pq(-1,1,1),new r.Pq(-1,1,-1)],s.FACE_DOWN=[new r.Pq(1,1,-1),new r.Pq(1,1,1),new r.Pq(-1,1,-1),new r.Pq(-1,1,1)],s.FACE_UP=[new r.Pq(-1,-1,-1),new r.Pq(-1,-1,1),new r.Pq(1,-1,-1),new r.Pq(1,-1,1)]},82814:(e,t,i)=>{i.d(t,{I9:()=>c,LT:()=>o,NK:()=>a,VH:()=>h});var r=i(73647);function s(e,t,i,r,s,n){s>0?(s=function(e,t){return t>1023?e*Math.pow(2,1023)*Math.pow(2,t-1023):t<-1074?e*Math.pow(2,-1074)*Math.pow(2,t+1074):e*Math.pow(2,t)}(1,s-136),e[n+0]=t*s,e[n+1]=i*s,e[n+2]=r*s):(e[n+0]=0,e[n+1]=0,e[n+2]=0)}function n(e,t){let i="",r="";for(let s=t;s<e.length-t&&(r=String.fromCharCode(e[s]),"\n"!=r);s++)i+=r;return i}function a(e){let t=0,i=0,r=n(e,0);if("#"!=r[0]||"?"!=r[1])throw"Bad HDR Format.";let s=!1,a=!1,h=0;do{h+=r.length+1,r=n(e,h),"FORMAT=32-bit_rle_rgbe"==r?a=!0:0==r.length&&(s=!0)}while(!s);if(!a)throw"HDR Bad header format, unsupported FORMAT";h+=r.length+1,r=n(e,h);const o=/^-Y (.*) \+X (.*)$/g.exec(r);if(!o||o.length<3)throw"HDR Bad header format, no size";if(i=parseInt(o[2]),t=parseInt(o[1]),i<8||i>32767)throw"HDR Bad header format, unsupported size";return h+=r.length+1,{height:t,width:i,dataPosition:h}}function h(e,t,i=!1){const s=new Uint8Array(e),n=a(s),h=o(s,n);return r.D.ConvertPanoramaToCubemap(h,n.width,n.height,t,i)}function o(e,t){return function(e,t){let i=t.height;const r=t.width;let n,a,h,o,c,l=t.dataPosition,u=0,f=0,_=0;const p=new ArrayBuffer(4*r),g=new Uint8Array(p),m=new ArrayBuffer(t.width*t.height*4*3),b=new Float32Array(m);for(;i>0;){if(n=e[l++],a=e[l++],h=e[l++],o=e[l++],2!=n||2!=a||128&h||t.width<8||t.width>32767)return d(e,t);if((h<<8|o)!=r)throw"HDR Bad header format, wrong scan line width";for(u=0,_=0;_<4;_++)for(f=(_+1)*r;u<f;)if(n=e[l++],a=e[l++],n>128){if(c=n-128,0==c||c>f-u)throw"HDR Bad Format, bad scanline data (run)";for(;c-- >0;)g[u++]=a}else{if(c=n,0==c||c>f-u)throw"HDR Bad Format, bad scanline data (non-run)";if(g[u++]=a,--c>0)for(let t=0;t<c;t++)g[u++]=e[l++]}for(_=0;_<r;_++)n=g[_],a=g[_+r],h=g[_+2*r],o=g[_+3*r],s(b,n,a,h,o,(t.height-i)*r*3+3*_);i--}return b}(e,t)}function d(e,t){let i=t.height;const r=t.width;let n,a,h,o,d,c=t.dataPosition;const l=new ArrayBuffer(t.width*t.height*4*3),u=new Float32Array(l);for(;i>0;){for(d=0;d<t.width;d++)n=e[c++],a=e[c++],h=e[c++],o=e[c++],s(u,n,a,h,o,(t.height-i)*r*3+3*d);i--}return u}const c={RGBE_ReadHeader:a,GetCubeMapTextureData:h,RGBE_ReadPixels:o}},89974:(e,t,i)=>{i.d(t,{O:()=>u});var r=i(7481),s=i(48963),n=i(77891),a=i(79923),h=i(96041),o=i(99848),d=i(93856),c=i(45503),l=i(6315);class u{get iblSource(){return this._iblSource}set iblSource(e){this._iblSource!==e&&(this._disposeTextures(),this._iblSource=e,e&&(e.isCube,e.isReadyOrNotBlocking()?this._recreateAssetsFromNewIbl():e.onLoadObservable.addOnce(this._recreateAssetsFromNewIbl.bind(this,e))))}_recreateAssetsFromNewIbl(){this._debugPass&&this._debugPass.dispose(),this._createTextures(),this._debugPass&&this._createDebugPass()}getIcdfTexture(){return this._icdfPT?this._icdfPT:this._dummyTexture}setDebugDisplayParams(e,t,i,r){this._debugSizeParams.set(e,t,i,r)}get debugPassName(){return this._debugPassName}getDebugPassPP(){return this._debugPass||this._createDebugPass(),this._debugPass}constructor(e){this.debugEnabled=!1,this._debugSizeParams=new a.IU(0,0,1,1),this._debugPassName="CDF Debug",this.onGeneratedObservable=new o.cP,e?u._IsScene(e)?this._scene=e:this._engine=e:this._scene=l.q.LastCreatedScene,this._scene&&(this._engine=this._scene.getEngine());const t=new Uint16Array([0,0,0,255]);this._dummyTexture=new h.I(t,1,1,d.Engine.TEXTUREFORMAT_RGBA,e,!1,!1,void 0,2),this._scene&&u._SceneComponentInitialization(this._scene)}_createTextures(){const e=this._iblSource?{width:this._iblSource.getSize().width,height:this._iblSource.getSize().height}:{width:1,height:1};this._iblSource||(this._iblSource=h.I.CreateRTexture(new Uint8Array([255]),1,1,this._engine,!1,!1,1,0),this._iblSource.name="Placeholder IBL Source"),this._iblSource.isCube&&(e.width*=4,e.height*=2,e.width=1<<Math.floor(Math.log2(e.width)),e.height=1<<Math.floor(Math.log2(e.height)));const t=this._engine.isWebGPU,r={generateDepthBuffer:!1,generateMipMaps:!1,format:6,type:1,samplingMode:1,shaderLanguage:t?1:0,gammaSpace:!1,extraInitializationsAsync:async()=>{t?await Promise.all([i.e(8900).then(i.bind(i,18900)),i.e(1245).then(i.bind(i,61245)),i.e(2099).then(i.bind(i,62099))]):await Promise.all([i.e(7671).then(i.bind(i,47671)),i.e(4030).then(i.bind(i,24030)),i.e(234).then(i.bind(i,80234))])}},n={generateDepthBuffer:!1,generateMipMaps:!1,format:5,type:2,samplingMode:1,shaderLanguage:t?1:0,gammaSpace:!1,extraInitializationsAsync:async()=>{t?await Promise.all([i.e(461).then(i.bind(i,10461))]):await Promise.all([i.e(982).then(i.bind(i,90982))])}};this._cdfyPT=new s.p("cdfyTexture",{width:e.width,height:e.height+1},"iblCdfy",this._scene,r,!1,!1),this._cdfyPT.autoClear=!1,this._cdfyPT.setTexture("iblSource",this._iblSource),this._cdfyPT.setInt("iblHeight",e.height),this._cdfyPT.wrapV=0,this._cdfyPT.refreshRate=0,this._iblSource.isCube&&(this._cdfyPT.defines="#define IBL_USE_CUBE_MAP\n"),this._cdfxPT=new s.p("cdfxTexture",{width:e.width+1,height:1},"iblCdfx",this._scene,r,!1,!1),this._cdfxPT.autoClear=!1,this._cdfxPT.setTexture("cdfy",this._cdfyPT),this._cdfxPT.refreshRate=0,this._cdfxPT.wrapU=0,this._scaledLuminancePT=new s.p("iblScaledLuminance",{width:e.width,height:e.height},"iblScaledLuminance",this._scene,{...r,samplingMode:3,generateMipMaps:!0},!0,!1),this._scaledLuminancePT.autoClear=!1,this._scaledLuminancePT.setTexture("iblSource",this._iblSource),this._scaledLuminancePT.setInt("iblHeight",e.height),this._scaledLuminancePT.setInt("iblWidth",e.width),this._scaledLuminancePT.refreshRate=0,this._iblSource.isCube&&(this._scaledLuminancePT.defines="#define IBL_USE_CUBE_MAP\n"),this._icdfPT=new s.p("icdfTexture",{width:e.width,height:e.height},"iblIcdf",this._scene,n,!1,!1),this._icdfPT.autoClear=!1,this._icdfPT.setTexture("cdfy",this._cdfyPT),this._icdfPT.setTexture("cdfx",this._cdfxPT),this._icdfPT.setTexture("iblSource",this._iblSource),this._icdfPT.setTexture("scaledLuminanceSampler",this._scaledLuminancePT),this._icdfPT.refreshRate=0,this._icdfPT.wrapV=0,this._icdfPT.wrapU=0,this._iblSource.isCube&&(this._icdfPT.defines="#define IBL_USE_CUBE_MAP\n"),this._icdfPT.onGeneratedObservable.addOnce((()=>{this.onGeneratedObservable.notifyObservers()}))}_disposeTextures(){this._cdfyPT?.dispose(),this._cdfxPT?.dispose(),this._icdfPT?.dispose(),this._scaledLuminancePT?.dispose()}_createDebugPass(){this._debugPass&&this._debugPass.dispose();const e=this._engine.isWebGPU,t={width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight(),samplingMode:r.g.BILINEAR_SAMPLINGMODE,engine:this._engine,textureType:0,uniforms:["sizeParams"],samplers:["cdfy","icdf","cdfx","iblSource"],defines:this._iblSource?.isCube?"#define IBL_USE_CUBE_MAP\n":"",shaderLanguage:e?1:0,extraInitializations:(e,t)=>{e?t.push(i.e(8137).then(i.bind(i,48137))):t.push(i.e(6762).then(i.bind(i,46762)))}};this._debugPass=new n.w(this._debugPassName,"iblCdfDebug",t);const s=this._debugPass.getEffect();s&&(s.defines=this._iblSource?.isCube?"#define IBL_USE_CUBE_MAP\n":""),this._iblSource?.isCube&&this._debugPass.updateEffect("#define IBL_USE_CUBE_MAP\n"),this._debugPass.onApplyObservable.add((e=>{e.setTexture("cdfy",this._cdfyPT),e.setTexture("icdf",this._icdfPT),e.setTexture("cdfx",this._cdfxPT),e.setTexture("iblSource",this._iblSource),e.setFloat4("sizeParams",this._debugSizeParams.x,this._debugSizeParams.y,this._debugSizeParams.z,this._debugSizeParams.w)}))}isReady(){return this._iblSource&&"Placeholder IBL Source"!==this._iblSource.name&&this._iblSource.isReady()&&this._cdfyPT&&this._cdfyPT.isReady()&&this._icdfPT&&this._icdfPT.isReady()&&this._cdfxPT&&this._cdfxPT.isReady()&&this._scaledLuminancePT&&this._scaledLuminancePT.isReady()}renderWhenReady(){this._icdfPT.onGeneratedObservable.addOnce((()=>{this.onGeneratedObservable.notifyObservers()}));const e=[],t=[this._cdfyPT,this._cdfxPT,this._scaledLuminancePT,this._icdfPT];return t.forEach((t=>{e.push(new Promise((e=>{t.isReady()?e():t.getEffect().executeWhenCompiled((()=>{e()}))})))})),Promise.all(e).then((()=>{t.forEach((e=>{e.render()}))}))}dispose(){this._disposeTextures(),this._dummyTexture.dispose(),this._debugPass&&this._debugPass.dispose(),this.onGeneratedObservable.clear()}static _IsScene(e){return"Scene"===e.getClassName()}}u._SceneComponentInitialization=e=>{throw(0,c.n)("IblCdfGeneratorSceneComponentSceneComponent")}}}]);