"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[5234,9928],{55234:(e,n,t)=>{t.d(n,{cU:()=>m,gW:()=>D,o5:()=>h,ow:()=>_});var r=t(998),a=t(79923),i=t(84867),o=t(77517),s=t(90854),l=t(82667),u=(t(48802),t(77891)),c=t(51137);t(97126),t(89928),t(69764);const p="image/png",d=2,f=[134,22,135,150,246,214,150,54];function m(e){const n=new DataView(e.buffer,e.byteOffset,e.byteLength);let t=0;for(let e=0;e<f.length;e++)if(n.getUint8(t++)!==f[e])return c.V.Error("Not a babylon environment map"),null;let r="",a=0;for(;a=n.getUint8(t++);)r+=String.fromCharCode(a);let i=JSON.parse(r);return i=g(i),i.binaryDataPosition=t,i.specular&&(i.specular.lodGenerationScale=i.specular.lodGenerationScale||.8),i}function g(e){if(e.version>d)throw new Error(`Unsupported babylon environment map version "${e.version}". Latest supported version is "${d}".`);return 2===e.version?e:e={...e,version:2,imageType:p}}function w(e,n){const t=(n=g(n)).specular;let r=Math.log2(n.width);if(r=Math.round(r)+1,t.mipmaps.length!==6*r)throw new Error(`Unsupported specular mipmaps number "${t.mipmaps.length}"`);const a=new Array(r);for(let i=0;i<r;i++){a[i]=new Array(6);for(let r=0;r<6;r++){const o=t.mipmaps[6*i+r];a[i][r]=new Uint8Array(e.buffer,e.byteOffset+n.binaryDataPosition+o.position,o.length)}}return a}function y(e,n){n=g(n);const t=new Array(6),r=n.irradiance?.irradianceTexture;if(r){if(6!==r.faces.length)throw new Error(`Incorrect irradiance texture faces number "${r.faces.length}"`);for(let a=0;a<6;a++){const i=r.faces[a];t[a]=new Uint8Array(e.buffer,e.byteOffset+n.binaryDataPosition+i.position,i.length)}}return t}function h(e,n,t){const r=(t=g(t)).specular;if(!r)return Promise.resolve([]);e._lodGenerationScale=r.lodGenerationScale;const i=[],o=w(n,t);i.push(b(e,o,t.imageType));const s=t.irradiance?.irradianceTexture;if(s){const r=y(n,t);let o=null;t.irradiance?.irradianceTexture?.dominantDirection&&(o=a.Pq.FromArray(t.irradiance.irradianceTexture.dominantDirection)),i.push(T(e,r,s.size,t.imageType,o))}return Promise.all(i)}async function x(e,n,t,r,a,i,o,s,l,u,c){return await new Promise((p,d)=>{if(t){const t=n.createTexture(null,!0,!0,null,1,null,e=>{d(e)},e);r?.onEffectCreatedObservable.addOnce(s=>{s.executeWhenCompiled(()=>{r.externalTextureSamplerBinding=!0,r.onApply=r=>{r._bindTexture("textureSampler",t),r.setFloat2("scale",1,n._features.needsInvertingBitmap&&e instanceof ImageBitmap?-1:1)},n.scenes.length&&(n.scenes[0].postProcessManager.directRender([r],u,!0,i,o),n.restoreDefaultFramebuffer(),t.dispose(),URL.revokeObjectURL(a),p())})})}else{if(n._uploadImageToTexture(c,e,i,o),s){const t=l[o];t&&n._uploadImageToTexture(t._texture,e,i,0)}p()}})}async function b(e,n,t=p){const r=e.getEngine();e.format=5,e.type=0,e.generateMipMaps=!0,e._cachedAnisotropicFilteringLevel=null,r.updateTextureSamplingMode(3,e),await v(e,n,!0,t),e.isReady=!0}async function T(e,n,t,r=p,a=null){const i=e.getEngine(),o=new s.h(i,5),u=new l.t(i,o);e._irradianceTexture=u,u._dominantDirection=a,o.isCube=!0,o.format=5,o.type=0,o.generateMipMaps=!0,o._cachedAnisotropicFilteringLevel=null,o.generateMipMaps=!0,o.width=t,o.height=t,i.updateTextureSamplingMode(3,o),await v(o,[n],!1,r),i.generateMipMapsForCubemap(o),o.isReady=!0}async function v(e,n,a,o=p){if(!r.S0.IsExponentOfTwo(e.width))throw new Error("Texture size must be a power of two");const c=(0,i.ILog2)(e.width)+1,d=e.getEngine();let f=!1,m=!1,g=null,w=null,y=null;const h=d.getCaps();h.textureLOD?d._features.supportRenderAndCopyToLodForFloatTextures?h.textureHalfFloatRender&&h.textureHalfFloatLinearFiltering?(f=!0,e.type=2):h.textureFloatRender&&h.textureFloatLinearFiltering&&(f=!0,e.type=1):f=!1:(f=!1,m=a);let b=0;if(f)d.isWebGPU?(b=1,await t.e(371).then(t.bind(t,30371))):await t.e(9682).then(t.bind(t,9682)),g=new u.w("rgbdDecode","rgbdDecode",null,null,1,null,3,d,!1,void 0,e.type,void 0,null,!1,void 0,b),e._isRGBD=!1,e.invertY=!1,w=d.createRenderTargetCubeTexture(e.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:e.type,format:5});else if(e._isRGBD=!0,e.invertY=!0,m){const n=3;y={};const t=e._lodGenerationScale,r=e._lodGenerationOffset;for(let a=0;a<n;a++){const i=(c-1)*t+r,o=r+(i-r)*(1-a/(n-1)),u=Math.round(Math.min(Math.max(o,0),i)),p=new s.h(d,2);p.isCube=!0,p.invertY=!0,p.generateMipMaps=!1,d.updateTextureSamplingMode(2,p);const f=new l.t(null);switch(f._isCube=!0,f._texture=p,y[u]=f,a){case 0:e._lodTextureLow=f;break;case 1:e._lodTextureMid=f;break;case 2:e._lodTextureHigh=f}}}const T=[];for(let t=0;t<n.length;t++)for(let r=0;r<6;r++){const a=n[t][r],i=new Blob([a],{type:o}),s=URL.createObjectURL(i);let l;if(d._features.forceBitmapOverHTMLImageElement)l=d.createImageBitmap(i,{premultiplyAlpha:"none"}).then(async n=>await x(n,d,f,g,s,r,t,m,y,w,e));else{const n=new Image;n.src=s,l=new Promise((a,i)=>{n.onload=()=>{x(n,d,f,g,s,r,t,m,y,w,e).then(()=>a()).catch(e=>{i(e)})},n.onerror=e=>{i(e)}})}T.push(l)}if(await Promise.all(T),n.length<c){let t;const r=Math.pow(2,c-1-n.length),a=r*r*4;switch(e.type){case 0:t=new Uint8Array(a);break;case 2:t=new Uint16Array(a);break;case 1:t=new Float32Array(a)}for(let r=n.length;r<c;r++)for(let n=0;n<6;n++)d._uploadArrayBufferViewToTexture(w?.texture||e,t,n,r)}if(w){const n=e._irradianceTexture;e._irradianceTexture=null,d._releaseTexture(e),w._swapAndDie(e),e._irradianceTexture=n}g&&g.dispose(),m&&(e._lodTextureHigh&&e._lodTextureHigh._texture&&(e._lodTextureHigh._texture.isReady=!0),e._lodTextureMid&&e._lodTextureMid._texture&&(e._lodTextureMid._texture.isReady=!0),e._lodTextureLow&&e._lodTextureLow._texture&&(e._lodTextureLow._texture.isReady=!0))}function _(e,n){const t=(n=g(n)).irradiance;if(!t)return;const r=new o.Q;a.Pq.FromArrayToRef(t.x,0,r.x),a.Pq.FromArrayToRef(t.y,0,r.y),a.Pq.FromArrayToRef(t.z,0,r.z),a.Pq.FromArrayToRef(t.xx,0,r.xx),a.Pq.FromArrayToRef(t.yy,0,r.yy),a.Pq.FromArrayToRef(t.zz,0,r.zz),a.Pq.FromArrayToRef(t.yz,0,r.yz),a.Pq.FromArrayToRef(t.zx,0,r.zx),a.Pq.FromArrayToRef(t.xy,0,r.xy),e._sphericalPolynomial=r}function D(e,n,t,r,a){const i=b(e.getEngine().createRawCubeTexture(null,e.width,e.format,e.type,e.generateMipMaps,e.invertY,e.samplingMode,e._compression),n).then(()=>e);return e.onRebuildCallback=e=>({proxy:i,isReady:!0,isAsync:!0}),e._source=13,e._bufferViewArrayArray=n,e._lodGenerationScale=r,e._lodGenerationOffset=a,e._sphericalPolynomial=t,b(e,n).then(()=>(e.isReady=!0,e))}},89928:(e,n,t)=>{t.r(n),t.d(n,{Dispose:()=>f,DumpData:()=>d,DumpDataAsync:()=>p,DumpFramebuffer:()=>c,DumpTools:()=>m});var r=t(84255),a=t(998),i=t(84867),o=t(6315),s=t(51137);let l=null;async function u(){return l||(l=async function(){const e=o.q.LastCreatedEngine?.createCanvas(100,100)??new OffscreenCanvas(100,100);e instanceof OffscreenCanvas&&s.V.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");const{ThinEngine:n}=await Promise.resolve().then(t.bind(t,77008));if(!n.IsSupported){if(!e.getContext("bitmaprenderer"))throw new Error("DumpData: No WebGL or bitmap rendering context available. Cannot dump data.");return{canvas:e}}const a=new n(e,!1,{preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1});o.q.Instances.pop(),o.q.OnEnginesDisposedObservable.add(e=>{a&&e!==a&&!a.isDisposed&&0===o.q.Instances.length&&f()}),a.getCaps().parallelShaderCompile=void 0;const i=new r.J(a),{passPixelShader:l}=await t.e(9820).then(t.bind(t,79820)),u=new r.$({engine:a,name:l.name,fragmentShader:l.shader,samplerNames:["textureSampler"]});return{canvas:e,dumpEngine:{engine:a,renderer:i,wrapper:u}}}()),await l}async function c(e,n,t,r,a="image/png",i,o){const s=await t.readPixels(0,0,e,n);d(e,n,new Uint8Array(s.buffer),r,a,i,!0,void 0,o)}async function p(e,n,t,r="image/png",o,s=!1,l=!1,c){if(t instanceof Float32Array){const e=new Uint8Array(t.length);let n=t.length;for(;n--;){const r=t[n];e[n]=Math.round(255*(0,i.Clamp)(r))}t=e}const p=await u();return await new Promise(async i=>{if(p.dumpEngine){const r=p.dumpEngine;r.engine.setSize(e,n,!0);const a=r.engine.createRawTexture(t,e,n,5,!1,!s,1);r.renderer.setViewport(),r.renderer.applyEffectWrapper(r.wrapper),r.wrapper.effect._bindTexture("textureSampler",a),r.renderer.draw(),a.dispose()}else{const r=p.canvas.getContext("bitmaprenderer");p.canvas.width=e,p.canvas.height=n;const a=new ImageData(e,n);a.data.set(t);const i=await createImageBitmap(a,{premultiplyAlpha:"none",imageOrientation:s?"flipY":"from-image"});r.transferFromImageBitmap(i)}a.S0.ToBlob(p.canvas,e=>{if(!e)throw new Error("DumpData: Failed to convert canvas to blob.");void 0!==o&&a.S0.DownloadBlob(e,o);const n=new FileReader;n.onload=e=>{const n=e.target.result;i(n)},l?n.readAsArrayBuffer(e):n.readAsDataURL(e)},r,c)})}function d(e,n,t,r,a="image/png",i,o=!1,s=!1,l){void 0!==i||r||(i=""),p(e,n,t,a,i,o,s,l).then(e=>{r&&r(e)})}function f(){l&&(l?.then(e=>{e.canvas instanceof HTMLCanvasElement&&e.canvas.remove(),e.dumpEngine&&(e.dumpEngine.engine.dispose(),e.dumpEngine.renderer.dispose(),e.dumpEngine.wrapper.dispose())}),l=null)}const m={DumpData:d,DumpDataAsync:p,DumpFramebuffer:c,Dispose:f};a.S0.DumpData=d,a.S0.DumpDataAsync=p,a.S0.DumpFramebuffer=c}}]);