"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[5234,9928],{55234:(e,t,r)=>{r.d(t,{Hx:()=>w,Pu:()=>A,RZ:()=>m,UA:()=>D,cU:()=>h,gW:()=>F,o5:()=>_,ow:()=>M,p$:()=>R,qY:()=>S,ux:()=>v});var n=r(998),a=r(79923),i=r(84867),o=r(77517),s=r(81194),l=r(56526),c=r(87491),u=r(77891),p=r(51137),d=r(97126),f=r(89928);r(69764);const y="image/png",g=2,x=[134,22,135,150,246,214,150,54];function h(e){const t=new DataView(e.buffer,e.byteOffset,e.byteLength);let r=0;for(let e=0;e<x.length;e++)if(t.getUint8(r++)!==x[e])return p.V.Error("Not a babylon environment map"),null;let n="",a=0;for(;a=t.getUint8(r++);)n+=String.fromCharCode(a);let i=JSON.parse(n);return i=m(i),i.binaryDataPosition=r,i.specular&&(i.specular.lodGenerationScale=i.specular.lodGenerationScale||.8),i}function m(e){if(e.version>g)throw new Error(`Unsupported babylon environment map version "${e.version}". Latest supported version is "${g}".`);return 2===e.version?e:e={...e,version:2,imageType:y}}async function w(e,t={}){const r=e.getInternalTexture();if(!r)return Promise.reject("The cube texture is invalid.");const n=r.getEngine();if(2!==e.textureType&&1!==e.textureType&&0!==e.textureType&&0!==e.textureType&&7!==e.textureType&&-1!==e.textureType)return Promise.reject("The cube texture should allow HDR (Full Float or Half Float).");let a=1;if(!n.getCaps().textureFloatRender&&(a=2,!n.getCaps().textureHalfFloatRender))return Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.");e.sphericalPolynomial;const o=e.getInternalTexture()?._sphericalPolynomialPromise,s=r.width,l=new c.Z(n),u={},p={};n.flushFramebuffer();const d=t.imageType??y,f=(0,i.ILog2)(r.width);for(let r=0;r<=f;r++){const n=Math.pow(2,f-r);for(let i=0;i<6;i++)u[6*r+i]=await T(l,e,a,i,r,n,d,t.imageQuality)}const h=t.disableIrradianceTexture?null:e.irradianceTexture;if(h){const e=h.getSize().width;for(let r=0;r<6;r++)p[r]=await T(l,h,a,r,0,e,d,t.imageQuality)}l.dispose(),o&&await o;const m={version:g,width:s,imageType:d,irradiance:b(e),specular:{mipmaps:[],lodGenerationScale:e.lodGenerationScale}};let w=0;for(let e=0;e<=f;e++)for(let t=0;t<6;t++){const r=u[6*e+t].byteLength;m.specular.mipmaps.push({length:r,position:w}),w+=r}if(h){m.irradiance=m.irradiance||{x:[0,0,0],xx:[0,0,0],y:[0,0,0],yy:[0,0,0],z:[0,0,0],zz:[0,0,0],yz:[0,0,0],zx:[0,0,0],xy:[0,0,0]},m.irradiance.irradianceTexture={size:h.getSize().width,faces:[]};for(let e=0;e<6;e++){const t=p[e].byteLength;m.irradiance.irradianceTexture.faces.push({length:t,position:w}),w+=t}}const v=JSON.stringify(m),A=new ArrayBuffer(v.length+1),_=new Uint8Array(A);for(let e=0,t=v.length;e<t;e++)_[e]=v.charCodeAt(e);_[v.length]=0;const z=x.length+w+A.byteLength,D=new ArrayBuffer(z),R=new Uint8Array(D),P=new DataView(D);let M=0;for(let e=0;e<x.length;e++)P.setUint8(M++,x[e]);R.set(new Uint8Array(A),M),M+=A.byteLength;for(let e=0;e<=f;e++)for(let t=0;t<6;t++){const r=u[6*e+t];R.set(new Uint8Array(r),M),M+=r.byteLength}if(h)for(let e=0;e<6;e++){const t=p[e];R.set(new Uint8Array(t),M),M+=t.byteLength}return D}async function T(e,t,r,n,a,i,o,s){let l=await t.readPixels(n,a,void 0,!1);if(l&&l.byteLength===l.length){const e=new Float32Array(4*l.byteLength);for(let t=0;t<l.byteLength;t++)e[t]=l[t]/255,e[t]=Math.pow(e[t],2.2);l=e}else if(l&&t.gammaSpace){const e=l;for(let t=0;t<e.length;t++)e[t]=Math.pow(e[t],2.2)}const c=e.getEngine(),u=c.createRawTexture(l,i,i,5,!1,!0,1,null,r);await d.G.EncodeTextureToRGBD(u,e,r);const p=await c._readTexturePixels(u,i,i),y=await(0,f.DumpDataAsync)(i,i,p,o,void 0,!1,!0,s);return u.dispose(),y}function b(e){const t=e.sphericalPolynomial;return null==t?null:{x:[t.x.x,t.x.y,t.x.z],y:[t.y.x,t.y.y,t.y.z],z:[t.z.x,t.z.y,t.z.z],xx:[t.xx.x,t.xx.y,t.xx.z],yy:[t.yy.x,t.yy.y,t.yy.z],zz:[t.zz.x,t.zz.y,t.zz.z],yz:[t.yz.x,t.yz.y,t.yz.z],zx:[t.zx.x,t.zx.y,t.zx.z],xy:[t.xy.x,t.xy.y,t.xy.z]}}function v(e,t){const r=(t=m(t)).specular;let n=Math.log2(t.width);if(n=Math.round(n)+1,r.mipmaps.length!==6*n)throw new Error(`Unsupported specular mipmaps number "${r.mipmaps.length}"`);const a=new Array(n);for(let i=0;i<n;i++){a[i]=new Array(6);for(let n=0;n<6;n++){const o=r.mipmaps[6*i+n];a[i][n]=new Uint8Array(e.buffer,e.byteOffset+t.binaryDataPosition+o.position,o.length)}}return a}function A(e,t){t=m(t);const r=new Array(6),n=t.irradiance?.irradianceTexture;if(n){if(6!==n.faces.length)throw new Error(`Incorrect irradiance texture faces number "${n.faces.length}"`);for(let a=0;a<6;a++){const i=n.faces[a];r[a]=new Uint8Array(e.buffer,e.byteOffset+t.binaryDataPosition+i.position,i.length)}}return r}function _(e,t,r){const n=(r=m(r)).specular;if(!n)return Promise.resolve([]);e._lodGenerationScale=n.lodGenerationScale;const a=[],i=v(t,r);a.push(D(e,i,r.imageType));const o=r.irradiance?.irradianceTexture;if(o){const n=A(t,r);a.push(R(e,n,o.size,r.imageType))}return Promise.all(a)}function z(e,t,r,n,a,i,o,s,l,c,u){return new Promise(((p,d)=>{if(r){const r=t.createTexture(null,!0,!0,null,1,null,(e=>{d(e)}),e);n?.onEffectCreatedObservable.addOnce((s=>{s.executeWhenCompiled((()=>{n.externalTextureSamplerBinding=!0,n.onApply=n=>{n._bindTexture("textureSampler",r),n.setFloat2("scale",1,t._features.needsInvertingBitmap&&e instanceof ImageBitmap?-1:1)},t.scenes.length&&(t.scenes[0].postProcessManager.directRender([n],c,!0,i,o),t.restoreDefaultFramebuffer(),r.dispose(),URL.revokeObjectURL(a),p())}))}))}else{if(t._uploadImageToTexture(u,e,i,o),s){const r=l[o];r&&t._uploadImageToTexture(r._texture,e,i,0)}p()}}))}async function D(e,t,r=y){const n=e.getEngine();e.format=5,e.type=0,e.generateMipMaps=!0,e._cachedAnisotropicFilteringLevel=null,n.updateTextureSamplingMode(3,e),await P(e,t,!0,r),e.isReady=!0}async function R(e,t,r,n=y){const a=e.getEngine(),i=new s.h(a,5),o=new l.t(a,i);e._irradianceTexture=o,i.isCube=!0,i.format=5,i.type=0,i.generateMipMaps=!0,i._cachedAnisotropicFilteringLevel=null,i.generateMipMaps=!0,i.width=r,i.height=r,a.updateTextureSamplingMode(3,i),await P(i,[t],!1,n),a.generateMipMapsForCubemap(i),i.isReady=!0}async function P(e,t,a,o=y){if(!n.S0.IsExponentOfTwo(e.width))throw new Error("Texture size must be a power of two");const c=(0,i.ILog2)(e.width)+1,p=e.getEngine();let d=!1,f=!1,g=null,x=null,h=null;const m=p.getCaps();m.textureLOD?p._features.supportRenderAndCopyToLodForFloatTextures?m.textureHalfFloatRender&&m.textureHalfFloatLinearFiltering?(d=!0,e.type=2):m.textureFloatRender&&m.textureFloatLinearFiltering&&(d=!0,e.type=1):d=!1:(d=!1,f=a);let w=0;if(d)p.isWebGPU?(w=1,await r.e(371).then(r.bind(r,30371))):await r.e(9682).then(r.bind(r,9682)),g=new u.w("rgbdDecode","rgbdDecode",null,null,1,null,3,p,!1,void 0,e.type,void 0,null,!1,void 0,w),e._isRGBD=!1,e.invertY=!1,x=p.createRenderTargetCubeTexture(e.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:e.type,format:5});else if(e._isRGBD=!0,e.invertY=!0,f){const t=3;h={};const r=e._lodGenerationScale,n=e._lodGenerationOffset;for(let a=0;a<t;a++){const i=(c-1)*r+n,o=n+(i-n)*(1-a/(t-1)),u=Math.round(Math.min(Math.max(o,0),i)),d=new s.h(p,2);d.isCube=!0,d.invertY=!0,d.generateMipMaps=!1,p.updateTextureSamplingMode(2,d);const f=new l.t(null);switch(f._isCube=!0,f._texture=d,h[u]=f,a){case 0:e._lodTextureLow=f;break;case 1:e._lodTextureMid=f;break;case 2:e._lodTextureHigh=f}}}const T=[];for(let r=0;r<t.length;r++)for(let n=0;n<6;n++){const a=t[r][n],i=new Blob([a],{type:o}),s=URL.createObjectURL(i);let l;if(p._features.forceBitmapOverHTMLImageElement)l=p.createImageBitmap(i,{premultiplyAlpha:"none"}).then((t=>z(t,p,d,g,s,n,r,f,h,x,e)));else{const t=new Image;t.src=s,l=new Promise(((a,i)=>{t.onload=()=>{z(t,p,d,g,s,n,r,f,h,x,e).then((()=>a())).catch((e=>{i(e)}))},t.onerror=e=>{i(e)}}))}T.push(l)}if(await Promise.all(T),t.length<c){let r;const n=Math.pow(2,c-1-t.length),a=n*n*4;switch(e.type){case 0:r=new Uint8Array(a);break;case 2:r=new Uint16Array(a);break;case 1:r=new Float32Array(a)}for(let n=t.length;n<c;n++)for(let t=0;t<6;t++)p._uploadArrayBufferViewToTexture(x?.texture||e,r,t,n)}if(x){const t=e._irradianceTexture;e._irradianceTexture=null,p._releaseTexture(e),x._swapAndDie(e),e._irradianceTexture=t}g&&g.dispose(),f&&(e._lodTextureHigh&&e._lodTextureHigh._texture&&(e._lodTextureHigh._texture.isReady=!0),e._lodTextureMid&&e._lodTextureMid._texture&&(e._lodTextureMid._texture.isReady=!0),e._lodTextureLow&&e._lodTextureLow._texture&&(e._lodTextureLow._texture.isReady=!0))}function M(e,t){const r=(t=m(t)).irradiance;if(!r)return;const n=new o.Q;a.Pq.FromArrayToRef(r.x,0,n.x),a.Pq.FromArrayToRef(r.y,0,n.y),a.Pq.FromArrayToRef(r.z,0,n.z),a.Pq.FromArrayToRef(r.xx,0,n.xx),a.Pq.FromArrayToRef(r.yy,0,n.yy),a.Pq.FromArrayToRef(r.zz,0,n.zz),a.Pq.FromArrayToRef(r.yz,0,n.yz),a.Pq.FromArrayToRef(r.zx,0,n.zx),a.Pq.FromArrayToRef(r.xy,0,n.xy),e._sphericalPolynomial=n}function F(e,t,r,n,a){const i=D(e.getEngine().createRawCubeTexture(null,e.width,e.format,e.type,e.generateMipMaps,e.invertY,e.samplingMode,e._compression),t).then((()=>e));return e.onRebuildCallback=e=>({proxy:i,isReady:!0,isAsync:!0}),e._source=13,e._bufferViewArrayArray=t,e._lodGenerationScale=n,e._lodGenerationOffset=a,e._sphericalPolynomial=r,D(e,t).then((()=>(e.isReady=!0,e)))}const S={GetEnvInfo:h,CreateEnvTextureAsync:w,CreateRadianceImageDataArrayBufferViews:v,CreateIrradianceImageDataArrayBufferViews:A,UploadEnvLevelsAsync:_,UploadRadianceLevelsAsync:D,UploadIrradianceLevelsAsync:R,UploadEnvSpherical:M}},89928:(e,t,r)=>{r.r(t),r.d(t,{Dispose:()=>d,DumpData:()=>p,DumpDataAsync:()=>u,DumpFramebuffer:()=>c,DumpTools:()=>f});var n=r(84255),a=r(998),i=r(84867),o=r(6315);let s,l=null;async function c(e,t,r,n,a="image/png",i,o){const s=await r.readPixels(0,0,e,t);p(e,t,new Uint8Array(s.buffer),n,a,i,!0,void 0,o)}function u(e,t,r,n="image/png",a,i=!1,o=!1,s){return new Promise((l=>{p(e,t,r,(e=>l(e)),n,a,i,o,s)}))}function p(e,t,c,u,p="image/png",f,y=!1,g=!1,x){(async function(){return l||(l=new Promise(((e,t)=>{let a,i=null;const l={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};Promise.resolve().then(r.bind(r,86514)).then((({ThinEngine:c})=>{const u=o.q.Instances.length;try{a=new OffscreenCanvas(100,100),i=new c(a,!1,l)}catch(e){u<o.q.Instances.length&&o.q.Instances.pop()?.dispose(),a=document.createElement("canvas"),i=new c(a,!1,l)}o.q.Instances.pop(),o.q.OnEnginesDisposedObservable.add((e=>{i&&e!==i&&!i.isDisposed&&0===o.q.Instances.length&&d()})),i.getCaps().parallelShaderCompile=void 0;const p=new n.J(i);r.e(9820).then(r.bind(r,79820)).then((({passPixelShader:r})=>{if(!i)return void t("Engine is not defined");const o=new n.$({engine:i,name:r.name,fragmentShader:r.shader,samplerNames:["textureSampler"]});s={canvas:a,engine:i,renderer:p,wrapper:o},e(s)}))})).catch(t)}))),await l})().then((r=>{if(r.engine.setSize(e,t,!0),c instanceof Float32Array){const e=new Uint8Array(c.length);let t=c.length;for(;t--;){const r=c[t];e[t]=Math.round(255*(0,i.Clamp)(r))}c=e}const n=r.engine.createRawTexture(c,e,t,5,!1,!y,1);r.renderer.setViewport(),r.renderer.applyEffectWrapper(r.wrapper),r.wrapper.effect._bindTexture("textureSampler",n),r.renderer.draw(),g?a.S0.ToBlob(r.canvas,(e=>{const t=new FileReader;t.onload=e=>{const t=e.target.result;u&&u(t)},t.readAsArrayBuffer(e)}),p,x):a.S0.EncodeScreenshotCanvasData(r.canvas,u,p,f,x),n.dispose()}))}function d(){s?(s.wrapper.dispose(),s.renderer.dispose(),s.engine.dispose()):l?.then((e=>{e.wrapper.dispose(),e.renderer.dispose(),e.engine.dispose()})),l=null,s=null}const f={DumpData:p,DumpDataAsync:u,DumpFramebuffer:c,Dispose:d};a.S0.DumpData=p,a.S0.DumpDataAsync=u,a.S0.DumpFramebuffer=c}}]);