"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[5234,9928],{55234:(e,r,n)=>{n.d(r,{cU:()=>m,gW:()=>A,o5:()=>w,ow:()=>v});var t=n(998),a=n(14037),i=n(84867),o=n(77517),s=n(90854),l=n(82667),u=(n(29794),n(77891)),c=n(51137);n(97126),n(89928),n(69764);const p="image/png",d=2,f=[134,22,135,150,246,214,150,54];function m(e){const r=new DataView(e.buffer,e.byteOffset,e.byteLength);let n=0;for(let e=0;e<f.length;e++)if(r.getUint8(n++)!==f[e])return c.V.Error("Not a babylon environment map"),null;let t="",a=0;for(;a=r.getUint8(n++);)t+=String.fromCharCode(a);let i=JSON.parse(t);return i=g(i),i.binaryDataPosition=n,i.specular&&(i.specular.lodGenerationScale=i.specular.lodGenerationScale||.8),i}function g(e){if(e.version>d)throw new Error(`Unsupported babylon environment map version "${e.version}". Latest supported version is "${d}".`);return 2===e.version?e:e={...e,version:2,imageType:p}}function y(e,r){const n=(r=g(r)).specular;let t=Math.log2(r.width);if(t=Math.round(t)+1,n.mipmaps.length!==6*t)throw new Error(`Unsupported specular mipmaps number "${n.mipmaps.length}"`);const a=new Array(t);for(let i=0;i<t;i++){a[i]=new Array(6);for(let t=0;t<6;t++){const o=n.mipmaps[6*i+t];a[i][t]=new Uint8Array(e.buffer,e.byteOffset+r.binaryDataPosition+o.position,o.length)}}return a}function h(e,r){r=g(r);const n=new Array(6),t=r.irradiance?.irradianceTexture;if(t){if(6!==t.faces.length)throw new Error(`Incorrect irradiance texture faces number "${t.faces.length}"`);for(let a=0;a<6;a++){const i=t.faces[a];n[a]=new Uint8Array(e.buffer,e.byteOffset+r.binaryDataPosition+i.position,i.length)}}return n}function w(e,r,n){const t=(n=g(n)).specular;if(!t)return Promise.resolve([]);e._lodGenerationScale=t.lodGenerationScale;const i=[],o=y(r,n);i.push(T(e,o,n.imageType));const s=n.irradiance?.irradianceTexture;if(s){const t=h(r,n);let o=null;n.irradiance?.irradianceTexture?.dominantDirection&&(o=a.Pq.FromArray(n.irradiance.irradianceTexture.dominantDirection)),i.push(b(e,t,s.size,n.imageType,o))}return Promise.all(i)}async function x(e,r,n,t,a,i,o,s,l,u,c){return await new Promise((p,d)=>{if(n){const n=r.createTexture(null,!0,!0,null,1,null,e=>{d(e)},e);t?.onEffectCreatedObservable.addOnce(s=>{s.executeWhenCompiled(()=>{t.externalTextureSamplerBinding=!0,t.onApply=t=>{t._bindTexture("textureSampler",n),t.setFloat2("scale",1,r._features.needsInvertingBitmap&&e instanceof ImageBitmap?-1:1)},r.scenes.length&&(r.scenes[0].postProcessManager.directRender([t],u,!0,i,o),r.restoreDefaultFramebuffer(),n.dispose(),URL.revokeObjectURL(a),p())})})}else{if(r._uploadImageToTexture(c,e,i,o),s){const n=l[o];n&&r._uploadImageToTexture(n._texture,e,i,0)}p()}})}async function T(e,r,n=p){const t=e.getEngine();e.format=5,e.type=0,e.generateMipMaps=!0,e._cachedAnisotropicFilteringLevel=null,t.updateTextureSamplingMode(3,e),await _(e,r,!0,n),e.isReady=!0}async function b(e,r,n,t=p,a=null){const i=e.getEngine(),o=new s.h(i,5),u=new l.t(i,o);e._irradianceTexture=u,u._dominantDirection=a,o.isCube=!0,o.format=5,o.type=0,o.generateMipMaps=!0,o._cachedAnisotropicFilteringLevel=null,o.generateMipMaps=!0,o.width=n,o.height=n,i.updateTextureSamplingMode(3,o),await _(o,[r],!1,t),i.generateMipMapsForCubemap(o),o.isReady=!0}async function _(e,r,a,o=p){if(!t.S0.IsExponentOfTwo(e.width))throw new Error("Texture size must be a power of two");const c=(0,i.ILog2)(e.width)+1,d=e.getEngine();let f=!1,m=!1,g=null,y=null,h=null;const w=d.getCaps();w.textureLOD?d._features.supportRenderAndCopyToLodForFloatTextures?w.textureHalfFloatRender&&w.textureHalfFloatLinearFiltering?(f=!0,e.type=2):w.textureFloatRender&&w.textureFloatLinearFiltering&&(f=!0,e.type=1):f=!1:(f=!1,m=a);let T=0;if(f)d.isWebGPU?(T=1,await n.e(371).then(n.bind(n,30371))):await n.e(9682).then(n.bind(n,9682)),g=new u.w("rgbdDecode","rgbdDecode",null,null,1,null,3,d,!1,void 0,e.type,void 0,null,!1,void 0,T),e._isRGBD=!1,e.invertY=!1,y=d.createRenderTargetCubeTexture(e.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:e.type,format:5});else if(e._isRGBD=!0,e.invertY=!0,m){const r=3;h={};const n=e._lodGenerationScale,t=e._lodGenerationOffset;for(let a=0;a<r;a++){const i=(c-1)*n+t,o=t+(i-t)*(1-a/(r-1)),u=Math.round(Math.min(Math.max(o,0),i)),p=new s.h(d,2);p.isCube=!0,p.invertY=!0,p.generateMipMaps=!1,d.updateTextureSamplingMode(2,p);const f=new l.t(null);switch(f._isCube=!0,f._texture=p,h[u]=f,a){case 0:e._lodTextureLow=f;break;case 1:e._lodTextureMid=f;break;case 2:e._lodTextureHigh=f}}}const b=[];for(let n=0;n<r.length;n++)for(let t=0;t<6;t++){const a=r[n][t],i=new Blob([a],{type:o}),s=URL.createObjectURL(i);let l;if(d._features.forceBitmapOverHTMLImageElement)l=d.createImageBitmap(i,{premultiplyAlpha:"none"}).then(async r=>await x(r,d,f,g,s,t,n,m,h,y,e));else{const r=new Image;r.src=s,l=new Promise((a,i)=>{r.onload=()=>{x(r,d,f,g,s,t,n,m,h,y,e).then(()=>a()).catch(e=>{i(e)})},r.onerror=e=>{i(e)}})}b.push(l)}if(await Promise.all(b),r.length<c){let n;const t=Math.pow(2,c-1-r.length),a=t*t*4;switch(e.type){case 0:n=new Uint8Array(a);break;case 2:n=new Uint16Array(a);break;case 1:n=new Float32Array(a)}for(let t=r.length;t<c;t++)for(let r=0;r<6;r++)d._uploadArrayBufferViewToTexture(y?.texture||e,n,r,t)}if(y){const r=e._irradianceTexture;e._irradianceTexture=null,d._releaseTexture(e),y._swapAndDie(e),e._irradianceTexture=r}g&&g.dispose(),m&&(e._lodTextureHigh&&e._lodTextureHigh._texture&&(e._lodTextureHigh._texture.isReady=!0),e._lodTextureMid&&e._lodTextureMid._texture&&(e._lodTextureMid._texture.isReady=!0),e._lodTextureLow&&e._lodTextureLow._texture&&(e._lodTextureLow._texture.isReady=!0))}function v(e,r){const n=(r=g(r)).irradiance;if(!n)return;const t=new o.Q;a.Pq.FromArrayToRef(n.x,0,t.x),a.Pq.FromArrayToRef(n.y,0,t.y),a.Pq.FromArrayToRef(n.z,0,t.z),a.Pq.FromArrayToRef(n.xx,0,t.xx),a.Pq.FromArrayToRef(n.yy,0,t.yy),a.Pq.FromArrayToRef(n.zz,0,t.zz),a.Pq.FromArrayToRef(n.yz,0,t.yz),a.Pq.FromArrayToRef(n.zx,0,t.zx),a.Pq.FromArrayToRef(n.xy,0,t.xy),e._sphericalPolynomial=t}function A(e,r,n,t,a){const i=T(e.getEngine().createRawCubeTexture(null,e.width,e.format,e.type,e.generateMipMaps,e.invertY,e.samplingMode,e._compression),r).then(()=>e);return e.onRebuildCallback=e=>({proxy:i,isReady:!0,isAsync:!0}),e._source=13,e._bufferViewArrayArray=r,e._lodGenerationScale=t,e._lodGenerationOffset=a,e._sphericalPolynomial=n,T(e,r).then(()=>(e.isReady=!0,e))}},89928:(e,r,n)=>{n.r(r),n.d(r,{Dispose:()=>d,DumpData:()=>p,DumpDataAsync:()=>c,DumpFramebuffer:()=>u,DumpTools:()=>f});var t=n(84255),a=n(998),i=n(84867),o=n(6315);let s,l=null;async function u(e,r,n,t,a="image/png",i,o){const s=await n.readPixels(0,0,e,r);p(e,r,new Uint8Array(s.buffer),t,a,i,!0,void 0,o)}async function c(e,r,n,t="image/png",a,i=!1,o=!1,s){return await new Promise(l=>{p(e,r,n,e=>l(e),t,a,i,o,s)})}function p(e,r,u,c,p="image/png",f,m=!1,g=!1,y){(async function(){return l||(l=new Promise((e,r)=>{let a,i=null;const l={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};Promise.resolve().then(n.bind(n,77008)).then(({ThinEngine:u})=>{const c=o.q.Instances.length;try{a=new OffscreenCanvas(100,100),i=new u(a,!1,l)}catch(e){c<o.q.Instances.length&&o.q.Instances.pop()?.dispose(),a=document.createElement("canvas"),i=new u(a,!1,l)}o.q.Instances.pop(),o.q.OnEnginesDisposedObservable.add(e=>{i&&e!==i&&!i.isDisposed&&0===o.q.Instances.length&&d()}),i.getCaps().parallelShaderCompile=void 0;const p=new t.J(i);n.e(9820).then(n.bind(n,79820)).then(({passPixelShader:n})=>{if(!i)return void r("Engine is not defined");const o=new t.$({engine:i,name:n.name,fragmentShader:n.shader,samplerNames:["textureSampler"]});s={canvas:a,engine:i,renderer:p,wrapper:o},e(s)})}).catch(r)})),await l})().then(n=>{if(n.engine.setSize(e,r,!0),u instanceof Float32Array){const e=new Uint8Array(u.length);let r=u.length;for(;r--;){const n=u[r];e[r]=Math.round(255*(0,i.Clamp)(n))}u=e}const t=n.engine.createRawTexture(u,e,r,5,!1,!m,1);n.renderer.setViewport(),n.renderer.applyEffectWrapper(n.wrapper),n.wrapper.effect._bindTexture("textureSampler",t),n.renderer.draw(),g?a.S0.ToBlob(n.canvas,e=>{const r=new FileReader;r.onload=e=>{const r=e.target.result;c&&c(r)},r.readAsArrayBuffer(e)},p,y):a.S0.EncodeScreenshotCanvasData(n.canvas,c,p,f,y),t.dispose()})}function d(){s?(s.wrapper.dispose(),s.renderer.dispose(),s.engine.dispose()):l?.then(e=>{e.wrapper.dispose(),e.renderer.dispose(),e.engine.dispose()}),l=null,s=null}const f={DumpData:p,DumpDataAsync:c,DumpFramebuffer:u,Dispose:d};a.S0.DumpData=p,a.S0.DumpDataAsync=c,a.S0.DumpFramebuffer=u}}]);