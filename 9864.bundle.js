"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[9864],{13833:(e,t,s)=>{s.d(t,{q:()=>n,y:()=>x});var n,r=s(62956),a=s(79923),i=s(51137),o=s(95616),c=s(36803),h=s(76595),u=s(6315),l=s(99083),_=s(86919),f=s(2093),d=s(56526),p=s(84867);!function(e){e[e.Color=2]="Color",e[e.UV=1]="UV",e[e.Random=0]="Random",e[e.Stated=3]="Stated"}(n||(n={}));class x{get positions(){return this._positions32}get colors(){return this._colors32}get uvs(){return this._uvs32}constructor(e,t,s,n){this.particles=new Array,this.nbParticles=0,this.counter=0,this.vars={},this._promises=[],this._positions=new Array,this._indices=new Array,this._normals=new Array,this._colors=new Array,this._uvs=new Array,this._updatable=!0,this._isVisibilityBoxLocked=!1,this._alwaysVisible=!1,this._groups=new Array,this._groupCounter=0,this._computeParticleColor=!0,this._computeParticleTexture=!0,this._computeParticleRotation=!0,this._computeBoundingBox=!1,this._isReady=!1,this.name=e,this._size=t,this._scene=s||u.q.LastCreatedScene,n&&void 0!==n.updatable?this._updatable=n.updatable:this._updatable=!0}buildMeshAsync(e){return Promise.all(this._promises).then((()=>(this._isReady=!0,this._buildMesh(e))))}_buildMesh(e){0===this.nbParticles&&this.addPoints(1),this._positions32=new Float32Array(this._positions),this._uvs32=new Float32Array(this._uvs),this._colors32=new Float32Array(this._colors);const t=new c.P;t.set(this._positions32,o.R.PositionKind),this._uvs32.length>0&&t.set(this._uvs32,o.R.UVKind);let s=0;this._colors32.length>0&&(s=1,t.set(this._colors32,o.R.ColorKind));const n=new h.e(this.name,this._scene);t.applyToMesh(n,this._updatable),this.mesh=n,this._positions=null,this._uvs=null,this._colors=null,this._updatable||(this.particles.length=0);let a=e;return a||(a=new f.F("point cloud material",this._scene),a.emissiveColor=new r.v9(s,s,s),a.disableLighting=!0,a.pointsCloud=!0,a.pointSize=this._size),n.material=a,new Promise((e=>e(n)))}_addParticle(e,t,s,n){const r=new l.M(e,t,s,n,this);return this.particles.push(r),r}_randomUnitVector(e){e.position=new a.Pq(Math.random(),Math.random(),Math.random()),e.color=new r.ov(1,1,1,1)}_getColorIndicesForCoord(e,t,s,n){const a=e._groupImageData,i=s*(4*n)+4*t,o=[i,i+1,i+2,i+3],c=o[1],h=o[2],u=o[3],l=a[o[0]],_=a[c],f=a[h],d=a[u];return new r.ov(l/255,_/255,f/255,d)}_setPointsColorOrUV(e,t,s,n,i,c,h,u){u=u??0,s&&e.updateFacetData();const l=2*e.getBoundingInfo().boundingSphere.radius;let f=e.getVerticesData(o.R.PositionKind);const d=e.getIndices(),x=e.getVerticesData(o.R.UVKind+(u?u+1:"")),m=e.getVerticesData(o.R.ColorKind),v=a.Pq.Zero();e.computeWorldMatrix();const S=e.getWorldMatrix();if(!S.isIdentity()){f=f.slice(0);for(let e=0;e<f.length/3;e++)a.Pq.TransformCoordinatesFromFloatsToRef(f[3*e],f[3*e+1],f[3*e+2],S,v),f[3*e]=v.x,f[3*e+1]=v.y,f[3*e+2]=v.z}let g=0,y=0,I=0,C=0,T=0,A=0,D=0,w=0,P=0,B=0,z=0,E=0,b=0;const M=a.Pq.Zero(),H=a.Pq.Zero(),R=a.Pq.Zero(),V=a.Pq.Zero(),U=a.Pq.Zero();let F=0,L=0,k=0,N=0,O=0,G=0;const W=a.I9.Zero(),q=a.I9.Zero(),X=a.I9.Zero(),Z=a.I9.Zero(),K=a.I9.Zero();let Y=0,j=0,Q=0,J=0,$=0,ee=0,te=0,se=0,ne=0,re=0,ae=0,ie=0;const oe=a.IU.Zero(),ce=a.IU.Zero(),he=a.IU.Zero(),ue=a.IU.Zero(),le=a.IU.Zero();let _e,fe,de=0,pe=0;h=h||0;let xe=new a.IU(0,0,0,0),me=a.Pq.Zero(),ve=a.Pq.Zero(),Se=a.Pq.Zero(),ge=0,ye=a.Pq.Zero(),Ie=0,Ce=0;const Te=new _.Ray(a.Pq.Zero(),new a.Pq(1,0,0));let Ae,De=a.Pq.Zero();for(let o=0;o<d.length/3;o++){let u,_,v,S,we,Pe,Be,ze;y=d[3*o],I=d[3*o+1],C=d[3*o+2],T=f[3*y],A=f[3*y+1],D=f[3*y+2],w=f[3*I],P=f[3*I+1],B=f[3*I+2],z=f[3*C],E=f[3*C+1],b=f[3*C+2],M.set(T,A,D),H.set(w,P,B),R.set(z,E,b),H.subtractToRef(M,V),R.subtractToRef(H,U),x&&(F=x[2*y],L=x[2*y+1],k=x[2*I],N=x[2*I+1],O=x[2*C],G=x[2*C+1],W.set(F,L),q.set(k,N),X.set(O,G),q.subtractToRef(W,Z),X.subtractToRef(q,K)),m&&n&&(Y=m[4*y],j=m[4*y+1],Q=m[4*y+2],J=m[4*y+3],$=m[4*I],ee=m[4*I+1],te=m[4*I+2],se=m[4*I+3],ne=m[4*C],re=m[4*C+1],ae=m[4*C+2],ie=m[4*C+3],oe.set(Y,j,Q,J),ce.set($,ee,te,se),he.set(ne,re,ae,ie),ce.subtractToRef(oe,ue),he.subtractToRef(ce,le));const Ee=new r.v9(0,0,0),be=new r.v9(0,0,0);let Me,He;for(let f=0;f<t._groupDensity[o];f++)g=this.particles.length,this._addParticle(g,t,this._groupCounter,o+f),He=this.particles[g],de=Math.sqrt((0,p.RandomRange)(0,1)),pe=(0,p.RandomRange)(0,1),_e=M.add(V.scale(de)).add(U.scale(de*pe)),s&&(me=e.getFacetNormal(o).normalize().scale(-1),ve=V.clone().normalize(),Se=a.Pq.Cross(me,ve),ge=(0,p.RandomRange)(0,2*Math.PI),ye=ve.scale(Math.cos(ge)).add(Se.scale(Math.sin(ge))),ge=(0,p.RandomRange)(.1,Math.PI/2),De=ye.scale(Math.cos(ge)).add(me.scale(Math.sin(ge))),Te.origin=_e.add(De.scale(1e-5)),Te.direction=De,Te.length=l,Ae=Te.intersectsMesh(e),Ae.hit&&(Ce=Ae.pickedPoint.subtract(_e).length(),Ie=(0,p.RandomRange)(0,1)*Ce,_e.addInPlace(De.scale(Ie)))),He.position=_e.clone(),this._positions.push(He.position.x,He.position.y,He.position.z),void 0!==n?x&&(fe=W.add(Z.scale(de)).add(K.scale(de*pe)),n?i&&null!==t._groupImageData?(u=t._groupImgWidth,_=t._groupImgHeight,Me=this._getColorIndicesForCoord(t,Math.round(fe.x*u),Math.round(fe.y*_),u),He.color=Me,this._colors.push(Me.r,Me.g,Me.b,Me.a)):m?(xe=oe.add(ue.scale(de)).add(le.scale(de*pe)),He.color=new r.ov(xe.x,xe.y,xe.z,xe.w),this._colors.push(xe.x,xe.y,xe.z,xe.w)):(xe=oe.set(Math.random(),Math.random(),Math.random(),1),He.color=new r.ov(xe.x,xe.y,xe.z,xe.w),this._colors.push(xe.x,xe.y,xe.z,xe.w)):(He.uv=fe.clone(),this._uvs.push(He.uv.x,He.uv.y))):(c?(Ee.set(c.r,c.g,c.b),v=(0,p.RandomRange)(-h,h),S=(0,p.RandomRange)(-h,h),ze=Ee.toHSV(),we=ze.r,Pe=ze.g+v,Be=ze.b+S,Pe<0&&(Pe=0),Pe>1&&(Pe=1),Be<0&&(Be=0),Be>1&&(Be=1),r.v9.HSVtoRGBToRef(we,Pe,Be,be),xe.set(be.r,be.g,be.b,1)):xe=oe.set(Math.random(),Math.random(),Math.random(),1),He.color=new r.ov(xe.x,xe.y,xe.z,xe.w),this._colors.push(xe.x,xe.y,xe.z,xe.w))}}_colorFromTexture(e,t,s){if(null===e.material)return i.V.Warn(e.name+"has no material."),t._groupImageData=null,void this._setPointsColorOrUV(e,t,s,!0,!1);const n=e.material.getActiveTextures();if(0===n.length)return i.V.Warn(e.name+"has no usable texture."),t._groupImageData=null,void this._setPointsColorOrUV(e,t,s,!0,!1);const r=e.clone();r.setEnabled(!1),this._promises.push(new Promise((e=>{d.t.WhenAllReady(n,(()=>{let a=t._textureNb;a<0&&(a=0),a>n.length-1&&(a=n.length-1);const i=()=>{t._groupImgWidth=n[a].getSize().width,t._groupImgHeight=n[a].getSize().height,this._setPointsColorOrUV(r,t,s,!0,!0,void 0,void 0,n[a].coordinatesIndex),r.dispose(),e()};t._groupImageData=null;const o=n[a].readPixels();o?o.then((e=>{t._groupImageData=e,i()})):i()}))})))}_calculateDensity(e,t,s){let n,r,i,o,c,h,u,l,_,f,d,p;const x=a.Pq.Zero(),m=a.Pq.Zero(),v=a.Pq.Zero(),S=a.Pq.Zero(),g=a.Pq.Zero(),y=a.Pq.Zero();let I;const C=[];let T=0;const A=s.length/3;for(let e=0;e<A;e++)n=s[3*e],r=s[3*e+1],i=s[3*e+2],o=t[3*n],c=t[3*n+1],h=t[3*n+2],u=t[3*r],l=t[3*r+1],_=t[3*r+2],f=t[3*i],d=t[3*i+1],p=t[3*i+2],x.set(o,c,h),m.set(u,l,_),v.set(f,d,p),m.subtractToRef(x,S),v.subtractToRef(m,g),a.Pq.CrossToRef(S,g,y),I=.5*y.length(),T+=I,C[e]=T;const D=new Array(A);let w=e;for(let e=A-1;e>0;e--){const t=C[e];if(0===t)D[e]=0;else{const s=(t-C[e-1])/t*w,n=Math.floor(s),r=s-n,a=n+Number(Math.random()<r);D[e]=a,w-=a}}return D[0]=w,D}addPoints(e,t=this._randomUnitVector){const s=new l.x(this._groupCounter,t);let n,r=this.nbParticles;for(let t=0;t<e;t++)n=this._addParticle(r,s,this._groupCounter,t),s&&s._positionFunction&&s._positionFunction(n,r,t),this._positions.push(n.position.x,n.position.y,n.position.z),n.color&&this._colors.push(n.color.r,n.color.g,n.color.b,n.color.a),n.uv&&this._uvs.push(n.uv.x,n.uv.y),r++;return this.nbParticles+=e,this._groupCounter++,this._groupCounter}addSurfacePoints(e,t,s,n,a){let i=s||0;(isNaN(i)||i<0||i>3)&&(i=0);const c=e.getVerticesData(o.R.PositionKind),h=e.getIndices();this._groups.push(this._groupCounter);const u=new l.x(this._groupCounter,null);switch(u._groupDensity=this._calculateDensity(t,c,h),2===i?u._textureNb=n||0:n=n||new r.ov(1,1,1,1),i){case 2:this._colorFromTexture(e,u,!1);break;case 1:this._setPointsColorOrUV(e,u,!1,!1,!1);break;case 0:this._setPointsColorOrUV(e,u,!1);break;case 3:this._setPointsColorOrUV(e,u,!1,void 0,void 0,n,a)}return this.nbParticles+=t,this._groupCounter++,this._groupCounter-1}addVolumePoints(e,t,s,n,a){let i=s||0;(isNaN(i)||i<0||i>3)&&(i=0);const c=e.getVerticesData(o.R.PositionKind),h=e.getIndices();this._groups.push(this._groupCounter);const u=new l.x(this._groupCounter,null);switch(u._groupDensity=this._calculateDensity(t,c,h),2===i?u._textureNb=n||0:n=n||new r.ov(1,1,1,1),i){case 2:this._colorFromTexture(e,u,!0);break;case 1:this._setPointsColorOrUV(e,u,!0,!1,!1);break;case 0:this._setPointsColorOrUV(e,u,!0);break;case 3:this._setPointsColorOrUV(e,u,!0,void 0,void 0,n,a)}return this.nbParticles+=t,this._groupCounter++,this._groupCounter-1}setParticles(e=0,t=this.nbParticles-1,s=!0){if(!this._updatable||!this._isReady)return this;this.beforeUpdateParticles(e,t,s);const n=a.AA.Matrix[0],r=this.mesh,i=this._colors32,c=this._positions32,h=this._uvs32,u=a.AA.Vector3,l=u[5].copyFromFloats(1,0,0),_=u[6].copyFromFloats(0,1,0),f=u[7].copyFromFloats(0,0,1),d=u[8].setAll(Number.MAX_VALUE),p=u[9].setAll(-Number.MAX_VALUE);a.uq.IdentityToRef(n);let x=0;if(this.mesh?.isFacetDataEnabled&&(this._computeBoundingBox=!0),t=t>=this.nbParticles?this.nbParticles-1:t,this._computeBoundingBox&&(0!=e||t!=this.nbParticles-1)){const e=this.mesh?.getBoundingInfo();e&&(d.copyFrom(e.minimum),p.copyFrom(e.maximum))}x=0;let m=0,v=0,S=0;for(let s=e;s<=t;s++){const e=this.particles[s];x=e.idx,m=3*x,v=4*x,S=2*x,this.updateParticle(e);const t=e._rotationMatrix,r=e.position,a=e._globalPosition;this._computeParticleRotation&&e.getRotationMatrix(n);if(null!==e.parentId){const s=this.particles[e.parentId],i=s._rotationMatrix,o=s._globalPosition,c=r.x*i[1]+r.y*i[4]+r.z*i[7],h=r.x*i[0]+r.y*i[3]+r.z*i[6],u=r.x*i[2]+r.y*i[5]+r.z*i[8];if(a.x=o.x+h,a.y=o.y+c,a.z=o.z+u,this._computeParticleRotation){const e=n.m;t[0]=e[0]*i[0]+e[1]*i[3]+e[2]*i[6],t[1]=e[0]*i[1]+e[1]*i[4]+e[2]*i[7],t[2]=e[0]*i[2]+e[1]*i[5]+e[2]*i[8],t[3]=e[4]*i[0]+e[5]*i[3]+e[6]*i[6],t[4]=e[4]*i[1]+e[5]*i[4]+e[6]*i[7],t[5]=e[4]*i[2]+e[5]*i[5]+e[6]*i[8],t[6]=e[8]*i[0]+e[9]*i[3]+e[10]*i[6],t[7]=e[8]*i[1]+e[9]*i[4]+e[10]*i[7],t[8]=e[8]*i[2]+e[9]*i[5]+e[10]*i[8]}}else if(a.x=0,a.y=0,a.z=0,this._computeParticleRotation){const e=n.m;t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[4],t[4]=e[5],t[5]=e[6],t[6]=e[8],t[7]=e[9],t[8]=e[10]}const i=u[11];e.translateFromPivot?i.setAll(0):i.copyFrom(e.pivot);const o=u[0];o.copyFrom(e.position);const h=o.x-e.pivot.x,g=o.y-e.pivot.y,y=o.z-e.pivot.z;let I=h*t[0]+g*t[3]+y*t[6],C=h*t[1]+g*t[4]+y*t[7],T=h*t[2]+g*t[5]+y*t[8];I+=i.x,C+=i.y,T+=i.z;const A=c[m]=a.x+l.x*I+_.x*C+f.x*T,D=c[m+1]=a.y+l.y*I+_.y*C+f.y*T,w=c[m+2]=a.z+l.z*I+_.z*C+f.z*T;if(this._computeBoundingBox&&(d.minimizeInPlaceFromFloats(A,D,w),p.maximizeInPlaceFromFloats(A,D,w)),this._computeParticleColor&&e.color){const t=e.color,s=this._colors32;s[v]=t.r,s[v+1]=t.g,s[v+2]=t.b,s[v+3]=t.a}if(this._computeParticleTexture&&e.uv){const t=e.uv,s=this._uvs32;s[S]=t.x,s[S+1]=t.y}}return r&&(s&&(this._computeParticleColor&&r.updateVerticesData(o.R.ColorKind,i,!1,!1),this._computeParticleTexture&&r.updateVerticesData(o.R.UVKind,h,!1,!1),r.updateVerticesData(o.R.PositionKind,c,!1,!1)),this._computeBoundingBox&&(r.hasBoundingInfo?r.getBoundingInfo().reConstruct(d,p,r._worldMatrix):r.buildBoundingInfo(d,p,r._worldMatrix))),this.afterUpdateParticles(e,t,s),this}dispose(){this.mesh?.dispose(),this.vars=null,this._positions=null,this._indices=null,this._normals=null,this._uvs=null,this._colors=null,this._indices32=null,this._positions32=null,this._uvs32=null,this._colors32=null}refreshVisibleSize(){return this._isVisibilityBoxLocked||this.mesh?.refreshBoundingInfo(),this}setVisibilityBox(e){if(!this.mesh)return;const t=e/2;this.mesh.buildBoundingInfo(new a.Pq(-t,-t,-t),new a.Pq(t,t,t))}get isAlwaysVisible(){return this._alwaysVisible}set isAlwaysVisible(e){this.mesh&&(this._alwaysVisible=e,this.mesh.alwaysSelectAsActiveMesh=e)}set computeParticleRotation(e){this._computeParticleRotation=e}set computeParticleColor(e){this._computeParticleColor=e}set computeParticleTexture(e){this._computeParticleTexture=e}get computeParticleColor(){return this._computeParticleColor}get computeParticleTexture(){return this._computeParticleTexture}set computeBoundingBox(e){this._computeBoundingBox=e}get computeBoundingBox(){return this._computeBoundingBox}initParticles(){}recycleParticle(e){return e}updateParticle(e){return e}beforeUpdateParticles(e,t,s){}afterUpdateParticles(e,t,s){}}},18335:(e,t,s)=>{s.r(t),s.d(t,{gaussianSplattingPixelShader:()=>c});var n=s(69610);s(6194),s(34581),s(7806),s(29741),s(2360);const r="gaussianSplattingFragmentDeclaration",a="vec4 gaussianColor(vec4 inColor)\n{float A=-dot(vPosition,vPosition);if (A<-4.0) discard;float B=exp(A)*inColor.a;\n#include<logDepthFragment>\nvec3 color=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4(color,B);}\n";n.l.IncludesShadersStore[r]||(n.l.IncludesShadersStore[r]=a);s(7412);const i="gaussianSplattingPixelShader",o="#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vec4 vColor;varying vec2 vPosition;\n#include<gaussianSplattingFragmentDeclaration>\nvoid main () { \n#include<clipPlaneFragment>\ngl_FragColor=gaussianColor(vColor);}\n";n.l.ShadersStore[i]||(n.l.ShadersStore[i]=o);const c={name:i,shader:o}},20927:(e,t,s)=>{s.d(t,{b:()=>_});var n=s(26877),r=s(95616),a=s(79526),i=s(21644),o=s(56552),c=s(30492),h=s(30388),u=(s(18335),s(97215),s(23758),s(55597),s(80467));class l extends a.M{constructor(){super(),this.FOG=!1,this.THIN_INSTANCES=!0,this.LOGARITHMICDEPTH=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.SH_DEGREE=0,this.COMPENSATION=!1,this.rebuild()}}class _ extends i.E{constructor(e,t){super(e,t),this.backFaceCulling=!1}get hasRenderTargetTextures(){return!1}needAlphaTesting(){return!1}needAlphaBlending(){return!0}isReadyForSubMesh(e,t){const n=!0,a=t._drawWrapper;if(a.effect&&this.isFrozen&&a._wasPreviouslyReady&&a._wasPreviouslyUsingInstances===n)return!0;t.materialDefines||(t.materialDefines=new l);const i=this.getScene(),o=t.materialDefines;if(this._isReadyForSubMesh(t))return!0;const h=i.getEngine();if((0,u.fm)(e,i,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,!1,o),(0,u.OR)(i,h,this,o,n,null,!0),(0,u.qB)(e,o,!1,!1),(h.version>1||h.isWebGPU)&&(o.SH_DEGREE=e.shDegree),o.COMPENSATION=_.Compensation,o.isDirty){o.markAsProcessed(),i.resetCachedMaterial();const e=[r.R.PositionKind,"splatIndex"];(0,u.ER)(e,o);const n=["world","view","projection","vFogInfos","vFogColor","logarithmicDepthConstant","invViewport","dataTextureSize","focal","vEyePosition","kernelSize"],a=["covariancesATexture","covariancesBTexture","centersTexture","colorsTexture","shTexture0","shTexture1","shTexture2"],l=["Scene","Mesh"];(0,u.Bb)({uniformsNames:n,uniformBuffersNames:l,samplers:a,defines:o}),(0,c.TV)(n);const _=o.toString(),f=i.getEngine().createEffect("gaussianSplatting",{attributes:e,uniformsNames:n,uniformBuffersNames:l,samplers:a,defines:_,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{},shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{1===this._shaderLanguage?await Promise.all([Promise.resolve().then(s.bind(s,23758)),Promise.resolve().then(s.bind(s,55597))]):await Promise.all([Promise.resolve().then(s.bind(s,18335)),Promise.resolve().then(s.bind(s,97215))])}},h);t.setEffect(f,o,this._materialContext)}return!(!t.effect||!t.effect.isReady())&&(o._renderId=i.getRenderId(),a._wasPreviouslyReady=!0,a._wasPreviouslyUsingInstances=n,!0)}static BindEffect(e,t,s){const n=s.getEngine(),r=s.activeCamera,a=n.getRenderWidth(),i=n.getRenderHeight(),o=r?.rigParent?.rigCameras.length||1;t.setFloat2("invViewport",1/(a/o),1/i);let c=1e3;if(r){const e=r.getProjectionMatrix().m[5];c=r.fovMode==h.i.FOVMODE_VERTICAL_FIXED?i*e/2:a*e/2}t.setFloat2("focal",c,c),t.setFloat("kernelSize",_.KernelSize),s.bindEyePosition(t);const u=e;if(u.covariancesATexture){const e=u.covariancesATexture.getSize();if(t.setFloat2("dataTextureSize",e.width,e.height),t.setTexture("covariancesATexture",u.covariancesATexture),t.setTexture("covariancesBTexture",u.covariancesBTexture),t.setTexture("centersTexture",u.centersTexture),t.setTexture("colorsTexture",u.colorsTexture),u.shTextures)for(let e=0;e<u.shTextures?.length;e++)t.setTexture(`shTexture${e}`,u.shTextures[e])}}bindForSubMesh(e,t,s){const n=this.getScene(),r=s.materialDefines;if(!r)return;const a=s.effect;if(!a)return;this._activeEffect=a,t.getMeshUniformBuffer().bindToEffect(a,"Mesh"),t.transferToEffect(e);this._mustRebind(n,a,s,t.visibility)?(this.bindView(a),this.bindViewProjection(a),_.BindEffect(t,this._activeEffect,n),(0,c.gS)(a,this,n)):n.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0),(0,u.Yy)(n,t,a),this.useLogarithmicDepth&&(0,u.DL)(r,a,n),this._afterBind(t,this._activeEffect,s)}clone(e){return n.p.Clone((()=>new _(e,this.getScene())),this)}serialize(){const e=super.serialize();return e.customType="BABYLON.GaussianSplattingMaterial",e}getClassName(){return"GaussianSplattingMaterial"}static Parse(e,t,s){return n.p.Parse((()=>new _(e.name,t)),e,t,s)}}_.KernelSize=.3,_.Compensation=!1,(0,o.Y5)("BABYLON.GaussianSplattingMaterial",_)},23758:(e,t,s)=>{s.r(t),s.d(t,{gaussianSplattingPixelShaderWGSL:()=>c});var n=s(69610);s(39759),s(93226),s(66407),s(38780),s(93243);const r="gaussianSplattingFragmentDeclaration",a="fn gaussianColor(inColor: vec4f,inPosition: vec2f)->vec4f\n{var A : f32=-dot(inPosition,inPosition);if (A>-4.0)\n{var B: f32=exp(A)*inColor.a;\n#include<logDepthFragment>\nvar color: vec3f=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4f(color,B);} else {return vec4f(0.0);}}\n";n.l.IncludesShadersStoreWGSL[r]||(n.l.IncludesShadersStoreWGSL[r]=a);s(97715);const i="gaussianSplattingPixelShader",o="#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplattingFragmentDeclaration>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\nfragmentOutputs.color=gaussianColor(input.vColor,input.vPosition);}\n";n.l.ShadersStoreWGSL[i]||(n.l.ShadersStoreWGSL[i]=o);const c={name:i,shader:o}},39775:(e,t,s)=>{s.d(t,{Q:()=>i});var n=s(69610);const r="gaussianSplattingVertexDeclaration",a="attribute vec2 position;uniform mat4 view;uniform mat4 projection;uniform mat4 world;uniform vec4 vEyePosition;";n.l.IncludesShadersStore[r]||(n.l.IncludesShadersStore[r]=a);const i={name:r,shader:a}},55597:(e,t,s)=>{s.r(t),s.d(t,{gaussianSplattingVertexShaderWGSL:()=>c});var n=s(69610);s(98327),s(6874),s(79702),s(77029),s(75757),s(93226);const r="gaussianSplatting",a="fn getDataUV(index: f32,dataTextureSize: vec2f)->vec2<f32> {let y: f32=floor(index/dataTextureSize.x);let x: f32=index-y*dataTextureSize.x;return vec2f((x+0.5),(y+0.5));}\nstruct Splat {center: vec4f,\ncolor: vec4f,\ncovA: vec4f,\ncovB: vec4f,\n#if SH_DEGREE>0\nsh0: vec4<u32>,\n#endif\n#if SH_DEGREE>1\nsh1: vec4<u32>,\n#endif\n#if SH_DEGREE>2\nsh2: vec4<u32>,\n#endif\n};fn readSplat(splatIndex: f32,dataTextureSize: vec2f)->Splat {var splat: Splat;let splatUV=getDataUV(splatIndex,dataTextureSize);let splatUVi32=vec2<i32>(i32(splatUV.x),i32(splatUV.y));splat.center=textureLoad(centersTexture,splatUVi32,0);splat.color=textureLoad(colorsTexture,splatUVi32,0);splat.covA=textureLoad(covariancesATexture,splatUVi32,0)*splat.center.w;splat.covB=textureLoad(covariancesBTexture,splatUVi32,0)*splat.center.w;\n#if SH_DEGREE>0\nsplat.sh0=textureLoad(shTexture0,splatUVi32,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=textureLoad(shTexture1,splatUVi32,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=textureLoad(shTexture2,splatUVi32,0);\n#endif\nreturn splat;}\nfn computeColorFromSHDegree(dir: vec3f,sh: array<vec3<f32>,16>)->vec3f\n{let SH_C0: f32=0.28209479;let SH_C1: f32=0.48860251;var SH_C2: array<f32,5>=array<f32,5>(\n1.092548430,\n-1.09254843,\n0.315391565,\n-1.09254843,\n0.546274215\n);var SH_C3: array<f32,7>=array<f32,7>(\n-0.59004358,\n2.890611442,\n-0.45704579,\n0.373176332,\n-0.45704579,\n1.445305721,\n-0.59004358\n);var result: vec3f=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nlet x: f32=dir.x;let y: f32=dir.y;let z: f32=dir.z;result+=-SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nlet xx: f32=x*x;let yy: f32=y*y;let zz: f32=z*z;let xy: f32=x*y;let yz: f32=y*z;let xz: f32=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0f*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0f*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0f*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0f*zz-3.0f*xx-3.0f*yy)*sh[12] +\nSH_C3[4]*x*(4.0f*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0f*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nfn decompose(value: u32)->vec4f\n{let components : vec4f=vec4f(\nf32((value ) & 255u),\nf32((value>>u32( 8)) & 255u),\nf32((value>>u32(16)) & 255u),\nf32((value>>u32(24)) & 255u));return components*vec4f(2./255.)-vec4f(1.);}\nfn computeSH(splat: Splat,color: vec3f,dir: vec3f)->vec3f\n{var sh: array<vec3<f32>,16>;sh[0]=color;\n#if SH_DEGREE>0\nlet sh00: vec4f=decompose(splat.sh0.x);let sh01: vec4f=decompose(splat.sh0.y);let sh02: vec4f=decompose(splat.sh0.z);sh[1]=vec3f(sh00.x,sh00.y,sh00.z);sh[2]=vec3f(sh00.w,sh01.x,sh01.y);sh[3]=vec3f(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nlet sh03: vec4f=decompose(splat.sh0.w);let sh04: vec4f=decompose(splat.sh1.x);let sh05: vec4f=decompose(splat.sh1.y);sh[4]=vec3f(sh02.y,sh02.z,sh02.w);sh[5]=vec3f(sh03.x,sh03.y,sh03.z);sh[6]=vec3f(sh03.w,sh04.x,sh04.y);sh[7]=vec3f(sh04.z,sh04.w,sh05.x);sh[8]=vec3f(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nlet sh06: vec4f=decompose(splat.sh1.z);let sh07: vec4f=decompose(splat.sh1.w);let sh08: vec4f=decompose(splat.sh2.x);let sh09: vec4f=decompose(splat.sh2.y);let sh10: vec4f=decompose(splat.sh2.z);let sh11: vec4f=decompose(splat.sh2.w);sh[9]=vec3f(sh06.x,sh06.y,sh06.z);sh[10]=vec3f(sh06.w,sh07.x,sh07.y);sh[11]=vec3f(sh07.z,sh07.w,sh08.x);sh[12]=vec3f(sh08.y,sh08.z,sh08.w);sh[13]=vec3f(sh09.x,sh09.y,sh09.z);sh[14]=vec3f(sh09.w,sh10.x,sh10.y);sh[15]=vec3f(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\nfn gaussianSplatting(\nmeshPos: vec2<f32>,\nworldPos: vec3<f32>,\nscale: vec2<f32>,\ncovA: vec3<f32>,\ncovB: vec3<f32>,\nworldMatrix: mat4x4<f32>,\nviewMatrix: mat4x4<f32>,\nprojectionMatrix: mat4x4<f32>,\nfocal: vec2f,\ninvViewport: vec2f,\nkernelSize: f32\n)->vec4f {let modelView=viewMatrix*worldMatrix;let camspace=viewMatrix*vec4f(worldPos,1.0);let pos2d=projectionMatrix*camspace;let bounds=1.2*pos2d.w;if (pos2d.z<0. || pos2d.x<-bounds || pos2d.x>bounds || pos2d.y<-bounds || pos2d.y>bounds) {return vec4f(0.0,0.0,2.0,1.0);}\nlet Vrk=mat3x3<f32>(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);let J=mat3x3<f32>(\nfocal.x/camspace.z,0.0,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.0,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.0,0.0,0.0\n);let invy=mat3x3<f32>(\n1.0,0.0,0.0,\n0.0,-1.0,0.0,\n0.0,0.0,1.0\n);let T=invy*transpose(mat3x3<f32>(\nmodelView[0].xyz,\nmodelView[1].xyz,\nmodelView[2].xyz))*J;var cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nlet c00: f32=cov2d[0][0];let c11: f32=cov2d[1][1];let c01: f32=cov2d[0][1];let detOrig: f32=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nlet c2d: vec3f=vec3f(cov2d[0][0],c01,cov2d[1][1]);let detBlur: f32=c2d.x*c2d.z-c2d.y*c2d.y;let compensation: f32=sqrt(max(0.,detOrig/detBlur));vertexOutputs.vColor.w*=compensation;\n#endif\nlet mid=(cov2d[0][0]+cov2d[1][1])/2.0;let radius=length(vec2<f32>((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));let lambda1=mid+radius;let lambda2=mid-radius;if (lambda2<0.0) {return vec4f(0.0,0.0,2.0,1.0);}\nlet diagonalVector=normalize(vec2<f32>(cov2d[0][1],lambda1-cov2d[0][0]));let majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;let minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2<f32>(diagonalVector.y,-diagonalVector.x);let vCenter=vec2<f32>(pos2d.x,pos2d.y);return vec4f(\nvCenter+((meshPos.x*majorAxis+meshPos.y*minorAxis)*invViewport*pos2d.w)*scale,\npos2d.z,\npos2d.w\n);}\n";n.l.IncludesShadersStoreWGSL[r]||(n.l.IncludesShadersStoreWGSL[r]=a);s(85197),s(59013),s(81482);const i="gaussianSplattingVertexShader",o="#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n#include<helperFunctions>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\nattribute splatIndex: f32;attribute position: vec2f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;\n#if SH_DEGREE>0\nvar shTexture0: texture_2d<u32>;\n#endif\n#if SH_DEGREE>1\nvar shTexture1: texture_2d<u32>;\n#endif\n#if SH_DEGREE>2\nvar shTexture2: texture_2d<u32>;\n#endif\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var splat: Splat=readSplat(input.splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position;\n#if SH_DEGREE>0\nlet worldRot: mat3x3f= mat3x3f(mesh.world[0].xyz,mesh.world[1].xyz,mesh.world[2].xyz);let normWorldRot: mat3x3f=inverseMat3(worldRot);var dir: vec3f=normalize(normWorldRot*(worldPos.xyz-scene.vEyePosition.xyz));dir*=vec3f(1.,1.,-1.); \nvertexOutputs.vColor=vec4f(computeSH(splat,splat.color.xyz,dir),1.0);\n#else\nvertexOutputs.vColor=splat.color;\n#endif\nvertexOutputs.position=gaussianSplatting(input.position,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n";n.l.ShadersStoreWGSL[i]||(n.l.ShadersStoreWGSL[i]=o);const c={name:i,shader:o}},62128:(e,t,s)=>{s.d(t,{X:()=>a});var n=s(84867);const r=n.HighestCommonFactor,a={...n,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:r}},90203:(e,t,s)=>{var n=s(76595),r=s(95616),a=s(79923),i=s(51137),o=s(20863);n.e.prototype.thinInstanceAdd=function(e,t=!0){if(!this.getScene().getEngine().getCaps().instancedArrays)return i.V.Error("Thin Instances are not supported on this device as Instanced Array extension not supported"),-1;this._thinInstanceUpdateBufferSize("matrix",Array.isArray(e)?e.length:1);const s=this._thinInstanceDataStorage.instancesCount;if(Array.isArray(e))for(let s=0;s<e.length;++s)this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,e[s],s===e.length-1&&t);else this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,e,t);return s},n.e.prototype.thinInstanceAddSelf=function(e=!0){return this.thinInstanceAdd(a.uq.IdentityReadOnly,e)},n.e.prototype.thinInstanceRegisterAttribute=function(e,t){e===r.R.ColorKind&&(e=r.R.ColorInstanceKind),this.removeVerticesData(e),this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.strides[e]=t,this._userThinInstanceBuffersStorage.sizes[e]=t*Math.max(32,this._thinInstanceDataStorage.instancesCount),this._userThinInstanceBuffersStorage.data[e]=new Float32Array(this._userThinInstanceBuffersStorage.sizes[e]),this._userThinInstanceBuffersStorage.vertexBuffers[e]=new r.R(this.getEngine(),this._userThinInstanceBuffersStorage.data[e],e,!0,!1,t,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e])},n.e.prototype.thinInstanceSetMatrixAt=function(e,t,s=!0){if(!this._thinInstanceDataStorage.matrixData||e>=this._thinInstanceDataStorage.instancesCount)return!1;const n=this._thinInstanceDataStorage.matrixData;return t.copyToArray(n,16*e),this._thinInstanceDataStorage.worldMatrices&&(this._thinInstanceDataStorage.worldMatrices[e]=t),s&&(this.thinInstanceBufferUpdated("matrix"),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)),!0},n.e.prototype.thinInstanceSetAttributeAt=function(e,t,s,n=!0){return e===r.R.ColorKind&&(e=r.R.ColorInstanceKind),!(!this._userThinInstanceBuffersStorage||!this._userThinInstanceBuffersStorage.data[e]||t>=this._thinInstanceDataStorage.instancesCount)&&(this._thinInstanceUpdateBufferSize(e,0),this._userThinInstanceBuffersStorage.data[e].set(s,t*this._userThinInstanceBuffersStorage.strides[e]),n&&this.thinInstanceBufferUpdated(e),!0)},Object.defineProperty(n.e.prototype,"thinInstanceCount",{get:function(){return this._thinInstanceDataStorage.instancesCount},set:function(e){const t=this._thinInstanceDataStorage.matrixData??this.source?._thinInstanceDataStorage.matrixData;e<=(t?t.length/16:0)&&(this._thinInstanceDataStorage.instancesCount=e)},enumerable:!0,configurable:!0}),n.e.prototype._thinInstanceCreateMatrixBuffer=function(e,t,s=!0){const n=new r.h(this.getEngine(),t,!s,16,!1,!0);for(let t=0;t<4;t++)this.setVerticesBuffer(n.createVertexBuffer(e+t,4*t,4));return n},n.e.prototype.thinInstanceSetBuffer=function(e,t,s=0,n=!0){s=s||16,"matrix"===e?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=null,this._thinInstanceDataStorage.matrixBufferSize=t?t.length:32*s,this._thinInstanceDataStorage.matrixData=t,this._thinInstanceDataStorage.worldMatrices=null,null!==t?(this._thinInstanceDataStorage.instancesCount=t.length/s,this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",t,n),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)):(this._thinInstanceDataStorage.instancesCount=0,this.doNotSyncBoundingInfo||this.refreshBoundingInfo())):"previousMatrix"===e?(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=null,this._thinInstanceDataStorage.previousMatrixData=t,null!==t&&(this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",t,n))):(e===r.R.ColorKind&&(e=r.R.ColorInstanceKind),null===t?this._userThinInstanceBuffersStorage?.data[e]&&(this.removeVerticesData(e),delete this._userThinInstanceBuffersStorage.data[e],delete this._userThinInstanceBuffersStorage.strides[e],delete this._userThinInstanceBuffersStorage.sizes[e],delete this._userThinInstanceBuffersStorage.vertexBuffers[e]):(this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.data[e]=t,this._userThinInstanceBuffersStorage.strides[e]=s,this._userThinInstanceBuffersStorage.sizes[e]=t.length,this._userThinInstanceBuffersStorage.vertexBuffers[e]=new r.R(this.getEngine(),t,e,!n,!1,s,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e])))},n.e.prototype.thinInstanceBufferUpdated=function(e){"matrix"===e?(this.thinInstanceAllowAutomaticStaticBufferRecreation&&this._thinInstanceDataStorage.matrixBuffer&&!this._thinInstanceDataStorage.matrixBuffer.isUpdatable()&&this._thinInstanceRecreateBuffer(e),this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData,0,this._thinInstanceDataStorage.instancesCount)):"previousMatrix"===e?(this.thinInstanceAllowAutomaticStaticBufferRecreation&&this._thinInstanceDataStorage.previousMatrixBuffer&&!this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()&&this._thinInstanceRecreateBuffer(e),this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData,0,this._thinInstanceDataStorage.instancesCount)):(e===r.R.ColorKind&&(e=r.R.ColorInstanceKind),this._userThinInstanceBuffersStorage?.vertexBuffers[e]&&(this.thinInstanceAllowAutomaticStaticBufferRecreation&&!this._userThinInstanceBuffersStorage.vertexBuffers[e].isUpdatable()&&this._thinInstanceRecreateBuffer(e),this._userThinInstanceBuffersStorage.vertexBuffers[e].updateDirectly(this._userThinInstanceBuffersStorage.data[e],0)))},n.e.prototype.thinInstancePartialBufferUpdate=function(e,t,s){"matrix"===e?this._thinInstanceDataStorage.matrixBuffer&&this._thinInstanceDataStorage.matrixBuffer.updateDirectly(t,s):(e===r.R.ColorKind&&(e=r.R.ColorInstanceKind),this._userThinInstanceBuffersStorage?.vertexBuffers[e]&&this._userThinInstanceBuffersStorage.vertexBuffers[e].updateDirectly(t,s))},n.e.prototype.thinInstanceGetWorldMatrices=function(){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return[];const e=this._thinInstanceDataStorage.matrixData;if(!this._thinInstanceDataStorage.worldMatrices){this._thinInstanceDataStorage.worldMatrices=[];for(let t=0;t<this._thinInstanceDataStorage.instancesCount;++t)this._thinInstanceDataStorage.worldMatrices[t]=a.uq.FromArray(e,16*t)}return this._thinInstanceDataStorage.worldMatrices},n.e.prototype.thinInstanceRefreshBoundingInfo=function(e=!1,t=!1,s=!1){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return;const n=this._thinInstanceDataStorage.boundingVectors;if(e||!this.rawBoundingInfo){n.length=0,this.refreshBoundingInfo(t,s);const e=this.getBoundingInfo();this.rawBoundingInfo=new o.j(e.minimum,e.maximum)}const r=this.getBoundingInfo(),i=this._thinInstanceDataStorage.matrixData;if(0===n.length)for(let e=0;e<r.boundingBox.vectors.length;++e)n.push(r.boundingBox.vectors[e].clone());a.AA.Vector3[0].setAll(Number.POSITIVE_INFINITY),a.AA.Vector3[1].setAll(Number.NEGATIVE_INFINITY);for(let e=0;e<this._thinInstanceDataStorage.instancesCount;++e){a.uq.FromArrayToRef(i,16*e,a.AA.Matrix[0]);for(let e=0;e<n.length;++e)a.Pq.TransformCoordinatesToRef(n[e],a.AA.Matrix[0],a.AA.Vector3[2]),a.AA.Vector3[0].minimizeInPlace(a.AA.Vector3[2]),a.AA.Vector3[1].maximizeInPlace(a.AA.Vector3[2])}r.reConstruct(a.AA.Vector3[0],a.AA.Vector3[1]),this._updateBoundingInfo()},n.e.prototype._thinInstanceRecreateBuffer=function(e,t=!0){"matrix"===e?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",this._thinInstanceDataStorage.matrixData,t)):"previousMatrix"===e?this._scene.needsPreviousWorldMatrices&&(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",this._thinInstanceDataStorage.previousMatrixData??this._thinInstanceDataStorage.matrixData,t)):(e===r.R.ColorKind&&(e=r.R.ColorInstanceKind),this._userThinInstanceBuffersStorage.vertexBuffers[e]?.dispose(),this._userThinInstanceBuffersStorage.vertexBuffers[e]=new r.R(this.getEngine(),this._userThinInstanceBuffersStorage.data[e],e,!t,!1,this._userThinInstanceBuffersStorage.strides[e],!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e]))},n.e.prototype._thinInstanceUpdateBufferSize=function(e,t=1){e===r.R.ColorKind&&(e=r.R.ColorInstanceKind);const s="matrix"===e;if(!(s||this._userThinInstanceBuffersStorage&&this._userThinInstanceBuffersStorage.strides[e]))return;const n=s?16:this._userThinInstanceBuffersStorage.strides[e],a=s?this._thinInstanceDataStorage.matrixBufferSize:this._userThinInstanceBuffersStorage.sizes[e];let i=s?this._thinInstanceDataStorage.matrixData:this._userThinInstanceBuffersStorage.data[e];const o=(this._thinInstanceDataStorage.instancesCount+t)*n;let c=a;for(;c<o;)c*=2;if(!i||a!=c){if(i){const e=new Float32Array(c);e.set(i,0),i=e}else i=new Float32Array(c);s?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",i,!1),this._thinInstanceDataStorage.matrixData=i,this._thinInstanceDataStorage.matrixBufferSize=c,this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",i,!1))):(this._userThinInstanceBuffersStorage.vertexBuffers[e]?.dispose(),this._userThinInstanceBuffersStorage.data[e]=i,this._userThinInstanceBuffersStorage.sizes[e]=c,this._userThinInstanceBuffersStorage.vertexBuffers[e]=new r.R(this.getEngine(),i,e,!0,!1,n,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e]))}},n.e.prototype._thinInstanceInitializeUserStorage=function(){this._userThinInstanceBuffersStorage||(this._userThinInstanceBuffersStorage={data:{},sizes:{},vertexBuffers:{},strides:{}})},n.e.prototype._disposeThinInstanceSpecificData=function(){this._thinInstanceDataStorage?.matrixBuffer&&(this._thinInstanceDataStorage.matrixBuffer.dispose(),this._thinInstanceDataStorage.matrixBuffer=null)}},97215:(e,t,s)=>{s.r(t),s.d(t,{gaussianSplattingVertexShader:()=>u});var n=s(69610);s(39775),s(28764),s(96467);const r="gaussianSplattingUboDeclaration",a="#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute vec2 position;";n.l.IncludesShadersStore[r]||(n.l.IncludesShadersStore[r]=a);s(71636),s(86560),s(34581),s(73325);const i="gaussianSplatting",o="#if !defined(WEBGL2) && !defined(WEBGPU) && !defined(NATIVE)\nmat3 transpose(mat3 matrix) {return mat3(matrix[0][0],matrix[1][0],matrix[2][0],\nmatrix[0][1],matrix[1][1],matrix[2][1],\nmatrix[0][2],matrix[1][2],matrix[2][2]);}\n#endif\nvec2 getDataUV(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return vec2((x+0.5)/textureSize.x,(y+0.5)/textureSize.y);}\n#if SH_DEGREE>0\nivec2 getDataUVint(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return ivec2(uint(x+0.5),uint(y+0.5));}\n#endif\nstruct Splat {vec4 center;vec4 color;vec4 covA;vec4 covB;\n#if SH_DEGREE>0\nuvec4 sh0; \n#endif\n#if SH_DEGREE>1\nuvec4 sh1;\n#endif\n#if SH_DEGREE>2\nuvec4 sh2;\n#endif\n};Splat readSplat(float splatIndex)\n{Splat splat;vec2 splatUV=getDataUV(splatIndex,dataTextureSize);splat.center=texture2D(centersTexture,splatUV);splat.color=texture2D(colorsTexture,splatUV);splat.covA=texture2D(covariancesATexture,splatUV)*splat.center.w;splat.covB=texture2D(covariancesBTexture,splatUV)*splat.center.w;\n#if SH_DEGREE>0\nivec2 splatUVint=getDataUVint(splatIndex,dataTextureSize);splat.sh0=texelFetch(shTexture0,splatUVint,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=texelFetch(shTexture1,splatUVint,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=texelFetch(shTexture2,splatUVint,0);\n#endif\nreturn splat;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nvec3 computeColorFromSHDegree(vec3 dir,const vec3 sh[16])\n{const float SH_C0=0.28209479;const float SH_C1=0.48860251;float SH_C2[5];SH_C2[0]=1.092548430;SH_C2[1]=-1.09254843;SH_C2[2]=0.315391565;SH_C2[3]=-1.09254843;SH_C2[4]=0.546274215;float SH_C3[7];SH_C3[0]=-0.59004358;SH_C3[1]=2.890611442;SH_C3[2]=-0.45704579;SH_C3[3]=0.373176332;SH_C3[4]=-0.45704579;SH_C3[5]=1.445305721;SH_C3[6]=-0.59004358;vec3 result=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nfloat x=dir.x;float y=dir.y;float z=dir.z;result+=- SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nfloat xx=x*x,yy=y*y,zz=z*z;float xy=x*y,yz=y*z,xz=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0*zz-3.0*xx-3.0*yy)*sh[12] +\nSH_C3[4]*x*(4.0*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nvec4 decompose(uint value)\n{vec4 components=vec4(\nfloat((value ) & 255u),\nfloat((value>>uint( 8)) & 255u),\nfloat((value>>uint(16)) & 255u),\nfloat((value>>uint(24)) & 255u));return components*vec4(2./255.)-vec4(1.);}\nvec3 computeSH(Splat splat,vec3 color,vec3 dir)\n{vec3 sh[16];sh[0]=color;\n#if SH_DEGREE>0\nvec4 sh00=decompose(splat.sh0.x);vec4 sh01=decompose(splat.sh0.y);vec4 sh02=decompose(splat.sh0.z);sh[1]=vec3(sh00.x,sh00.y,sh00.z);sh[2]=vec3(sh00.w,sh01.x,sh01.y);sh[3]=vec3(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nvec4 sh03=decompose(splat.sh0.w);vec4 sh04=decompose(splat.sh1.x);vec4 sh05=decompose(splat.sh1.y);sh[4]=vec3(sh02.y,sh02.z,sh02.w);sh[5]=vec3(sh03.x,sh03.y,sh03.z);sh[6]=vec3(sh03.w,sh04.x,sh04.y);sh[7]=vec3(sh04.z,sh04.w,sh05.x);sh[8]=vec3(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nvec4 sh06=decompose(splat.sh1.z);vec4 sh07=decompose(splat.sh1.w);vec4 sh08=decompose(splat.sh2.x);vec4 sh09=decompose(splat.sh2.y);vec4 sh10=decompose(splat.sh2.z);vec4 sh11=decompose(splat.sh2.w);sh[9]=vec3(sh06.x,sh06.y,sh06.z);sh[10]=vec3(sh06.w,sh07.x,sh07.y);sh[11]=vec3(sh07.z,sh07.w,sh08.x);sh[12]=vec3(sh08.y,sh08.z,sh08.w);sh[13]=vec3(sh09.x,sh09.y,sh09.z);sh[14]=vec3(sh09.w,sh10.x,sh10.y);sh[15]=vec3(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\n#else\nvec3 computeSH(Splat splat,vec3 color,vec3 dir)\n{return color;}\n#endif\nvec4 gaussianSplatting(vec2 meshPos,vec3 worldPos,vec2 scale,vec3 covA,vec3 covB,mat4 worldMatrix,mat4 viewMatrix,mat4 projectionMatrix)\n{mat4 modelView=viewMatrix*worldMatrix;vec4 camspace=viewMatrix*vec4(worldPos,1.);vec4 pos2d=projectionMatrix*camspace;float bounds=1.2*pos2d.w;if (pos2d.z<-pos2d.w || pos2d.x<-bounds || pos2d.x>bounds\n|| pos2d.y<-bounds || pos2d.y>bounds) {return vec4(0.0,0.0,2.0,1.0);}\nmat3 Vrk=mat3(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);mat3 J=mat3(\nfocal.x/camspace.z,0.,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.,0.,0.\n);mat3 invy=mat3(1,0,0,0,-1,0,0,0,1);mat3 T=invy*transpose(mat3(modelView))*J;mat3 cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nfloat c00=cov2d[0][0];float c11=cov2d[1][1];float c01=cov2d[0][1];float detOrig=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nvec3 c2d=vec3(cov2d[0][0],c01,cov2d[1][1]);float detBlur=c2d.x*c2d.z-c2d.y*c2d.y;float compensation=sqrt(max(0.,detOrig/detBlur));vColor.w*=compensation;\n#endif\nfloat mid=(cov2d[0][0]+cov2d[1][1])/2.0;float radius=length(vec2((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));float epsilon=0.0001;float lambda1=mid+radius+epsilon,lambda2=mid-radius+epsilon;if (lambda2<0.0)\n{return vec4(0.0,0.0,2.0,1.0);}\nvec2 diagonalVector=normalize(vec2(cov2d[0][1],lambda1-cov2d[0][0]));vec2 majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;vec2 minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2(diagonalVector.y,-diagonalVector.x);vec2 vCenter=vec2(pos2d);return vec4(\nvCenter \n+ ((meshPos.x*majorAxis\n+ meshPos.y*minorAxis)*invViewport*pos2d.w)*scale,pos2d.zw);}";n.l.IncludesShadersStore[i]||(n.l.IncludesShadersStore[i]=o);s(47314),s(16470),s(2215);const c="gaussianSplattingVertexShader",h="#include<__decl__gaussianSplattingVertex>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\nattribute float splatIndex;uniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;\n#if SH_DEGREE>0\nuniform highp usampler2D shTexture0;\n#endif\n#if SH_DEGREE>1\nuniform highp usampler2D shTexture1;\n#endif\n#if SH_DEGREE>2\nuniform highp usampler2D shTexture2;\n#endif\nvarying vec4 vColor;varying vec2 vPosition;\n#include<gaussianSplatting>\nvoid main () {Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);vec4 worldPos=world*vec4(splat.center.xyz,1.0);vColor=splat.color;vPosition=position;\n#if SH_DEGREE>0\nmat3 worldRot=mat3(world);mat3 normWorldRot=inverseMat3(worldRot);vec3 dir=normalize(normWorldRot*(worldPos.xyz-vEyePosition.xyz));dir*=vec3(1.,1.,-1.); \nvColor.xyz=computeSH(splat,splat.color.xyz,dir);\n#endif\ngl_Position=gaussianSplatting(position,worldPos.xyz,vec2(1.,1.),covA,covB,world,view,projection);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n";n.l.ShadersStore[c]||(n.l.ShadersStore[c]=h);const u={name:c,shader:h}},98058:(e,t,s)=>{s.d(t,{t:()=>y});var n=s(65907),r=s(76595),a=s(36803),i=s(79923),o=s(51137),c=s(20927),h=s(96041),u=s(998),l=(s(90203),s(42683)),_=s(62128),f=s(80163),d=s(6315);const p=(e,t)=>{const s=(1<<t)-1;return(e&s)/s},x=(e,t)=>{t.x=p(e>>>21,11),t.y=p(e>>>11,10),t.z=p(e,11)},m=(e,t)=>{t[0]=255*p(e>>>24,8),t[1]=255*p(e>>>16,8),t[2]=255*p(e>>>8,8),t[3]=255*p(e,8)},v=(e,t)=>{const s=1/(.5*Math.sqrt(2)),n=(p(e>>>20,10)-.5)*s,r=(p(e>>>10,10)-.5)*s,a=(p(e,10)-.5)*s,i=Math.sqrt(1-(n*n+r*r+a*a));switch(e>>>30){case 0:t.set(i,n,r,a);break;case 1:t.set(n,i,r,a);break;case 2:t.set(n,r,i,a);break;case 3:t.set(n,r,a,i)}};var S,g;!function(e){e[e.FLOAT=0]="FLOAT",e[e.INT=1]="INT",e[e.UINT=2]="UINT",e[e.DOUBLE=3]="DOUBLE",e[e.UCHAR=4]="UCHAR",e[e.UNDEFINED=5]="UNDEFINED"}(S||(S={})),function(e){e[e.MIN_X=0]="MIN_X",e[e.MIN_Y=1]="MIN_Y",e[e.MIN_Z=2]="MIN_Z",e[e.MAX_X=3]="MAX_X",e[e.MAX_Y=4]="MAX_Y",e[e.MAX_Z=5]="MAX_Z",e[e.MIN_SCALE_X=6]="MIN_SCALE_X",e[e.MIN_SCALE_Y=7]="MIN_SCALE_Y",e[e.MIN_SCALE_Z=8]="MIN_SCALE_Z",e[e.MAX_SCALE_X=9]="MAX_SCALE_X",e[e.MAX_SCALE_Y=10]="MAX_SCALE_Y",e[e.MAX_SCALE_Z=11]="MAX_SCALE_Z",e[e.PACKED_POSITION=12]="PACKED_POSITION",e[e.PACKED_ROTATION=13]="PACKED_ROTATION",e[e.PACKED_SCALE=14]="PACKED_SCALE",e[e.PACKED_COLOR=15]="PACKED_COLOR",e[e.X=16]="X",e[e.Y=17]="Y",e[e.Z=18]="Z",e[e.SCALE_0=19]="SCALE_0",e[e.SCALE_1=20]="SCALE_1",e[e.SCALE_2=21]="SCALE_2",e[e.DIFFUSE_RED=22]="DIFFUSE_RED",e[e.DIFFUSE_GREEN=23]="DIFFUSE_GREEN",e[e.DIFFUSE_BLUE=24]="DIFFUSE_BLUE",e[e.OPACITY=25]="OPACITY",e[e.F_DC_0=26]="F_DC_0",e[e.F_DC_1=27]="F_DC_1",e[e.F_DC_2=28]="F_DC_2",e[e.F_DC_3=29]="F_DC_3",e[e.ROT_0=30]="ROT_0",e[e.ROT_1=31]="ROT_1",e[e.ROT_2=32]="ROT_2",e[e.ROT_3=33]="ROT_3",e[e.MIN_COLOR_R=34]="MIN_COLOR_R",e[e.MIN_COLOR_G=35]="MIN_COLOR_G",e[e.MIN_COLOR_B=36]="MIN_COLOR_B",e[e.MAX_COLOR_R=37]="MAX_COLOR_R",e[e.MAX_COLOR_G=38]="MAX_COLOR_G",e[e.MAX_COLOR_B=39]="MAX_COLOR_B",e[e.SH_0=40]="SH_0",e[e.SH_1=41]="SH_1",e[e.SH_2=42]="SH_2",e[e.SH_3=43]="SH_3",e[e.SH_4=44]="SH_4",e[e.SH_5=45]="SH_5",e[e.SH_6=46]="SH_6",e[e.SH_7=47]="SH_7",e[e.SH_8=48]="SH_8",e[e.SH_9=49]="SH_9",e[e.SH_10=50]="SH_10",e[e.SH_11=51]="SH_11",e[e.SH_12=52]="SH_12",e[e.SH_13=53]="SH_13",e[e.SH_14=54]="SH_14",e[e.SH_15=55]="SH_15",e[e.SH_16=56]="SH_16",e[e.SH_17=57]="SH_17",e[e.SH_18=58]="SH_18",e[e.SH_19=59]="SH_19",e[e.SH_20=60]="SH_20",e[e.SH_21=61]="SH_21",e[e.SH_22=62]="SH_22",e[e.SH_23=63]="SH_23",e[e.SH_24=64]="SH_24",e[e.SH_25=65]="SH_25",e[e.SH_26=66]="SH_26",e[e.SH_27=67]="SH_27",e[e.SH_28=68]="SH_28",e[e.SH_29=69]="SH_29",e[e.SH_30=70]="SH_30",e[e.SH_31=71]="SH_31",e[e.SH_32=72]="SH_32",e[e.SH_33=73]="SH_33",e[e.SH_34=74]="SH_34",e[e.SH_35=75]="SH_35",e[e.SH_36=76]="SH_36",e[e.SH_37=77]="SH_37",e[e.SH_38=78]="SH_38",e[e.SH_39=79]="SH_39",e[e.SH_40=80]="SH_40",e[e.SH_41=81]="SH_41",e[e.SH_42=82]="SH_42",e[e.SH_43=83]="SH_43",e[e.SH_44=84]="SH_44",e[e.UNDEFINED=85]="UNDEFINED"}(g||(g={}));class y extends r.e{get shDegree(){return this._shDegree}get splatsData(){return this._splatsData}get covariancesATexture(){return this._covariancesATexture}get covariancesBTexture(){return this._covariancesBTexture}get centersTexture(){return this._centersTexture}get colorsTexture(){return this._colorsTexture}get shTextures(){return this._shTextures}set material(e){this._material=e,this._material.backFaceCulling=!0,this._material.cullBackFaces=!1,e.resetDrawCache()}get material(){return this._material}constructor(e,t=null,s=null,r=!1){super(e,s),this._vertexCount=0,this._worker=null,this._frameIdLastUpdate=-1,this._modelViewMatrix=i.uq.Identity(),this._canPostToWorker=!0,this._readyToDisplay=!1,this._covariancesATexture=null,this._covariancesBTexture=null,this._centersTexture=null,this._colorsTexture=null,this._splatPositions=null,this._splatIndex=null,this._shTextures=null,this._splatsData=null,this._sh=null,this._keepInRam=!1,this._delayedTextureUpdate=null,this._oldDirection=new i.Pq,this._useRGBACovariants=!1,this._material=null,this._tmpCovariances=[0,0,0,0,0,0],this._sortIsDirty=!1,this._shDegree=0;const o=new a.P;o.positions=[-3,-2,0,3,-2,0,0,4,0],o.indices=[0,1,2],o.applyToMesh(this),this.subMeshes=[],new n.K(0,0,3,0,3,this),this.setEnabled(!1),this._useRGBACovariants=!this.getEngine().isWebGPU&&1===this.getEngine().version,this._keepInRam=r,t&&this.loadFileAsync(t),this._material=new c.b(this.name+"_material",this._scene)}getClassName(){return"GaussianSplattingMesh"}getTotalVertices(){return this._vertexCount}isReady(e=!1){return!!super.isReady(e,!0)&&(!!this._readyToDisplay||(this._postToWorker(!0),!1))}_postToWorker(e=!1){const t=this.getScene().getFrameId();if((e||t!==this._frameIdLastUpdate)&&this._worker&&this._scene.activeCamera&&this._canPostToWorker){const s=this._scene.activeCamera.getViewMatrix();this.getWorldMatrix().multiplyToRef(s,this._modelViewMatrix),s.invertToRef(i.AA.Matrix[0]),this.getWorldMatrix().multiplyToRef(i.AA.Matrix[0],i.AA.Matrix[1]),i.Pq.TransformNormalToRef(i.Pq.Forward(this._scene.useRightHandedSystem),i.AA.Matrix[1],i.AA.Vector3[2]),i.AA.Vector3[2].normalize();const n=i.Pq.Dot(i.AA.Vector3[2],this._oldDirection);(e||Math.abs(n-1)>=.01)&&(this._oldDirection.copyFrom(i.AA.Vector3[2]),this._frameIdLastUpdate=t,this._canPostToWorker=!1,this._worker.postMessage({view:this._modelViewMatrix.m,depthMix:this._depthMix,useRightHandedSystem:this._scene.useRightHandedSystem},[this._depthMix.buffer]))}}render(e,t,s){return this._postToWorker(),super.render(e,t,s)}static _TypeNameToEnum(e){switch(e){case"float":return 0;case"int":return 1;case"uint":return 2;case"double":return 3;case"uchar":return 4}return 5}static _ValueNameToEnum(e){switch(e){case"min_x":return 0;case"min_y":return 1;case"min_z":return 2;case"max_x":return 3;case"max_y":return 4;case"max_z":return 5;case"min_scale_x":return 6;case"min_scale_y":return 7;case"min_scale_z":return 8;case"max_scale_x":return 9;case"max_scale_y":return 10;case"max_scale_z":return 11;case"packed_position":return 12;case"packed_rotation":return 13;case"packed_scale":return 14;case"packed_color":return 15;case"x":return 16;case"y":return 17;case"z":return 18;case"scale_0":return 19;case"scale_1":return 20;case"scale_2":return 21;case"diffuse_red":case"red":return 22;case"diffuse_green":case"green":return 23;case"diffuse_blue":case"blue":return 24;case"f_dc_0":return 26;case"f_dc_1":return 27;case"f_dc_2":return 28;case"f_dc_3":return 29;case"opacity":return 25;case"rot_0":return 30;case"rot_1":return 31;case"rot_2":return 32;case"rot_3":return 33;case"min_r":return 34;case"min_g":return 35;case"min_b":return 36;case"max_r":return 37;case"max_g":return 38;case"max_b":return 39;case"f_rest_0":return 40;case"f_rest_1":return 41;case"f_rest_2":return 42;case"f_rest_3":return 43;case"f_rest_4":return 44;case"f_rest_5":return 45;case"f_rest_6":return 46;case"f_rest_7":return 47;case"f_rest_8":return 48;case"f_rest_9":return 49;case"f_rest_10":return 50;case"f_rest_11":return 51;case"f_rest_12":return 52;case"f_rest_13":return 53;case"f_rest_14":return 54;case"f_rest_15":return 55;case"f_rest_16":return 56;case"f_rest_17":return 57;case"f_rest_18":return 58;case"f_rest_19":return 59;case"f_rest_20":return 60;case"f_rest_21":return 61;case"f_rest_22":return 62;case"f_rest_23":return 63;case"f_rest_24":return 64;case"f_rest_25":return 65;case"f_rest_26":return 66;case"f_rest_27":return 67;case"f_rest_28":return 68;case"f_rest_29":return 69;case"f_rest_30":return 70;case"f_rest_31":return 71;case"f_rest_32":return 72;case"f_rest_33":return 73;case"f_rest_34":return 74;case"f_rest_35":return 75;case"f_rest_36":return 76;case"f_rest_37":return 77;case"f_rest_38":return 78;case"f_rest_39":return 79;case"f_rest_40":return 80;case"f_rest_41":return 81;case"f_rest_42":return 82;case"f_rest_43":return 83;case"f_rest_44":return 84}return 85}static ParseHeader(e){const t=new Uint8Array(e),s=(new TextDecoder).decode(t.slice(0,10240)),n="end_header\n",r=s.indexOf(n);if(r<0||!s)return null;const a=parseInt(/element vertex (\d+)\n/.exec(s)[1]),i=/element chunk (\d+)\n/.exec(s);let c=0;i&&(c=parseInt(i[1]));let h=0,u=0;const l={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let _;!function(e){e[e.Vertex=0]="Vertex",e[e.Chunk=1]="Chunk"}(_||(_={}));let f=1;const d=[],p=[],x=s.slice(0,r).split("\n");let m=0;for(const e of x)if(e.startsWith("property ")){const[,t,s]=e.split(" "),n=y._ValueNameToEnum(s);n>=84?m=3:n>=64?m=2:n>=48&&(m=1);const r=y._TypeNameToEnum(t);1==f?(p.push({value:n,type:r,offset:u}),u+=l[t]):0==f&&(d.push({value:n,type:r,offset:h}),h+=l[t]),l[t]||o.V.Warn(`Unsupported property type: ${t}.`)}else if(e.startsWith("element ")){const[,t]=e.split(" ");"chunk"==t?f=1:"vertex"==t&&(f=0)}const v=new DataView(e,r+11),S=new ArrayBuffer(y._RowOutputLength*a);let g=null,I=0;if(m){I=3*((m+1)*(m+1)-1),g=new ArrayBuffer(I*a)}return{vertexCount:a,chunkCount:c,rowVertexLength:h,rowChunkLength:u,vertexProperties:d,chunkProperties:p,dataView:v,buffer:S,shDegree:m,shCoefficientCount:I,shBuffer:g}}static _GetCompressedChunks(e,t){if(!e.chunkCount)return null;const s=e.dataView,n=new Array(e.chunkCount);for(let r=0;r<e.chunkCount;r++){const a={min:new i.Pq,max:new i.Pq,minScale:new i.Pq,maxScale:new i.Pq,minColor:new i.Pq(0,0,0),maxColor:new i.Pq(1,1,1)};n[r]=a;for(let n=0;n<e.chunkProperties.length;n++){const r=e.chunkProperties[n];let i;if(0===r.type)switch(i=s.getFloat32(r.offset+t.value,!0),r.value){case 0:a.min.x=i;break;case 1:a.min.y=i;break;case 2:a.min.z=i;break;case 3:a.max.x=i;break;case 4:a.max.y=i;break;case 5:a.max.z=i;break;case 6:a.minScale.x=i;break;case 7:a.minScale.y=i;break;case 8:a.minScale.z=i;break;case 9:a.maxScale.x=i;break;case 10:a.maxScale.y=i;break;case 11:a.maxScale.z=i;break;case 34:a.minColor.x=i;break;case 35:a.minColor.y=i;break;case 36:a.minColor.z=i;break;case 37:a.maxColor.x=i;break;case 38:a.maxColor.y=i;break;case 39:a.maxColor.z=i}}t.value+=e.rowChunkLength}return n}static _GetSplat(e,t,s,n){const r=i.AA.Quaternion[0],a=i.AA.Vector3[0],o=y._RowOutputLength,c=e.buffer,h=e.dataView,u=new Float32Array(c,t*o,3),l=new Float32Array(c,t*o+12,3),f=new Uint8ClampedArray(c,t*o+24,4),d=new Uint8ClampedArray(c,t*o+28,4);let p=null;e.shBuffer&&(p=new Uint8ClampedArray(e.shBuffer,t*e.shCoefficientCount,e.shCoefficientCount));const S=t>>8;let g=255,I=0,C=0,T=0;const A=[];for(let t=0;t<e.vertexProperties.length;t++){const i=e.vertexProperties[t];let o;switch(i.type){case 0:o=h.getFloat32(n.value+i.offset,!0);break;case 1:o=h.getInt32(n.value+i.offset,!0);break;case 2:o=h.getUint32(n.value+i.offset,!0);break;case 3:o=h.getFloat64(n.value+i.offset,!0);break;case 4:o=h.getUint8(n.value+i.offset);break;default:continue}switch(i.value){case 12:{const e=s[S];x(o,a),u[0]=_.X.Lerp(e.min.x,e.max.x,a.x),u[1]=-_.X.Lerp(e.min.y,e.max.y,a.y),u[2]=_.X.Lerp(e.min.z,e.max.z,a.z)}break;case 13:v(o,r),g=r.w,I=r.z,C=r.y,T=r.x;break;case 14:{const e=s[S];x(o,a),l[0]=Math.exp(_.X.Lerp(e.minScale.x,e.maxScale.x,a.x)),l[1]=Math.exp(_.X.Lerp(e.minScale.y,e.maxScale.y,a.y)),l[2]=Math.exp(_.X.Lerp(e.minScale.z,e.maxScale.z,a.z))}break;case 15:{const e=s[S];m(o,f),f[0]=255*_.X.Lerp(e.minColor.x,e.maxColor.x,f[0]/255),f[1]=255*_.X.Lerp(e.minColor.y,e.maxColor.y,f[1]/255),f[2]=255*_.X.Lerp(e.minColor.z,e.maxColor.z,f[2]/255)}break;case 16:u[0]=o;break;case 17:u[1]=-o;break;case 18:u[2]=-o;break;case 19:l[0]=Math.exp(o);break;case 20:l[1]=Math.exp(o);break;case 21:l[2]=Math.exp(o);break;case 22:f[0]=o;break;case 23:f[1]=o;break;case 24:f[2]=o;break;case 26:f[0]=255*(.5+y._SH_C0*o);break;case 27:f[1]=255*(.5+y._SH_C0*o);break;case 28:f[2]=255*(.5+y._SH_C0*o);break;case 29:f[3]=255*(.5+y._SH_C0*o);break;case 25:f[3]=1/(1+Math.exp(-o))*255;break;case 30:g=o;break;case 31:I=o;break;case 32:C=o;break;case 33:T=o}if(p&&i.value>=40&&i.value<=84){const e=_.X.Clamp(127.5*o+127.5,0,255);A[i.value-40]=e}}if(p){const t=1==e.shDegree?3:2==e.shDegree?8:15;for(let e=0;e<t;e++)p[3*e+0]=A[e],p[3*e+1]=A[e+t],p[3*e+2]=A[e+2*t]}r.set(I,C,T,g),r.normalize(),d[0]=128*r.w+128,d[1]=128*r.x+128,d[2]=128*r.y+128,d[3]=128*r.z+128,n.value+=e.rowVertexLength}static*ConvertPLYWithSHToSplat(e,t=!1){const s=y.ParseHeader(e);if(!s)return{buffer:e};const n={value:0},r=y._GetCompressedChunks(s,n);for(let e=0;e<s.vertexCount;e++)y._GetSplat(s,e,r,n),e%y._PlyConversionBatchSize==0&&t&&(yield);let a=null;if(s.shDegree&&s.shBuffer){const e=Math.ceil(s.shCoefficientCount/16);let t=0;const n=new Uint8Array(s.shBuffer);a=[];const r=s.vertexCount,i=d.q.LastCreatedEngine;if(i){const o=i.getCaps().maxTextureSize,c=Math.ceil(r/o);for(let t=0;t<e;t++){const e=new Uint8Array(c*o*4*4);a.push(e)}for(let e=0;e<r;e++)for(let r=0;r<s.shCoefficientCount;r++){const s=n[t++];a[Math.floor(r/16)][r%16+16*e]=s}}}return{buffer:s.buffer,sh:a}}static*ConvertPLYToSplat(e,t=!1){const s=y.ParseHeader(e);if(!s)return e;const n={value:0},r=y._GetCompressedChunks(s,n);for(let e=0;e<s.vertexCount;e++)y._GetSplat(s,e,r,n),e%y._PlyConversionBatchSize==0&&t&&(yield);return s.buffer}static async ConvertPLYToSplatAsync(e){return(0,f.kj)(y.ConvertPLYToSplat(e,!0),(0,f.VP)())}static async ConvertPLYWithSHToSplatAsync(e){return(0,f.kj)(y.ConvertPLYWithSHToSplat(e,!0),(0,f.VP)())}loadDataAsync(e){return this.updateDataAsync(e)}loadFileAsync(e){return u.S0.LoadFileAsync(e,!0).then((async e=>{y.ConvertPLYWithSHToSplatAsync(e).then((e=>{this.updateDataAsync(e.buffer,e.sh)}))}))}dispose(e){this._covariancesATexture?.dispose(),this._covariancesBTexture?.dispose(),this._centersTexture?.dispose(),this._colorsTexture?.dispose(),this._shTextures&&this._shTextures.forEach((e=>{e.dispose()})),this._covariancesATexture=null,this._covariancesBTexture=null,this._centersTexture=null,this._colorsTexture=null,this._shTextures=null,this._worker?.terminate(),this._worker=null,super.dispose(e,!0)}_copyTextures(e){this._covariancesATexture=e.covariancesATexture?.clone(),this._covariancesBTexture=e.covariancesBTexture?.clone(),this._centersTexture=e.centersTexture?.clone(),this._colorsTexture=e.colorsTexture?.clone(),e._shTextures&&(this._shTextures=[],this._shTextures.forEach((e=>{this._shTextures?.push(e.clone())})))}clone(e=""){const t=new y(e,void 0,this.getScene());t._copySource(this),t.makeGeometryUnique(),t._vertexCount=this._vertexCount,t._copyTextures(this),t._modelViewMatrix=i.uq.Identity(),t._splatPositions=this._splatPositions,t._readyToDisplay=!1,t._instanciateWorker();const s=this.getBoundingInfo();return t.getBoundingInfo().reConstruct(s.minimum,s.maximum,this.getWorldMatrix()),t.forcedInstanceCount=t._vertexCount,t.setEnabled(!0),t}_makeSplat(e,t,s,n,r,a,o,c){const h=i.AA.Matrix[0],u=i.AA.Matrix[1],_=i.AA.Quaternion[0],f=this._useRGBACovariants?4:2,d=t[8*e+0],p=-t[8*e+1],x=t[8*e+2];this._splatPositions[4*e+0]=d,this._splatPositions[4*e+1]=p,this._splatPositions[4*e+2]=x,o.minimizeInPlaceFromFloats(d,p,x),c.maximizeInPlaceFromFloats(d,p,x),_.set((s[32*e+28+1]-127.5)/127.5,(s[32*e+28+2]-127.5)/127.5,(s[32*e+28+3]-127.5)/127.5,-(s[32*e+28+0]-127.5)/127.5),_.toRotationMatrix(h),i.uq.ScalingToRef(2*t[8*e+3+0],2*t[8*e+3+1],2*t[8*e+3+2],u);const m=h.multiplyToRef(u,i.AA.Matrix[0]).m,v=this._tmpCovariances;v[0]=m[0]*m[0]+m[1]*m[1]+m[2]*m[2],v[1]=m[0]*m[4]+m[1]*m[5]+m[2]*m[6],v[2]=m[0]*m[8]+m[1]*m[9]+m[2]*m[10],v[3]=m[4]*m[4]+m[5]*m[5]+m[6]*m[6],v[4]=m[4]*m[8]+m[5]*m[9]+m[6]*m[10],v[5]=m[8]*m[8]+m[9]*m[9]+m[10]*m[10];let S=-1e4;for(let e=0;e<6;e++)S=Math.max(S,Math.abs(v[e]));this._splatPositions[4*e+3]=S;const g=S;n[4*e+0]=(0,l.LZ)(v[0]/g),n[4*e+1]=(0,l.LZ)(v[1]/g),n[4*e+2]=(0,l.LZ)(v[2]/g),n[4*e+3]=(0,l.LZ)(v[3]/g),r[e*f+0]=(0,l.LZ)(v[4]/g),r[e*f+1]=(0,l.LZ)(v[5]/g),a[4*e+0]=s[32*e+24+0],a[4*e+1]=s[32*e+24+1],a[4*e+2]=s[32*e+24+2],a[4*e+3]=s[32*e+24+3]}_updateTextures(e,t,s,n){const r=this._getTextureSize(this._vertexCount),a=(e,t,s,n)=>new h.I(e,t,s,n,this._scene,!1,!1,2,1),i=(e,t,s,n)=>new h.I(e,t,s,n,this._scene,!1,!1,2,0),o=(e,t,s,n)=>new h.I(e,t,s,n,this._scene,!1,!1,1,7),c=(e,t,s,n)=>new h.I(e,t,s,n,this._scene,!1,!1,2,2);if(this._covariancesATexture){this._delayedTextureUpdate={covA:e,covB:t,colors:s,centers:this._splatPositions,sh:n};const r=Float32Array.from(this._splatPositions),a=this._vertexCount;this._worker.postMessage({positions:r,vertexCount:a},[r.buffer]),this._postToWorker(!0)}else this._covariancesATexture=c(e,r.x,r.y,5),this._covariancesBTexture=c(t,r.x,r.y,this._useRGBACovariants?5:7),this._centersTexture=a(this._splatPositions,r.x,r.y,5),this._colorsTexture=i(s,r.x,r.y,5),n&&(this._shTextures=[],n.forEach((e=>{const t=new Uint32Array(e.buffer),s=o(t,r.x,r.y,11);s.wrapU=0,s.wrapV=0,this._shTextures.push(s)}))),this._instanciateWorker()}*_updateData(e,t,s){this._covariancesATexture||(this._readyToDisplay=!1);const n=new Uint8Array(e),r=new Float32Array(n.buffer);this._keepInRam&&(this._splatsData=e,s&&(this._sh=s));const a=n.length/y._RowOutputLength;a!=this._vertexCount&&this._updateSplatIndexBuffer(a),this._vertexCount=a,this._shDegree=s?s.length:0;const o=this._getTextureSize(a),c=o.x*o.y,h=y.ProgressiveUpdateAmount??o.y,u=o.x*h;this._splatPositions=new Float32Array(4*c);const l=new Uint16Array(4*c),_=new Uint16Array((this._useRGBACovariants?4:2)*c),f=new Uint8Array(4*c),d=new i.Pq(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),p=new i.Pq(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);if(y.ProgressiveUpdateAmount){this._updateTextures(l,_,f,s),this.setEnabled(!0);const e=Math.ceil(o.y/h);for(let s=0;s<e;s++){const e=s*h,a=e*o.x;for(let e=0;e<u;e++)this._makeSplat(a+e,r,n,l,_,f,d,p);this._updateSubTextures(this._splatPositions,l,_,f,e,Math.min(h,o.y-e)),this.getBoundingInfo().reConstruct(d,p,this.getWorldMatrix()),t&&(yield)}const a=Float32Array.from(this._splatPositions),i=this._vertexCount;this._worker.postMessage({positions:a,vertexCount:i},[a.buffer]),this._sortIsDirty=!0}else{for(let e=0;e<a;e++)this._makeSplat(e,r,n,l,_,f,d,p),t&&e%y._SplatBatchSize==0&&(yield);this._updateTextures(l,_,f,s),this.getBoundingInfo().reConstruct(d,p,this.getWorldMatrix()),this.setEnabled(!0)}this._postToWorker(!0)}async updateDataAsync(e,t){return(0,f.kj)(this._updateData(e,!0,t),(0,f.VP)())}updateData(e,t){(0,f.V1)(this._updateData(e,!1,t))}refreshBoundingInfo(){return this.thinInstanceRefreshBoundingInfo(!1),this}_updateSplatIndexBuffer(e){(!this._splatIndex||e>this._splatIndex.length)&&(this._splatIndex=new Float32Array(e),this.thinInstanceSetBuffer("splatIndex",this._splatIndex,1,!1)),this.forcedInstanceCount=e}_updateSubTextures(e,t,s,n,r,a,i){const o=(e,t,s,n,r)=>{this.getEngine().updateTextureData(e.getInternalTexture(),t,0,n,s,r,0,0,!1)},c=this._getTextureSize(this._vertexCount),h=this._useRGBACovariants?4:2,u=r*c.x,l=a*c.x,_=new Uint16Array(t.buffer,4*u*Uint16Array.BYTES_PER_ELEMENT,4*l),f=new Uint16Array(s.buffer,u*h*Uint16Array.BYTES_PER_ELEMENT,l*h),d=new Uint8Array(n.buffer,4*u,4*l),p=new Float32Array(e.buffer,4*u*Float32Array.BYTES_PER_ELEMENT,4*l);if(o(this._covariancesATexture,_,c.x,r,a),o(this._covariancesBTexture,f,c.x,r,a),o(this._centersTexture,p,c.x,r,a),o(this._colorsTexture,d,c.x,r,a),i)for(let e=0;e<i.length;e++){const t=4,s=new Uint8Array(this._sh[e].buffer,u*t,l*t);o(this._shTextures[e],s,c.x,r,a)}}_instanciateWorker(){if(!this._vertexCount)return;this._updateSplatIndexBuffer(this._vertexCount),this._worker?.terminate(),this._worker=new Worker(URL.createObjectURL(new Blob(["(",y._CreateWorker.toString(),")(self)"],{type:"application/javascript"}))),this._depthMix=new BigInt64Array(this._vertexCount);const e=Float32Array.from(this._splatPositions),t=this._vertexCount;this._worker.postMessage({positions:e,vertexCount:t},[e.buffer]),this._worker.onmessage=e=>{this._depthMix=e.data.depthMix;const s=new Uint32Array(e.data.depthMix.buffer);if(this._splatIndex)for(let e=0;e<this._vertexCount;e++)this._splatIndex[e]=s[2*e];if(this._delayedTextureUpdate){const e=this._getTextureSize(t);this._updateSubTextures(this._delayedTextureUpdate.centers,this._delayedTextureUpdate.covA,this._delayedTextureUpdate.covB,this._delayedTextureUpdate.colors,0,e.y,this._delayedTextureUpdate.sh),this._delayedTextureUpdate=null}this.thinInstanceBufferUpdated("splatIndex"),this._canPostToWorker=!0,this._readyToDisplay=!0,this._sortIsDirty&&(this._postToWorker(!0),this._sortIsDirty=!1)}}_getTextureSize(e){const t=this._scene.getEngine(),s=t.getCaps().maxTextureSize;let n=1;if(1!==t.version||t.isWebGPU)n=Math.ceil(e/s);else for(;s*n<e;)n*=2;return n>s&&(o.V.Error("GaussianSplatting texture size: ("+s+", "+n+"), maxTextureSize: "+s),n=s),new i.I9(s,n)}}y._RowOutputLength=32,y._SH_C0=.28209479177387814,y._SplatBatchSize=327680,y._PlyConversionBatchSize=32768,y.ProgressiveUpdateAmount=0,y._CreateWorker=function(e){let t,s,n,r,a=0;e.onmessage=i=>{if(i.data.positions)t=i.data.positions,a=i.data.vertexCount;else{const o=i.data.view;if(!t||!o)throw new Error("positions or view is not defined!");s=i.data.depthMix,n=new Uint32Array(s.buffer),r=new Float32Array(s.buffer);for(let e=0;e<a;e++)n[2*e]=e;let c=-1;i.data.useRightHandedSystem&&(c=1);for(let e=0;e<a;e++)r[2*e+1]=1e4+(o[2]*t[4*e+0]+o[6]*t[4*e+1]+o[10]*t[4*e+2])*c;s.sort(),e.postMessage({depthMix:s},[s.buffer])}}}},99083:(e,t,s)=>{s.d(t,{M:()=>r,x:()=>a});var n=s(62956);class r{constructor(e,t,s,r,a){this.idx=0,this.color=new n.ov(1,1,1,1),this.position=n.Pq.Zero(),this.rotation=n.Pq.Zero(),this.uv=new n.I9(0,0),this.velocity=n.Pq.Zero(),this.pivot=n.Pq.Zero(),this.translateFromPivot=!1,this._pos=0,this._ind=0,this.groupId=0,this.idxInGroup=0,this._stillInvisible=!1,this._rotationMatrix=[1,0,0,0,1,0,0,0,1],this.parentId=null,this._globalPosition=n.Pq.Zero(),this.idx=e,this._group=t,this.groupId=s,this.idxInGroup=r,this._pcs=a}get size(){return this.size}set size(e){this.size=e}get quaternion(){return this.rotationQuaternion}set quaternion(e){this.rotationQuaternion=e}intersectsMesh(e,t){if(!e.hasBoundingInfo)return!1;if(!this._pcs.mesh)throw new Error("Point Cloud System doesnt contain the Mesh");if(t)return e.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));const s=e.getBoundingInfo().boundingBox,n=s.maximumWorld.x,r=s.minimumWorld.x,a=s.maximumWorld.y,i=s.minimumWorld.y,o=s.maximumWorld.z,c=s.minimumWorld.z,h=this.position.x+this._pcs.mesh.position.x,u=this.position.y+this._pcs.mesh.position.y,l=this.position.z+this._pcs.mesh.position.z;return r<=h&&h<=n&&i<=u&&u<=a&&c<=l&&l<=o}getRotationMatrix(e){let t;if(this.rotationQuaternion)t=this.rotationQuaternion;else{t=n.AA.Quaternion[0];const e=this.rotation;n.PT.RotationYawPitchRollToRef(e.y,e.x,e.z,t)}t.toRotationMatrix(e)}}class a{get groupID(){return this.groupId}set groupID(e){this.groupId=e}constructor(e,t){this.groupId=e,this._positionFunction=t}}}}]);