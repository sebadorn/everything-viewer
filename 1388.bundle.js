"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[1388],{31388:(e,t,s)=>{s.d(t,{EXT_meshopt_compression:()=>c});var r=s(98556),o=s(998);let n=0,a=null;class d{static get Default(){return d._Default||(d._Default=new d),d._Default}constructor(){const e=d.Configuration.decoder;this._decoderModulePromise=o.S0.LoadBabylonScriptAsync(e.url).then(()=>MeshoptDecoder.ready)}dispose(){delete this._decoderModulePromise}async decodeGltfBufferAsync(e,t,s,r,o){await this._decoderModulePromise,0===n&&(MeshoptDecoder.useWorkers(1),n=1);const d=await MeshoptDecoder.decodeGltfBufferAsync(t,s,e,r,o);return null!==a&&clearTimeout(a),a=setTimeout(()=>{MeshoptDecoder.useWorkers(0),n=0,a=null},1e3),d}}d.Configuration={decoder:{url:`${o.S0._DefaultCdnUrl}/meshopt_decoder.js`}},d._Default=null;var l=s(37812);const u="EXT_meshopt_compression";class c{constructor(e){this.name=u,this.enabled=e.isExtensionUsed(u),this._loader=e}dispose(){this._loader=null}loadBufferViewAsync(e,t){return r.BT.LoadExtensionAsync(e,t,this.name,async(s,o)=>{const n=t;if(n._meshOptData)return await n._meshOptData;const a=r.l2.Get(`${e}/buffer`,this._loader.gltf.buffers,o.buffer);return n._meshOptData=this._loader.loadBufferAsync(`/buffers/${a.index}`,a,o.byteOffset||0,o.byteLength).then(async e=>await d.Default.decodeGltfBufferAsync(e,o.count,o.byteStride,o.mode,o.filter)),await n._meshOptData})}}(0,l.Hg)(u),(0,l.Ye)(u,!0,e=>new c(e))}}]);