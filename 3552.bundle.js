"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[3552],{3552:(e,t,i)=>{i.d(t,{HDRCubeTexture:()=>P});var r=i(79923),n=i(82667),a=i(82781),s=i(36755),o=i(99848),h=i(998),l=i(65559),u=i(62956),d=i(84867),c=i(84255);class f{constructor(e,t={}){this._lodGenerationOffset=0,this._lodGenerationScale=.8,this.quality=4096,this.hdrScale=1,this._engine=e,this.hdrScale=t.hdrScale||this.hdrScale,this.quality=t.quality||this.quality}_createRenderTarget(e){let t=0;this._engine.getCaps().textureHalfFloatRender?t=2:this._engine.getCaps().textureFloatRender&&(t=1);const i=this._engine.createRenderTargetCubeTexture(e,{format:5,type:t,createMipMaps:!0,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:1,label:"HDR_Radiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(i.texture,0,0,0),this._engine.updateTextureSamplingMode(3,i.texture,!0),i}_prefilterInternal(e){const t=e.getSize().width,i=(0,d.ILog2)(t)+1,r=this._effectWrapper.effect,n=this._createRenderTarget(t);this._effectRenderer.saveStates(),this._effectRenderer.setViewport();const a=e.getInternalTexture();a&&this._engine.updateTextureSamplingMode(3,a,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const s=[[new u.Pq(0,0,-1),new u.Pq(0,-1,0),new u.Pq(1,0,0)],[new u.Pq(0,0,1),new u.Pq(0,-1,0),new u.Pq(-1,0,0)],[new u.Pq(1,0,0),new u.Pq(0,0,1),new u.Pq(0,1,0)],[new u.Pq(1,0,0),new u.Pq(0,0,-1),new u.Pq(0,-1,0)],[new u.Pq(1,0,0),new u.Pq(0,-1,0),new u.Pq(0,0,1)],[new u.Pq(-1,0,0),new u.Pq(0,-1,0),new u.Pq(0,0,-1)]];r.setFloat("hdrScale",this.hdrScale),r.setFloat2("vFilteringInfo",e.getSize().width,i),r.setTexture("inputTexture",e);for(let e=0;e<6;e++){r.setVector3("up",s[e][0]),r.setVector3("right",s[e][1]),r.setVector3("front",s[e][2]);for(let a=0;a<i;a++){this._engine.bindFramebuffer(n,e,void 0,void 0,!0,a),this._effectRenderer.applyEffectWrapper(this._effectWrapper);let i=Math.pow(2,(a-this._lodGenerationOffset)/this._lodGenerationScale)/t;0===a&&(i=0),r.setFloat("alphaG",i),this._effectRenderer.draw()}}this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),this._engine._releaseTexture(e._texture);const o=n.texture.type,h=n.texture.format;return n._swapAndDie(e._texture),e._texture.type=o,e._texture.format=h,e.gammaSpace=!1,e.lodGenerationOffset=this._lodGenerationOffset,e.lodGenerationScale=this._lodGenerationScale,e._prefiltered=!0,e}_createEffect(e,t){const r=[];e.gammaSpace&&r.push("#define GAMMA_INPUT"),r.push("#define NUM_SAMPLES "+this.quality+"u");const n=this._engine.isWebGPU;return new c.$({engine:this._engine,name:"hdrFiltering",vertexShader:"hdrFiltering",fragmentShader:"hdrFiltering",samplerNames:["inputTexture"],uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale","alphaG"],useShaderStore:!0,defines:r,onCompiled:t,shaderLanguage:n?1:0,extraInitializationsAsync:async()=>{n?await Promise.all([i.e(2248).then(i.bind(i,92248)),Promise.all([i.e(2703),i.e(274)]).then(i.bind(i,50274))]):await Promise.all([i.e(6109).then(i.bind(i,86109)),Promise.all([i.e(8481),i.e(5779)]).then(i.bind(i,55779))])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this._effectRenderer=new c.J(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync(),this._prefilterInternal(e),this._effectRenderer.dispose(),this._effectWrapper.dispose()}}var p=i(89974);class _{constructor(e,t={}){this.quality=4096,this.hdrScale=1,this.useCdf=!1,this._engine=e,this.hdrScale=t.hdrScale||this.hdrScale,this.quality=t.quality||this.quality,this.useCdf=t.useCdf||this.useCdf}_createRenderTarget(e){let t=0;this._engine.getCaps().textureHalfFloatRender?t=2:this._engine.getCaps().textureFloatRender&&(t=1);const i=this._engine.createRenderTargetCubeTexture(e,{format:5,type:t,createMipMaps:!1,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:2,label:"HDR_Irradiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(i.texture,0,0,0),i}_prefilterInternal(e){const t=e.getSize().width,i=(0,d.ILog2)(t),r=this._effectWrapper.effect,a=Math.max(32,1<<(0,d.ILog2)(t>>3)),s=this._createRenderTarget(a);this._effectRenderer.saveStates(),this._effectRenderer.setViewport(),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const o=[[new u.Pq(0,0,-1),new u.Pq(0,-1,0),new u.Pq(1,0,0)],[new u.Pq(0,0,1),new u.Pq(0,-1,0),new u.Pq(-1,0,0)],[new u.Pq(1,0,0),new u.Pq(0,0,1),new u.Pq(0,1,0)],[new u.Pq(1,0,0),new u.Pq(0,0,-1),new u.Pq(0,-1,0)],[new u.Pq(1,0,0),new u.Pq(0,-1,0),new u.Pq(0,0,1)],[new u.Pq(-1,0,0),new u.Pq(0,-1,0),new u.Pq(0,0,-1)]];r.setFloat("hdrScale",this.hdrScale),r.setFloat2("vFilteringInfo",e.getSize().width,i),r.setTexture("inputTexture",e),this._cdfGenerator&&r.setTexture("icdfTexture",this._cdfGenerator.getIcdfTexture());for(let e=0;e<6;e++)r.setVector3("up",o[e][0]),r.setVector3("right",o[e][1]),r.setVector3("front",o[e][2]),this._engine.bindFramebuffer(s,e,void 0,void 0,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper),this._effectRenderer.draw();this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),r.setTexture("inputTexture",null),r.setTexture("icdfTexture",null);const h=new n.t(e.getScene(),s.texture);return h.name=e.name+"_irradiance",h.displayName=e.name+"_irradiance",h.gammaSpace=!1,h}_createEffect(e,t){const r=[];e.gammaSpace&&r.push("#define GAMMA_INPUT"),r.push("#define NUM_SAMPLES "+this.quality+"u");const n=this._engine.isWebGPU,a=["inputTexture"];this._cdfGenerator&&(a.push("icdfTexture"),r.push("#define IBL_CDF_FILTERING"));return new c.$({engine:this._engine,name:"HDRIrradianceFiltering",vertexShader:"hdrIrradianceFiltering",fragmentShader:"hdrIrradianceFiltering",samplerNames:a,uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale"],useShaderStore:!0,defines:r,onCompiled:t,shaderLanguage:n?1:0,extraInitializationsAsync:async()=>{n?await Promise.all([i.e(858).then(i.bind(i,858)),Promise.all([i.e(2703),i.e(4972)]).then(i.bind(i,64972))]):await Promise.all([i.e(4619).then(i.bind(i,94619)),Promise.all([i.e(8481),i.e(8961)]).then(i.bind(i,18961))])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this.useCdf&&(this._cdfGenerator=new p.IblCdfGenerator(this._engine),this._cdfGenerator.iblSource=e,await this._cdfGenerator.renderWhenReady()),this._effectRenderer=new c.J(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync();const t=this._prefilterInternal(e);return this.useCdf&&await this._cdfGenerator.findDominantDirection().then(e=>{t._dominantDirection=e}),this._effectRenderer.dispose(),this._effectWrapper.dispose(),this._cdfGenerator?.dispose(),t}}var g=i(42683);i(69764);class w extends n.t{set isBlocking(e){this._isBlocking=e}get isBlocking(){return this._isBlocking}set rotationY(e){this._rotationY=e,this.setReflectionTextureMatrix(r.uq.RotationY(this._rotationY))}get rotationY(){return this._rotationY}set boundingBoxSize(e){if(this._boundingBoxSize&&this._boundingBoxSize.equals(e))return;this._boundingBoxSize=e;const t=this.getScene();t&&t.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}constructor(e,t,i,n=!1,s=!0,l=!1,u=!1,d=null,c=null,f=!1,p=!1,_=!1){super(t),this._generateHarmonics=!0,this._onError=null,this._isBlocking=!0,this._rotationY=0,this.boundingBoxPosition=r.Pq.Zero(),this.onLoadObservable=new o.cP,e&&(this._coordinatesMode=a.g.CUBIC_MODE,this.name=e,this.url=e,this.hasAlpha=!1,this.isCube=!0,this._textureMatrix=r.uq.Identity(),this._prefilterOnLoad=u,this._prefilterIrradianceOnLoad=p,this._prefilterUsingCdf=_,this._onLoad=()=>{this.onLoadObservable.notifyObservers(this),d&&d()},this._onError=c,this.gammaSpace=l,this._noMipmap=n,this._size=i,this._supersample=f||_,this._generateHarmonics=s,this._texture=this._getFromCache(e,this._noMipmap,void 0,void 0,void 0,this.isCube),this._texture?this._texture.isReady?h.S0.SetImmediate(()=>this._onLoad()):this._texture.onLoadedObservable.add(this._onLoad):this.getScene()?.useDelayedTextureLoading?this.delayLoadState=4:this._loadTexture())}getClassName(){return"EnvCubeTexture"}_loadTexture(){const e=this._getEngine(),t=e.getCaps();let i=0;t.textureFloat&&t.textureFloatLinearFiltering?i=1:t.textureHalfFloat&&t.textureHalfFloatLinearFiltering&&(i=2);if(e._features.allowTexturePrefiltering&&(this._prefilterOnLoad||this._prefilterIrradianceOnLoad)){const t=this._onLoad,i=new f(e);this._onLoad=()=>{let r=Promise.resolve(null),n=Promise.resolve();if(this._prefilterIrradianceOnLoad){r=new _(e,{useCdf:this._prefilterUsingCdf}).prefilter(this)}this._prefilterOnLoad&&(n=i.prefilter(this)),Promise.all([r,n]).then(e=>{const i=e[0];if(this._prefilterIrradianceOnLoad&&i){this.irradianceTexture=i;const e=this.getScene();e&&e.markAllMaterialsAsDirty(1)}t&&t()})}}this._texture=e.createRawCubeTextureFromUrl(this.url,this.getScene(),this._size,4,i,this._noMipmap,async e=>{this.lodGenerationOffset=0,this.lodGenerationScale=.8;const t=await this._getCubeMapTextureDataAsync(e,this._size,this._supersample);if(this._generateHarmonics){const e=s.d.ConvertCubeMapToSphericalPolynomial(t);this.sphericalPolynomial=e}const r=[];let n=null,a=null;for(let e=0;e<6;e++){2===i?a=new Uint16Array(this._size*this._size*3):0===i&&(n=new Uint8Array(this._size*this._size*3));const s=t[w._FacesMapping[e]];if(this.gammaSpace||a||n)for(let e=0;e<this._size*this._size;e++)if(this.gammaSpace&&(s[3*e+0]=Math.pow(s[3*e+0],l.rv),s[3*e+1]=Math.pow(s[3*e+1],l.rv),s[3*e+2]=Math.pow(s[3*e+2],l.rv)),a&&(a[3*e+0]=(0,g.LZ)(s[3*e+0]),a[3*e+1]=(0,g.LZ)(s[3*e+1]),a[3*e+2]=(0,g.LZ)(s[3*e+2])),n){let t=Math.max(255*s[3*e+0],0),i=Math.max(255*s[3*e+1],0),r=Math.max(255*s[3*e+2],0);const a=Math.max(Math.max(t,i),r);if(a>255){const e=255/a;t*=e,i*=e,r*=e}n[3*e+0]=t,n[3*e+1]=i,n[3*e+2]=r}a?r.push(a):n?r.push(n):r.push(s)}return r},null,this._onLoad,this._onError)}delayLoad(){4===this.delayLoadState&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,this._noMipmap),this._texture||this._loadTexture())}getReflectionTextureMatrix(){return this._textureMatrix}setReflectionTextureMatrix(e){this._textureMatrix=e,e.updateFlag!==this._textureMatrix.updateFlag&&e.isIdentity()!==this._textureMatrix.isIdentity()&&this.getScene()?.markAllMaterialsAsDirty(1,e=>-1!==e.getActiveTextures().indexOf(this))}dispose(){this.onLoadObservable.clear(),super.dispose()}serialize(){if(!this.name)return null;const e={};return e.name=this.name,e.hasAlpha=this.hasAlpha,e.isCube=!0,e.level=this.level,e.size=this._size,e.coordinatesMode=this.coordinatesMode,e.useInGammaSpace=this.gammaSpace,e.generateHarmonics=this._generateHarmonics,e.noMipmap=this._noMipmap,e.isBlocking=this._isBlocking,e.rotationY=this._rotationY,e}clone(){const e=this._instantiateClone();return e.level=this.level,e.wrapU=this.wrapU,e.wrapV=this.wrapV,e.coordinatesIndex=this.coordinatesIndex,e.coordinatesMode=this.coordinatesMode,e}static _Parse(e,t){t.name=e.name,t.hasAlpha=e.hasAlpha,t.level=e.level,t.coordinatesMode=e.coordinatesMode,t.isBlocking=e.isBlocking,e.boundingBoxPosition&&(t.boundingBoxPosition=r.Pq.FromArray(e.boundingBoxPosition)),e.boundingBoxSize&&(t.boundingBoxSize=r.Pq.FromArray(e.boundingBoxSize)),e.rotationY&&(t.rotationY=e.rotationY)}}w._FacesMapping=["right","left","up","down","front","back"];var m=i(47407),x=i(56552);class P extends w{constructor(e,t,i,r=!1,n=!0,a=!1,s=!1,o=null,h=null,l=!1,u=!1,d=!1){super(e,t,i,r,n,a,s,o,h,l,u,d)}getClassName(){return"HDRCubeTexture"}async _getCubeMapTextureDataAsync(e,t,i){return(0,m.VH)(e,t,i)}_instantiateClone(){return new P(this.url,this.getScene()||this._getEngine(),this._size,this._noMipmap,this._generateHarmonics,this.gammaSpace)}serialize(){const e=super.serialize();return e?(e.customType="BABYLON.HDRCubeTexture",e):null}static Parse(e,t,i){if(!e.name||e.isRenderTarget)return null;const r=new P(i+e.name,t,e.size,e.noMipmap,e.generateHarmonics,e.useInGammaSpace);return this._Parse(e,r),r}}(0,x.Y5)("BABYLON.HDRCubeTexture",P)},47407:(e,t,i)=>{i.d(t,{VH:()=>h,NK:()=>o,LT:()=>l});var r=i(79923);class n{static ConvertPanoramaToCubemap(e,t,i,r,n=!1,a=!0){if(!e)throw"ConvertPanoramaToCubemap: input cannot be null";let s=0;if(e.length!=t*i*3){if(e.length!=t*i*4)throw"ConvertPanoramaToCubemap: input size is wrong";s=4}else s=3;return{front:this.CreateCubemapTexture(r,this.FACE_FRONT,e,t,i,n,a,s),back:this.CreateCubemapTexture(r,this.FACE_BACK,e,t,i,n,a,s),left:this.CreateCubemapTexture(r,this.FACE_LEFT,e,t,i,n,a,s),right:this.CreateCubemapTexture(r,this.FACE_RIGHT,e,t,i,n,a,s),up:this.CreateCubemapTexture(r,this.FACE_UP,e,t,i,n,a,s),down:this.CreateCubemapTexture(r,this.FACE_DOWN,e,t,i,n,a,s),size:r,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(e,t,i,r,n,a,s,o){const h=new ArrayBuffer(e*e*4*3),l=new Float32Array(h),u=a?Math.max(1,Math.round(r/4/e)):1,d=1/u,c=d*d,f=t[1].subtract(t[0]).scale(d/e),p=t[3].subtract(t[2]).scale(d/e),_=1/e;let g=0;for(let a=0;a<e;a++)for(let h=0;h<u;h++){let h=t[0],w=t[2];for(let t=0;t<e;t++)for(let d=0;d<u;d++){const u=w.subtract(h).scale(g).add(h);u.normalize();const d=this.CalcProjectionSpherical(u,i,r,n,o,s);l[a*e*3+3*t+0]+=d.r*c,l[a*e*3+3*t+1]+=d.g*c,l[a*e*3+3*t+2]+=d.b*c,h=h.add(f),w=w.add(p)}g+=_*d}return l}static CalcProjectionSpherical(e,t,i,r,n,a){let s=Math.atan2(e.z,e.x);const o=Math.acos(e.y);for(;s<-Math.PI;)s+=2*Math.PI;for(;s>Math.PI;)s-=2*Math.PI;let h=s/Math.PI;const l=o/Math.PI;h=.5*h+.5;let u=Math.round(h*i);u<0?u=0:u>=i&&(u=i-1);let d=Math.round(l*r);d<0?d=0:d>=r&&(d=r-1);const c=a?r-d-1:d;return{r:t[c*i*n+u*n+0],g:t[c*i*n+u*n+1],b:t[c*i*n+u*n+2]}}}function a(e,t,i,r,n,a){n>0?(n=function(e,t){return t>1023?e*Math.pow(2,1023)*Math.pow(2,t-1023):t<-1074?e*Math.pow(2,-1074)*Math.pow(2,t+1074):e*Math.pow(2,t)}(1,n-136),e[a+0]=t*n,e[a+1]=i*n,e[a+2]=r*n):(e[a+0]=0,e[a+1]=0,e[a+2]=0)}function s(e,t){let i="",r="";for(let n=t;n<e.length-t&&(r=String.fromCharCode(e[n]),"\n"!=r);n++)i+=r;return i}function o(e){let t=0,i=0,r=s(e,0);if("#"!=r[0]||"?"!=r[1])throw"Bad HDR Format.";let n=!1,a=!1,o=0;do{o+=r.length+1,r=s(e,o),"FORMAT=32-bit_rle_rgbe"==r?a=!0:0==r.length&&(n=!0)}while(!n);if(!a)throw"HDR Bad header format, unsupported FORMAT";o+=r.length+1,r=s(e,o);const h=/^-Y (.*) \+X (.*)$/g.exec(r);if(!h||h.length<3)throw"HDR Bad header format, no size";if(i=parseInt(h[2]),t=parseInt(h[1]),i<8||i>32767)throw"HDR Bad header format, unsupported size";return o+=r.length+1,{height:t,width:i,dataPosition:o}}function h(e,t,i=!1){const r=new Uint8Array(e),a=o(r),s=l(r,a);return n.ConvertPanoramaToCubemap(s,a.width,a.height,t,i)}function l(e,t){return function(e,t){let i=t.height;const r=t.width;let n,s,o,h,l,d=t.dataPosition,c=0,f=0,p=0;const _=new ArrayBuffer(4*r),g=new Uint8Array(_),w=new ArrayBuffer(t.width*t.height*4*3),m=new Float32Array(w);for(;i>0;){if(n=e[d++],s=e[d++],o=e[d++],h=e[d++],2!=n||2!=s||128&o||t.width<8||t.width>32767)return u(e,t);if((o<<8|h)!=r)throw"HDR Bad header format, wrong scan line width";for(c=0,p=0;p<4;p++)for(f=(p+1)*r;c<f;)if(n=e[d++],s=e[d++],n>128){if(l=n-128,0==l||l>f-c)throw"HDR Bad Format, bad scanline data (run)";for(;l-- >0;)g[c++]=s}else{if(l=n,0==l||l>f-c)throw"HDR Bad Format, bad scanline data (non-run)";if(g[c++]=s,--l>0)for(let t=0;t<l;t++)g[c++]=e[d++]}for(p=0;p<r;p++)n=g[p],s=g[p+r],o=g[p+2*r],h=g[p+3*r],a(m,n,s,o,h,(t.height-i)*r*3+3*p);i--}return m}(e,t)}function u(e,t){let i=t.height;const r=t.width;let n,s,o,h,l,u=t.dataPosition;const d=new ArrayBuffer(t.width*t.height*4*3),c=new Float32Array(d);for(;i>0;){for(l=0;l<t.width;l++)n=e[u++],s=e[u++],o=e[u++],h=e[u++],a(c,n,s,o,h,(t.height-i)*r*3+3*l);i--}return c}n.FACE_LEFT=[new r.Pq(-1,-1,-1),new r.Pq(1,-1,-1),new r.Pq(-1,1,-1),new r.Pq(1,1,-1)],n.FACE_RIGHT=[new r.Pq(1,-1,1),new r.Pq(-1,-1,1),new r.Pq(1,1,1),new r.Pq(-1,1,1)],n.FACE_FRONT=[new r.Pq(1,-1,-1),new r.Pq(1,-1,1),new r.Pq(1,1,-1),new r.Pq(1,1,1)],n.FACE_BACK=[new r.Pq(-1,-1,1),new r.Pq(-1,-1,-1),new r.Pq(-1,1,1),new r.Pq(-1,1,-1)],n.FACE_DOWN=[new r.Pq(1,1,-1),new r.Pq(1,1,1),new r.Pq(-1,1,-1),new r.Pq(-1,1,1)],n.FACE_UP=[new r.Pq(-1,-1,-1),new r.Pq(-1,-1,1),new r.Pq(1,-1,-1),new r.Pq(1,-1,1)]}}]);