"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[5538],{35538:(t,a,e)=>{e.d(a,{KHR_materials_variants:()=>l});var n=e(98556),s=e(85530),i=e(37812);const r="KHR_materials_variants";class l{constructor(t){this.name=r,this._loader=t,this.enabled=this._loader.isExtensionUsed(r)}dispose(){this._loader=null}static GetAvailableVariants(t){const a=this._GetExtensionMetadata(t);return a?Object.keys(a.variants):[]}getAvailableVariants(t){return l.GetAvailableVariants(t)}static SelectVariant(t,a){const e=this._GetExtensionMetadata(t);if(!e)throw new Error(`Cannot select variant on a glTF mesh that does not have the ${r} extension`);const n=t=>{const a=e.variants[t];if(a)for(const t of a)t.mesh.material=t.material};if(a instanceof Array)for(const t of a)n(t);else n(a);e.lastSelected=a}selectVariant(t,a){l.SelectVariant(t,a)}static Reset(t){const a=this._GetExtensionMetadata(t);if(!a)throw new Error(`Cannot reset on a glTF mesh that does not have the ${r} extension`);for(const t of a.original)t.mesh.material=t.material;a.lastSelected=null}reset(t){l.Reset(t)}static GetLastSelectedVariant(t){const a=this._GetExtensionMetadata(t);if(!a)throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${r} extension`);return a.lastSelected}getLastSelectedVariant(t){return l.GetLastSelectedVariant(t)}static _GetExtensionMetadata(t){return t?._internalMetadata?.gltf?.[r]||null}onLoading(){const t=this._loader.gltf.extensions;if(t&&t[this.name]){const a=t[this.name];this._variants=a.variants}}onReady(){const t=this._loader.rootBabylonMesh;if(t){const a=this._loader.parent.extensionOptions[r];a?.defaultVariant&&l.SelectVariant(t,a.defaultVariant),a?.onLoaded?.({get variants(){return l.GetAvailableVariants(t)},get selectedVariant(){const a=l.GetLastSelectedVariant(t);return a?Array.isArray(a)?a[0]:a:l.GetAvailableVariants(t)[0]},set selectedVariant(a){l.SelectVariant(t,a)}})}}_loadMeshPrimitiveAsync(t,a,e,i,o,h){return n.BT.LoadExtensionAsync(t,o,this.name,async(d,c)=>{const f=new Array;return f.push(this._loader._loadMeshPrimitiveAsync(t,a,e,i,o,a=>{if(h(a),a instanceof s.e){const e=n.BT._GetDrawMode(t,o.mode),s=this._loader.rootBabylonMesh,i=s?s._internalMetadata=s._internalMetadata||{}:{},h=i.gltf=i.gltf||{},m=h[r]=h[r]||{lastSelected:null,original:[],variants:{}};m.original.push({mesh:a,material:a.material});for(let t=0;t<c.mappings.length;++t){const i=c.mappings[t],o=n.l2.Get(`${d}/mappings/${t}/material`,this._loader.gltf.materials,i.material);f.push(this._loader._loadMaterialAsync(`#/materials/${i.material}`,o,a,e,t=>{for(let e=0;e<i.variants.length;++e){const o=i.variants[e],h=n.l2.Get(`/extensions/${r}/variants/${o}`,this._variants,o);m.variants[h.name]=m.variants[h.name]||[],m.variants[h.name].push({mesh:a,material:t}),a.onClonedObservable.add(t=>{const e=t;let n=null,i=e;do{if(i=i.parent,!i)return;n=l._GetExtensionMetadata(i)}while(null===n);if(s&&n===l._GetExtensionMetadata(s)){i._internalMetadata={};for(const t in s._internalMetadata)i._internalMetadata[t]=s._internalMetadata[t];i._internalMetadata.gltf=[];for(const t in s._internalMetadata.gltf)i._internalMetadata.gltf[t]=s._internalMetadata.gltf[t];i._internalMetadata.gltf[r]={lastSelected:null,original:[],variants:{}};for(const t of n.original)i._internalMetadata.gltf[r].original.push({mesh:t.mesh,material:t.material});for(const t in n.variants)if(Object.prototype.hasOwnProperty.call(n.variants,t)){i._internalMetadata.gltf[r].variants[t]=[];for(const a of n.variants[t])i._internalMetadata.gltf[r].variants[t].push({mesh:a.mesh,material:a.material})}n=i._internalMetadata.gltf[r]}for(const t of n.original)t.mesh===a&&(t.mesh=e);for(const t of n.variants[h.name])t.mesh===a&&(t.mesh=e)})}}))}}})),await Promise.all(f).then(([t])=>t)})}}(0,i.Hg)(r),(0,i.Ye)(r,!0,t=>new l(t))}}]);