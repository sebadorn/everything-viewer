"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[967],{52046:(t,o,e)=>{e.d(o,{Z:()=>u});var i=e(75524),s=e(79259),r=e(79923),h=e(4870),n=e(64704),a=e(83316),d=e(56552);h.b.AddNodeConstructor("Light_Type_1",((t,o)=>()=>new u(t,r.Pq.Zero(),o)));class u extends a.p{get shadowFrustumSize(){return this._shadowFrustumSize}set shadowFrustumSize(t){this._shadowFrustumSize=t,this.forceProjectionMatrixCompute()}get shadowOrthoScale(){return this._shadowOrthoScale}set shadowOrthoScale(t){this._shadowOrthoScale=t,this.forceProjectionMatrixCompute()}get orthoLeft(){return this._orthoLeft}set orthoLeft(t){this._orthoLeft=t}get orthoRight(){return this._orthoRight}set orthoRight(t){this._orthoRight=t}get orthoTop(){return this._orthoTop}set orthoTop(t){this._orthoTop=t}get orthoBottom(){return this._orthoBottom}set orthoBottom(t){this._orthoBottom=t}constructor(t,o,e){super(t,e),this._shadowFrustumSize=0,this._shadowOrthoScale=.1,this.autoUpdateExtends=!0,this.autoCalcShadowZBounds=!1,this._orthoLeft=Number.MAX_VALUE,this._orthoRight=Number.MIN_VALUE,this._orthoTop=Number.MIN_VALUE,this._orthoBottom=Number.MAX_VALUE,this.position=o.scale(-1),this.direction=o}getClassName(){return"DirectionalLight"}getTypeID(){return n.v.LIGHTTYPEID_DIRECTIONALLIGHT}_setDefaultShadowProjectionMatrix(t,o,e){this.shadowFrustumSize>0?this._setDefaultFixedFrustumShadowProjectionMatrix(t):this._setDefaultAutoExtendShadowProjectionMatrix(t,o,e)}_setDefaultFixedFrustumShadowProjectionMatrix(t){const o=this.getScene().activeCamera;o&&r.uq.OrthoLHToRef(this.shadowFrustumSize,this.shadowFrustumSize,void 0!==this.shadowMinZ?this.shadowMinZ:o.minZ,void 0!==this.shadowMaxZ?this.shadowMaxZ:o.maxZ,t,this.getScene().getEngine().isNDCHalfZRange)}_setDefaultAutoExtendShadowProjectionMatrix(t,o,e){const i=this.getScene().activeCamera;if(this.autoUpdateExtends||this._orthoLeft===Number.MAX_VALUE){const t=r.Pq.Zero();this._orthoLeft=Number.MAX_VALUE,this._orthoRight=-Number.MAX_VALUE,this._orthoTop=-Number.MAX_VALUE,this._orthoBottom=Number.MAX_VALUE;let i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(let h=0;h<e.length;h++){const n=e[h];if(!n)continue;const a=n.getBoundingInfo().boundingBox;for(let e=0;e<a.vectorsWorld.length;e++)r.Pq.TransformCoordinatesToRef(a.vectorsWorld[e],o,t),t.x<this._orthoLeft&&(this._orthoLeft=t.x),t.y<this._orthoBottom&&(this._orthoBottom=t.y),t.x>this._orthoRight&&(this._orthoRight=t.x),t.y>this._orthoTop&&(this._orthoTop=t.y),this.autoCalcShadowZBounds&&(t.z<i&&(i=t.z),t.z>s&&(s=t.z))}this.autoCalcShadowZBounds&&(this._shadowMinZ=i,this._shadowMaxZ=s)}const s=this._orthoRight-this._orthoLeft,h=this._orthoTop-this._orthoBottom,n=void 0!==this.shadowMinZ?this.shadowMinZ:i?.minZ||0,a=void 0!==this.shadowMaxZ?this.shadowMaxZ:i?.maxZ||1e4,d=this.getScene().getEngine().useReverseDepthBuffer;r.uq.OrthoOffCenterLHToRef(this._orthoLeft-s*this.shadowOrthoScale,this._orthoRight+s*this.shadowOrthoScale,this._orthoBottom-h*this.shadowOrthoScale,this._orthoTop+h*this.shadowOrthoScale,d?a:n,d?n:a,t,this.getScene().getEngine().isNDCHalfZRange)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(t,o){return this.computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z,1,o),this):(this._uniformBuffer.updateFloat4("vLightData",this.direction.x,this.direction.y,this.direction.z,1,o),this)}transferToNodeMaterialEffect(t,o){return this.computeTransformedInformation()?(t.setFloat3(o,this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z),this):(t.setFloat3(o,this.direction.x,this.direction.y,this.direction.z),this)}getDepthMinZ(t){const o=this._scene.getEngine();return!o.useReverseDepthBuffer&&o.isNDCHalfZRange?0:1}getDepthMaxZ(t){const o=this._scene.getEngine();return o.useReverseDepthBuffer&&o.isNDCHalfZRange?0:1}prepareLightSpecificDefines(t,o){t["DIRLIGHT"+o]=!0}}(0,i.Cg)([(0,s.lK)()],u.prototype,"shadowFrustumSize",null),(0,i.Cg)([(0,s.lK)()],u.prototype,"shadowOrthoScale",null),(0,i.Cg)([(0,s.lK)()],u.prototype,"autoUpdateExtends",void 0),(0,i.Cg)([(0,s.lK)()],u.prototype,"autoCalcShadowZBounds",void 0),(0,i.Cg)([(0,s.lK)("orthoLeft")],u.prototype,"_orthoLeft",void 0),(0,i.Cg)([(0,s.lK)("orthoRight")],u.prototype,"_orthoRight",void 0),(0,i.Cg)([(0,s.lK)("orthoTop")],u.prototype,"_orthoTop",void 0),(0,i.Cg)([(0,s.lK)("orthoBottom")],u.prototype,"_orthoBottom",void 0),(0,d.Y5)("BABYLON.DirectionalLight",u)},67524:(t,o,e)=>{e.d(o,{H:()=>u});var i=e(75524),s=e(79259),r=e(79923),h=e(4870),n=e(64704),a=e(83316),d=e(56552);h.b.AddNodeConstructor("Light_Type_0",((t,o)=>()=>new u(t,r.Pq.Zero(),o)));class u extends a.p{get shadowAngle(){return this._shadowAngle}set shadowAngle(t){this._shadowAngle=t,this.forceProjectionMatrixCompute()}get direction(){return this._direction}set direction(t){const o=this.needCube();if(this._direction=t,this.needCube()!==o&&this._shadowGenerators){const t=this._shadowGenerators.values();for(let o=t.next();!0!==o.done;o=t.next()){o.value.recreateShadowMap()}}}constructor(t,o,e){super(t,e),this._shadowAngle=Math.PI/2,this.position=o}getClassName(){return"PointLight"}getTypeID(){return n.v.LIGHTTYPEID_POINTLIGHT}needCube(){return!this.direction}getShadowDirection(t){if(this.direction)return super.getShadowDirection(t);switch(t){case 0:return new r.Pq(1,0,0);case 1:return new r.Pq(-1,0,0);case 2:return new r.Pq(0,-1,0);case 3:return new r.Pq(0,1,0);case 4:return new r.Pq(0,0,1);case 5:return new r.Pq(0,0,-1)}return r.Pq.Zero()}_setDefaultShadowProjectionMatrix(t,o,e){const i=this.getScene().activeCamera;if(!i)return;const s=void 0!==this.shadowMinZ?this.shadowMinZ:i.minZ,h=void 0!==this.shadowMaxZ?this.shadowMaxZ:i.maxZ,n=this.getScene().getEngine().useReverseDepthBuffer;r.uq.PerspectiveFovLHToRef(this.shadowAngle,1,n?h:s,n?s:h,t,!0,this._scene.getEngine().isNDCHalfZRange,void 0,n)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(t,o){return this.computeTransformedInformation()?this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z,0,o):this._uniformBuffer.updateFloat4("vLightData",this.position.x,this.position.y,this.position.z,0,o),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,0,0,o),this}transferToNodeMaterialEffect(t,o){return this.computeTransformedInformation()?t.setFloat3(o,this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z):t.setFloat3(o,this.position.x,this.position.y,this.position.z),this}prepareLightSpecificDefines(t,o){t["POINTLIGHT"+o]=!0}}(0,i.Cg)([(0,s.lK)()],u.prototype,"shadowAngle",null),(0,d.Y5)("BABYLON.PointLight",u)},90967:(t,o,e)=>{e.d(o,{KHR_lights:()=>l});var i=e(79923),s=e(26041),r=e(52046),h=e(67524),n=e(40136),a=e(64704),d=e(45316),u=e(37812);const f="KHR_lights_punctual";class l{constructor(t){this.name=f,this._loader=t,this.enabled=this._loader.isExtensionUsed(f)}dispose(){this._loader=null,delete this._lights}onLoading(){const t=this._loader.gltf.extensions;if(t&&t[this.name]){const o=t[this.name];this._lights=o.lights,d.l2.Assign(this._lights)}}loadNodeAsync(t,o,e){return d.BT.LoadExtensionAsync(t,o,this.name,((u,f)=>(this._loader._allMaterialsDirtyRequired=!0,this._loader.loadNodeAsync(t,o,(t=>{let o;const l=d.l2.Get(u,this._lights,f.light),c=l.name||t.name;switch(this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer,l.type){case"directional":{const t=new r.Z(c,i.Pq.Backward(),this._loader.babylonScene);t.position.setAll(0),o=t;break}case"point":o=new h.H(c,i.Pq.Zero(),this._loader.babylonScene);break;case"spot":{const t=new n.n(c,i.Pq.Zero(),i.Pq.Backward(),0,1,this._loader.babylonScene);t.angle=2*(l.spot&&l.spot.outerConeAngle||Math.PI/4),t.innerAngle=2*(l.spot&&l.spot.innerConeAngle||0),o=t;break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${u}: Invalid light type (${l.type})`)}o._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,l._babylonLight=o,o.falloffType=a.v.FALLOFF_GLTF,o.diffuse=l.color?s.v9.FromArray(l.color):s.v9.White(),o.intensity=null==l.intensity?1:l.intensity,o.range=null==l.range?Number.MAX_VALUE:l.range,o.parent=t,this._loader._babylonLights.push(o),d.BT.AddPointerMetadata(o,u),e(t)})))))}}(0,u.Hg)(f),(0,u.Ye)(f,!0,(t=>new l(t)))}}]);