"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[7353],{2215:(e,t,n)=>{var r=n(69610);const s="logDepthVertex",a="#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a)},2360:(e,t,n)=>{var r=n(69610);const s="fogFragment",a="#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a)},6874:(e,t,n)=>{var r=n(69610);const s="meshUboDeclaration",a="struct Mesh {world : mat4x4<f32>,\nvisibility : f32,};var<uniform> mesh : Mesh;\n#define WORLD_UBO\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},7806:(e,t,n)=>{var r=n(69610);const s="fogFragmentDeclaration",a="#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()\n{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a)},16470:(e,t,n)=>{var r=n(69610);const s="fogVertex",a="#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a)},18335:(e,t,n)=>{n.r(t),n.d(t,{gaussianSplattingPixelShader:()=>c});var r=n(69610);n(6194),n(34581),n(7806),n(29741),n(2360);const s="gaussianSplattingFragmentDeclaration",a="vec4 gaussianColor(vec4 inColor)\n{float A=-dot(vPosition,vPosition);if (A<-4.0) discard;float B=exp(A)*inColor.a;\n#include<logDepthFragment>\nvec3 color=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4(color,B);}\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a);n(7412);const i="gaussianSplattingPixelShader",o="#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vec4 vColor;varying vec2 vPosition;\n#include<gaussianSplattingFragmentDeclaration>\nvoid main () { \n#include<clipPlaneFragment>\ngl_FragColor=gaussianColor(vColor);}\n";r.l.ShadersStore[i]||(r.l.ShadersStore[i]=o);const c={name:i,shader:o}},23758:(e,t,n)=>{n.r(t),n.d(t,{gaussianSplattingPixelShaderWGSL:()=>c});var r=n(69610);n(39759),n(93226),n(66407),n(38780),n(93243);const s="gaussianSplattingFragmentDeclaration",a="fn gaussianColor(inColor: vec4f,inPosition: vec2f)->vec4f\n{var A : f32=-dot(inPosition,inPosition);if (A>-4.0)\n{var B: f32=exp(A)*inColor.a;\n#include<logDepthFragment>\nvar color: vec3f=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4f(color,B);} else {return vec4f(0.0);}}\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a);n(97715);const i="gaussianSplattingPixelShader",o="#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplattingFragmentDeclaration>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\nfragmentOutputs.color=gaussianColor(input.vColor,input.vPosition);}\n";r.l.ShadersStoreWGSL[i]||(r.l.ShadersStoreWGSL[i]=o);const c={name:i,shader:o}},28764:(e,t,n)=>{var r=n(69610);const s="sceneUboDeclaration",a="layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif \nmat4 view;mat4 projection;vec4 vEyePosition;};\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a)},29741:(e,t,n)=>{var r=n(69610);const s="logDepthFragment",a="#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a)},34581:(e,t,n)=>{var r=n(69610);const s="logDepthDeclaration",a="#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;varying float vFragmentDepth;\n#endif\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a)},37353:(e,t,n)=>{n.d(t,{SPLATFileLoader:()=>K});var r=n(15909),s=n(31612),a=n(65907),i=n(85530),o=n(36803),c=n(79923),l=n(51137),u=n(26877),f=n(95616),h=n(79526),d=n(21644),_=n(56552),p=n(30492),x=n(30388),v=(n(18335),n(60924),n(23758),n(55597),n(80467));class m extends h.M{constructor(){super(),this.FOG=!1,this.THIN_INSTANCES=!0,this.LOGARITHMICDEPTH=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.SH_DEGREE=0,this.COMPENSATION=!1,this.rebuild()}}class g extends d.E{constructor(e,t){super(e,t),this.kernelSize=g.KernelSize,this._compensation=g.Compensation,this._isDirty=!1,this.backFaceCulling=!1}set compensation(e){this._isDirty=this._isDirty!=e,this._compensation=e}get compensation(){return this._compensation}get hasRenderTargetTextures(){return!1}needAlphaTesting(){return!1}needAlphaBlending(){return!0}isReadyForSubMesh(e,t){const r=!0,s=t._drawWrapper;let a=t.materialDefines;if(a&&this._isDirty&&a.markAsUnprocessed(),s.effect&&this.isFrozen&&s._wasPreviouslyReady&&s._wasPreviouslyUsingInstances===r)return!0;t.materialDefines||(a=t.materialDefines=new m);const i=this.getScene();if(this._isReadyForSubMesh(t))return!0;const o=i.getEngine(),c=e;(0,v.fm)(e,i,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,!1,a,void 0,void 0,void 0,this._setVertexOutputInvariant),(0,v.OR)(i,o,this,a,r,null,!0),(0,v.qB)(e,a,!1,!1),(o.version>1||o.isWebGPU)&&(a.SH_DEGREE=c.shDegree);const l=c.material;if(a.COMPENSATION=l&&l.compensation?l.compensation:g.Compensation,a.isDirty){a.markAsProcessed(),i.resetCachedMaterial();const e=[f.R.PositionKind,"splatIndex"];(0,v.ER)(e,a);const r=["world","view","projection","vFogInfos","vFogColor","logarithmicDepthConstant","invViewport","dataTextureSize","focal","eyePosition","kernelSize","viewDirectionFactor"],s=["covariancesATexture","covariancesBTexture","centersTexture","colorsTexture","shTexture0","shTexture1","shTexture2"],c=["Scene","Mesh"];(0,v.Bb)({uniformsNames:r,uniformBuffersNames:c,samplers:s,defines:a}),(0,p.Ll)(r);const l=a.toString(),u=i.getEngine().createEffect("gaussianSplatting",{attributes:e,uniformsNames:r,uniformBuffersNames:c,samplers:s,defines:l,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{},shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{1===this._shaderLanguage?await Promise.all([Promise.resolve().then(n.bind(n,23758)),Promise.resolve().then(n.bind(n,55597))]):await Promise.all([Promise.resolve().then(n.bind(n,18335)),Promise.resolve().then(n.bind(n,60924))])}},o);t.setEffect(u,a,this._materialContext)}return!(!t.effect||!t.effect.isReady())&&(a._renderId=i.getRenderId(),s._wasPreviouslyReady=!0,s._wasPreviouslyUsingInstances=r,this._isDirty=!1,!0)}static BindEffect(e,t,n){const r=n.getEngine(),s=n.activeCamera,a=r.getRenderWidth(),i=r.getRenderHeight(),o=e,c=o.material,l=s?.rigParent?.rigCameras.length||1;t.setFloat2("invViewport",1/(a/l),1/i);let u=1e3;if(s){const e=s.getProjectionMatrix().m[5];u=s.fovMode==x.i.FOVMODE_VERTICAL_FIXED?i*e/2:a*e/2}if(t.setFloat2("focal",u,u),t.setVector3("viewDirectionFactor",o.viewDirectionFactor),t.setFloat("kernelSize",c&&c.kernelSize?c.kernelSize:g.KernelSize),n.bindEyePosition(t,"eyePosition",!0),o.covariancesATexture){const e=o.covariancesATexture.getSize();if(t.setFloat2("dataTextureSize",e.width,e.height),t.setTexture("covariancesATexture",o.covariancesATexture),t.setTexture("covariancesBTexture",o.covariancesBTexture),t.setTexture("centersTexture",o.centersTexture),t.setTexture("colorsTexture",o.colorsTexture),o.shTextures)for(let e=0;e<o.shTextures?.length;e++)t.setTexture(`shTexture${e}`,o.shTextures[e])}}bindForSubMesh(e,t,n){const r=this.getScene(),s=n.materialDefines;if(!s)return;const a=n.effect;if(!a)return;this._activeEffect=a,t.getMeshUniformBuffer().bindToEffect(a,"Mesh"),t.transferToEffect(e);this._mustRebind(r,a,n,t.visibility)?(this.bindView(a),this.bindViewProjection(a),g.BindEffect(t,this._activeEffect,r),(0,p.ij)(a,this,r)):r.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0),(0,v.Yy)(r,t,a),this.useLogarithmicDepth&&(0,v.DL)(s,a,r),this._afterBind(t,this._activeEffect,n)}clone(e){return u.p.Clone(()=>new g(e,this.getScene()),this)}serialize(){const e=super.serialize();return e.customType="BABYLON.GaussianSplattingMaterial",e}getClassName(){return"GaussianSplattingMaterial"}static Parse(e,t,n){return u.p.Parse(()=>new g(e.name,t),e,t,n)}}g.KernelSize=.3,g.Compensation=!1,(0,_.Y5)("BABYLON.GaussianSplattingMaterial",g);var S=n(96041),y=n(998),I=(n(90203),n(42683)),C=n(84867);const w=C.HighestCommonFactor,P={...C,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:w};var A=n(80163),E=n(6315);const D=(e,t)=>{const n=(1<<t)-1;return(e&n)/n},T=(e,t)=>{t.x=D(e>>>21,11),t.y=D(e>>>11,10),t.z=D(e,11)},b=(e,t)=>{t[0]=255*D(e>>>24,8),t[1]=255*D(e>>>16,8),t[2]=255*D(e>>>8,8),t[3]=255*D(e,8)},M=(e,t)=>{const n=1/(.5*Math.sqrt(2)),r=(D(e>>>20,10)-.5)*n,s=(D(e>>>10,10)-.5)*n,a=(D(e,10)-.5)*n,i=Math.sqrt(1-(r*r+s*s+a*a));switch(e>>>30){case 0:t.set(i,r,s,a);break;case 1:t.set(r,i,s,a);break;case 2:t.set(r,s,i,a);break;case 3:t.set(r,s,a,i)}};var B,L;!function(e){e[e.FLOAT=0]="FLOAT",e[e.INT=1]="INT",e[e.UINT=2]="UINT",e[e.DOUBLE=3]="DOUBLE",e[e.UCHAR=4]="UCHAR",e[e.UNDEFINED=5]="UNDEFINED"}(B||(B={})),function(e){e[e.MIN_X=0]="MIN_X",e[e.MIN_Y=1]="MIN_Y",e[e.MIN_Z=2]="MIN_Z",e[e.MAX_X=3]="MAX_X",e[e.MAX_Y=4]="MAX_Y",e[e.MAX_Z=5]="MAX_Z",e[e.MIN_SCALE_X=6]="MIN_SCALE_X",e[e.MIN_SCALE_Y=7]="MIN_SCALE_Y",e[e.MIN_SCALE_Z=8]="MIN_SCALE_Z",e[e.MAX_SCALE_X=9]="MAX_SCALE_X",e[e.MAX_SCALE_Y=10]="MAX_SCALE_Y",e[e.MAX_SCALE_Z=11]="MAX_SCALE_Z",e[e.PACKED_POSITION=12]="PACKED_POSITION",e[e.PACKED_ROTATION=13]="PACKED_ROTATION",e[e.PACKED_SCALE=14]="PACKED_SCALE",e[e.PACKED_COLOR=15]="PACKED_COLOR",e[e.X=16]="X",e[e.Y=17]="Y",e[e.Z=18]="Z",e[e.SCALE_0=19]="SCALE_0",e[e.SCALE_1=20]="SCALE_1",e[e.SCALE_2=21]="SCALE_2",e[e.DIFFUSE_RED=22]="DIFFUSE_RED",e[e.DIFFUSE_GREEN=23]="DIFFUSE_GREEN",e[e.DIFFUSE_BLUE=24]="DIFFUSE_BLUE",e[e.OPACITY=25]="OPACITY",e[e.F_DC_0=26]="F_DC_0",e[e.F_DC_1=27]="F_DC_1",e[e.F_DC_2=28]="F_DC_2",e[e.F_DC_3=29]="F_DC_3",e[e.ROT_0=30]="ROT_0",e[e.ROT_1=31]="ROT_1",e[e.ROT_2=32]="ROT_2",e[e.ROT_3=33]="ROT_3",e[e.MIN_COLOR_R=34]="MIN_COLOR_R",e[e.MIN_COLOR_G=35]="MIN_COLOR_G",e[e.MIN_COLOR_B=36]="MIN_COLOR_B",e[e.MAX_COLOR_R=37]="MAX_COLOR_R",e[e.MAX_COLOR_G=38]="MAX_COLOR_G",e[e.MAX_COLOR_B=39]="MAX_COLOR_B",e[e.SH_0=40]="SH_0",e[e.SH_1=41]="SH_1",e[e.SH_2=42]="SH_2",e[e.SH_3=43]="SH_3",e[e.SH_4=44]="SH_4",e[e.SH_5=45]="SH_5",e[e.SH_6=46]="SH_6",e[e.SH_7=47]="SH_7",e[e.SH_8=48]="SH_8",e[e.SH_9=49]="SH_9",e[e.SH_10=50]="SH_10",e[e.SH_11=51]="SH_11",e[e.SH_12=52]="SH_12",e[e.SH_13=53]="SH_13",e[e.SH_14=54]="SH_14",e[e.SH_15=55]="SH_15",e[e.SH_16=56]="SH_16",e[e.SH_17=57]="SH_17",e[e.SH_18=58]="SH_18",e[e.SH_19=59]="SH_19",e[e.SH_20=60]="SH_20",e[e.SH_21=61]="SH_21",e[e.SH_22=62]="SH_22",e[e.SH_23=63]="SH_23",e[e.SH_24=64]="SH_24",e[e.SH_25=65]="SH_25",e[e.SH_26=66]="SH_26",e[e.SH_27=67]="SH_27",e[e.SH_28=68]="SH_28",e[e.SH_29=69]="SH_29",e[e.SH_30=70]="SH_30",e[e.SH_31=71]="SH_31",e[e.SH_32=72]="SH_32",e[e.SH_33=73]="SH_33",e[e.SH_34=74]="SH_34",e[e.SH_35=75]="SH_35",e[e.SH_36=76]="SH_36",e[e.SH_37=77]="SH_37",e[e.SH_38=78]="SH_38",e[e.SH_39=79]="SH_39",e[e.SH_40=80]="SH_40",e[e.SH_41=81]="SH_41",e[e.SH_42=82]="SH_42",e[e.SH_43=83]="SH_43",e[e.SH_44=84]="SH_44",e[e.UNDEFINED=85]="UNDEFINED"}(L||(L={}));class R extends i.e{get viewDirectionFactor(){return this._viewDirectionFactor}get shDegree(){return this._shDegree}get splatCount(){return this._splatIndex?.length}get splatsData(){return this._splatsData}get covariancesATexture(){return this._covariancesATexture}get covariancesBTexture(){return this._covariancesBTexture}get centersTexture(){return this._centersTexture}get colorsTexture(){return this._colorsTexture}get shTextures(){return this._shTextures}get kernelSize(){return this._material instanceof g?this._material.kernelSize:0}get compensation(){return this._material instanceof g&&this._material.compensation}set material(e){this._material=e,this._material.backFaceCulling=!0,this._material.cullBackFaces=!1,e.resetDrawCache()}get material(){return this._material}constructor(e,t=null,n=null,r=!1){super(e,n),this._vertexCount=0,this._worker=null,this._frameIdLastUpdate=-1,this._modelViewMatrix=c.uq.Identity(),this._canPostToWorker=!0,this._readyToDisplay=!1,this._covariancesATexture=null,this._covariancesBTexture=null,this._centersTexture=null,this._colorsTexture=null,this._splatPositions=null,this._splatIndex=null,this._shTextures=null,this._splatsData=null,this._sh=null,this._keepInRam=!1,this._delayedTextureUpdate=null,this._oldDirection=new c.Pq,this._useRGBACovariants=!1,this._material=null,this._tmpCovariances=[0,0,0,0,0,0],this._sortIsDirty=!1,this._shDegree=0,this._viewDirectionFactor=new c.Pq(1,1,-1);const s=new o.P;s.positions=[-2,-2,0,2,-2,0,2,2,0,-2,2,0],s.indices=[0,1,2,0,2,3],s.applyToMesh(this),this.subMeshes=[],new a.K(0,0,4,0,6,this),this.setEnabled(!1),this._useRGBACovariants=!this.getEngine().isWebGPU&&1===this.getEngine().version,this._keepInRam=r,t&&this.loadFileAsync(t),this._material=new g(this.name+"_material",this._scene)}getClassName(){return"GaussianSplattingMesh"}getTotalVertices(){return this._vertexCount}isReady(e=!1){return!!super.isReady(e,!0)&&(!!this._readyToDisplay||(this._postToWorker(!0),!1))}_postToWorker(e=!1){const t=this.getScene().getFrameId();if((e||t!==this._frameIdLastUpdate)&&this._worker&&this._scene.activeCamera&&this._canPostToWorker){const n=this._scene.activeCamera.getViewMatrix();this.getWorldMatrix().multiplyToRef(n,this._modelViewMatrix),n.invertToRef(c.AA.Matrix[0]),this.getWorldMatrix().multiplyToRef(c.AA.Matrix[0],c.AA.Matrix[1]),c.Pq.TransformNormalToRef(c.Pq.Forward(this._scene.useRightHandedSystem),c.AA.Matrix[1],c.AA.Vector3[2]),c.AA.Vector3[2].normalize();const r=c.Pq.Dot(c.AA.Vector3[2],this._oldDirection);(e||Math.abs(r-1)>=.01)&&(this._oldDirection.copyFrom(c.AA.Vector3[2]),this._frameIdLastUpdate=t,this._canPostToWorker=!1,this._worker.postMessage({view:this._modelViewMatrix.m,depthMix:this._depthMix,useRightHandedSystem:this._scene.useRightHandedSystem},[this._depthMix.buffer]))}}render(e,t,n){return this._postToWorker(),super.render(e,t,n)}static _TypeNameToEnum(e){switch(e){case"float":return 0;case"int":return 1;case"uint":return 2;case"double":return 3;case"uchar":return 4}return 5}static _ValueNameToEnum(e){switch(e){case"min_x":return 0;case"min_y":return 1;case"min_z":return 2;case"max_x":return 3;case"max_y":return 4;case"max_z":return 5;case"min_scale_x":return 6;case"min_scale_y":return 7;case"min_scale_z":return 8;case"max_scale_x":return 9;case"max_scale_y":return 10;case"max_scale_z":return 11;case"packed_position":return 12;case"packed_rotation":return 13;case"packed_scale":return 14;case"packed_color":return 15;case"x":return 16;case"y":return 17;case"z":return 18;case"scale_0":return 19;case"scale_1":return 20;case"scale_2":return 21;case"diffuse_red":case"red":return 22;case"diffuse_green":case"green":return 23;case"diffuse_blue":case"blue":return 24;case"f_dc_0":return 26;case"f_dc_1":return 27;case"f_dc_2":return 28;case"f_dc_3":return 29;case"opacity":return 25;case"rot_0":return 30;case"rot_1":return 31;case"rot_2":return 32;case"rot_3":return 33;case"min_r":return 34;case"min_g":return 35;case"min_b":return 36;case"max_r":return 37;case"max_g":return 38;case"max_b":return 39;case"f_rest_0":return 40;case"f_rest_1":return 41;case"f_rest_2":return 42;case"f_rest_3":return 43;case"f_rest_4":return 44;case"f_rest_5":return 45;case"f_rest_6":return 46;case"f_rest_7":return 47;case"f_rest_8":return 48;case"f_rest_9":return 49;case"f_rest_10":return 50;case"f_rest_11":return 51;case"f_rest_12":return 52;case"f_rest_13":return 53;case"f_rest_14":return 54;case"f_rest_15":return 55;case"f_rest_16":return 56;case"f_rest_17":return 57;case"f_rest_18":return 58;case"f_rest_19":return 59;case"f_rest_20":return 60;case"f_rest_21":return 61;case"f_rest_22":return 62;case"f_rest_23":return 63;case"f_rest_24":return 64;case"f_rest_25":return 65;case"f_rest_26":return 66;case"f_rest_27":return 67;case"f_rest_28":return 68;case"f_rest_29":return 69;case"f_rest_30":return 70;case"f_rest_31":return 71;case"f_rest_32":return 72;case"f_rest_33":return 73;case"f_rest_34":return 74;case"f_rest_35":return 75;case"f_rest_36":return 76;case"f_rest_37":return 77;case"f_rest_38":return 78;case"f_rest_39":return 79;case"f_rest_40":return 80;case"f_rest_41":return 81;case"f_rest_42":return 82;case"f_rest_43":return 83;case"f_rest_44":return 84}return 85}static ParseHeader(e){const t=new Uint8Array(e),n=(new TextDecoder).decode(t.slice(0,10240)),r="end_header\n",s=n.indexOf(r);if(s<0||!n)return null;const a=parseInt(/element vertex (\d+)\n/.exec(n)[1]),i=/element chunk (\d+)\n/.exec(n);let o=0;i&&(o=parseInt(i[1]));let c=0,u=0;const f={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let h;!function(e){e[e.Vertex=0]="Vertex",e[e.Chunk=1]="Chunk",e[e.SH=2]="SH"}(h||(h={}));let d=1;const _=[],p=[],x=n.slice(0,s).split("\n");let v=0;for(const e of x)if(e.startsWith("property ")){const[,t,n]=e.split(" "),r=R._ValueNameToEnum(n);r>=84?v=3:r>=64?v=2:r>=48&&(v=1);const s=R._TypeNameToEnum(t);1==d?(p.push({value:r,type:s,offset:u}),u+=f[t]):0==d?(_.push({value:r,type:s,offset:c}),c+=f[t]):2==d&&_.push({value:r,type:s,offset:c}),f[t]||l.V.Warn(`Unsupported property type: ${t}.`)}else if(e.startsWith("element ")){const[,t]=e.split(" ");"chunk"==t?d=1:"vertex"==t?d=0:"sh"==t&&(d=2)}const m=new DataView(e,s+11),g=new ArrayBuffer(R._RowOutputLength*a);let S=null,y=0;if(v){y=3*((v+1)*(v+1)-1),S=new ArrayBuffer(y*a)}return{vertexCount:a,chunkCount:o,rowVertexLength:c,rowChunkLength:u,vertexProperties:_,chunkProperties:p,dataView:m,buffer:g,shDegree:v,shCoefficientCount:y,shBuffer:S}}static _GetCompressedChunks(e,t){if(!e.chunkCount)return null;const n=e.dataView,r=new Array(e.chunkCount);for(let s=0;s<e.chunkCount;s++){const a={min:new c.Pq,max:new c.Pq,minScale:new c.Pq,maxScale:new c.Pq,minColor:new c.Pq(0,0,0),maxColor:new c.Pq(1,1,1)};r[s]=a;for(let r=0;r<e.chunkProperties.length;r++){const s=e.chunkProperties[r];let i;if(0===s.type)switch(i=n.getFloat32(s.offset+t.value,!0),s.value){case 0:a.min.x=i;break;case 1:a.min.y=i;break;case 2:a.min.z=i;break;case 3:a.max.x=i;break;case 4:a.max.y=i;break;case 5:a.max.z=i;break;case 6:a.minScale.x=i;break;case 7:a.minScale.y=i;break;case 8:a.minScale.z=i;break;case 9:a.maxScale.x=i;break;case 10:a.maxScale.y=i;break;case 11:a.maxScale.z=i;break;case 34:a.minColor.x=i;break;case 35:a.minColor.y=i;break;case 36:a.minColor.z=i;break;case 37:a.maxColor.x=i;break;case 38:a.maxColor.y=i;break;case 39:a.maxColor.z=i}}t.value+=e.rowChunkLength}return r}static _GetSplat(e,t,n,r){const s=c.AA.Quaternion[0],a=c.AA.Vector3[0],i=R._RowOutputLength,o=e.buffer,l=e.dataView,u=new Float32Array(o,t*i,3),f=new Float32Array(o,t*i+12,3),h=new Uint8ClampedArray(o,t*i+24,4),d=new Uint8ClampedArray(o,t*i+28,4);let _=null;e.shBuffer&&(_=new Uint8ClampedArray(e.shBuffer,t*e.shCoefficientCount,e.shCoefficientCount));const p=t>>8;let x=255,v=0,m=0,g=0;const S=[];for(let i=0;i<e.vertexProperties.length;i++){const o=e.vertexProperties[i];let c;switch(o.type){case 0:c=l.getFloat32(r.value+o.offset,!0);break;case 1:c=l.getInt32(r.value+o.offset,!0);break;case 2:c=l.getUint32(r.value+o.offset,!0);break;case 3:c=l.getFloat64(r.value+o.offset,!0);break;case 4:c=l.getUint8(r.value+o.offset);break;default:continue}switch(o.value){case 12:{const e=n[p];T(c,a),u[0]=P.Lerp(e.min.x,e.max.x,a.x),u[1]=P.Lerp(e.min.y,e.max.y,a.y),u[2]=P.Lerp(e.min.z,e.max.z,a.z)}break;case 13:M(c,s),x=s.x,v=s.y,m=s.z,g=s.w;break;case 14:{const e=n[p];T(c,a),f[0]=Math.exp(P.Lerp(e.minScale.x,e.maxScale.x,a.x)),f[1]=Math.exp(P.Lerp(e.minScale.y,e.maxScale.y,a.y)),f[2]=Math.exp(P.Lerp(e.minScale.z,e.maxScale.z,a.z))}break;case 15:{const e=n[p];b(c,h),h[0]=255*P.Lerp(e.minColor.x,e.maxColor.x,h[0]/255),h[1]=255*P.Lerp(e.minColor.y,e.maxColor.y,h[1]/255),h[2]=255*P.Lerp(e.minColor.z,e.maxColor.z,h[2]/255)}break;case 16:u[0]=c;break;case 17:u[1]=c;break;case 18:u[2]=c;break;case 19:f[0]=Math.exp(c);break;case 20:f[1]=Math.exp(c);break;case 21:f[2]=Math.exp(c);break;case 22:h[0]=c;break;case 23:h[1]=c;break;case 24:h[2]=c;break;case 26:h[0]=255*(.5+R._SH_C0*c);break;case 27:h[1]=255*(.5+R._SH_C0*c);break;case 28:h[2]=255*(.5+R._SH_C0*c);break;case 29:h[3]=255*(.5+R._SH_C0*c);break;case 25:h[3]=1/(1+Math.exp(-c))*255;break;case 30:x=c;break;case 31:v=c;break;case 32:m=c;break;case 33:g=c}if(_&&o.value>=40&&o.value<=84){const n=o.value-40;if(4==o.type&&e.chunkCount){const r=l.getUint8(e.rowChunkLength*e.chunkCount+e.vertexCount*e.rowVertexLength+t*e.shCoefficientCount+n);S[n]=127.5*(r*(8/255)-4)+127.5}else{const e=P.Clamp(127.5*c+127.5,0,255);S[n]=e}}}if(_){const t=1==e.shDegree?3:2==e.shDegree?8:15;for(let e=0;e<t;e++)_[3*e+0]=S[e],_[3*e+1]=S[e+t],_[3*e+2]=S[e+2*t]}s.set(v,m,g,x),s.normalize(),d[0]=127.5*s.w+127.5,d[1]=127.5*s.x+127.5,d[2]=127.5*s.y+127.5,d[3]=127.5*s.z+127.5,r.value+=e.rowVertexLength}static*ConvertPLYWithSHToSplat(e,t=!1){const n=R.ParseHeader(e);if(!n)return{buffer:e};const r={value:0},s=R._GetCompressedChunks(n,r);for(let e=0;e<n.vertexCount;e++)R._GetSplat(n,e,s,r),e%R._PlyConversionBatchSize===0&&t&&(yield);let a=null;if(n.shDegree&&n.shBuffer){const e=Math.ceil(n.shCoefficientCount/16);let t=0;const r=new Uint8Array(n.shBuffer);a=[];const s=n.vertexCount,i=E.q.LastCreatedEngine;if(i){const o=i.getCaps().maxTextureSize,c=Math.ceil(s/o);for(let t=0;t<e;t++){const e=new Uint8Array(c*o*4*4);a.push(e)}for(let e=0;e<s;e++)for(let s=0;s<n.shCoefficientCount;s++){const n=r[t++];a[Math.floor(s/16)][s%16+16*e]=n}}}return{buffer:n.buffer,sh:a}}static*ConvertPLYToSplat(e,t=!1){const n=R.ParseHeader(e);if(!n)return e;const r={value:0},s=R._GetCompressedChunks(n,r);for(let e=0;e<n.vertexCount;e++)R._GetSplat(n,e,s,r),e%R._PlyConversionBatchSize===0&&t&&(yield);return n.buffer}static async ConvertPLYToSplatAsync(e){return await(0,A.kj)(R.ConvertPLYToSplat(e,!0),(0,A.VP)())}static async ConvertPLYWithSHToSplatAsync(e){return await(0,A.kj)(R.ConvertPLYWithSHToSplat(e,!0),(0,A.VP)())}async loadDataAsync(e){return await this.updateDataAsync(e)}async loadFileAsync(e){const t=await y.S0.LoadFileAsync(e,!0),n=await R.ConvertPLYWithSHToSplatAsync(t);await this.updateDataAsync(n.buffer,n.sh)}dispose(e){if(this._covariancesATexture?.dispose(),this._covariancesBTexture?.dispose(),this._centersTexture?.dispose(),this._colorsTexture?.dispose(),this._shTextures)for(const e of this._shTextures)e.dispose();this._covariancesATexture=null,this._covariancesBTexture=null,this._centersTexture=null,this._colorsTexture=null,this._shTextures=null,this._worker?.terminate(),this._worker=null,super.dispose(e,!0)}_copyTextures(e){if(this._covariancesATexture=e.covariancesATexture?.clone(),this._covariancesBTexture=e.covariancesBTexture?.clone(),this._centersTexture=e.centersTexture?.clone(),this._colorsTexture=e.colorsTexture?.clone(),e._shTextures){this._shTextures=[];for(const e of this._shTextures)this._shTextures?.push(e.clone())}}clone(e=""){const t=new R(e,void 0,this.getScene());t._copySource(this),t.makeGeometryUnique(),t._vertexCount=this._vertexCount,t._copyTextures(this),t._modelViewMatrix=c.uq.Identity(),t._splatPositions=this._splatPositions,t._readyToDisplay=!1,t._instanciateWorker();const n=this.getBoundingInfo();return t.getBoundingInfo().reConstruct(n.minimum,n.maximum,this.getWorldMatrix()),t.forcedInstanceCount=t._vertexCount,t.setEnabled(!0),t}_makeSplat(e,t,n,r,s,a,i,o){const l=c.AA.Matrix[0],u=c.AA.Matrix[1],f=c.AA.Quaternion[0],h=this._useRGBACovariants?4:2,d=t[8*e+0],_=-t[8*e+1],p=t[8*e+2];this._splatPositions[4*e+0]=d,this._splatPositions[4*e+1]=_,this._splatPositions[4*e+2]=p,i.minimizeInPlaceFromFloats(d,_,p),o.maximizeInPlaceFromFloats(d,_,p),f.set((n[32*e+28+1]-127.5)/127.5,(n[32*e+28+2]-127.5)/127.5,(n[32*e+28+3]-127.5)/127.5,-(n[32*e+28+0]-127.5)/127.5),f.normalize(),f.toRotationMatrix(l),c.uq.ScalingToRef(2*t[8*e+3+0],2*t[8*e+3+1],2*t[8*e+3+2],u);const x=l.multiplyToRef(u,c.AA.Matrix[0]).m,v=this._tmpCovariances;v[0]=x[0]*x[0]+x[1]*x[1]+x[2]*x[2],v[1]=x[0]*x[4]+x[1]*x[5]+x[2]*x[6],v[2]=x[0]*x[8]+x[1]*x[9]+x[2]*x[10],v[3]=x[4]*x[4]+x[5]*x[5]+x[6]*x[6],v[4]=x[4]*x[8]+x[5]*x[9]+x[6]*x[10],v[5]=x[8]*x[8]+x[9]*x[9]+x[10]*x[10];let m=-1e4;for(let e=0;e<6;e++)m=Math.max(m,Math.abs(v[e]));this._splatPositions[4*e+3]=m;const g=m;r[4*e+0]=(0,I.LZ)(v[0]/g),r[4*e+1]=(0,I.LZ)(v[1]/g),r[4*e+2]=(0,I.LZ)(v[2]/g),r[4*e+3]=(0,I.LZ)(v[3]/g),s[e*h+0]=(0,I.LZ)(v[4]/g),s[e*h+1]=(0,I.LZ)(v[5]/g),a[4*e+0]=n[32*e+24+0],a[4*e+1]=n[32*e+24+1],a[4*e+2]=n[32*e+24+2],a[4*e+3]=n[32*e+24+3]}_updateTextures(e,t,n,r){const s=this._getTextureSize(this._vertexCount),a=(e,t,n,r)=>new S.I(e,t,n,r,this._scene,!1,!1,2,1),i=(e,t,n,r)=>new S.I(e,t,n,r,this._scene,!1,!1,2,0),o=(e,t,n,r)=>new S.I(e,t,n,r,this._scene,!1,!1,1,7),c=(e,t,n,r)=>new S.I(e,t,n,r,this._scene,!1,!1,2,2);if(this._covariancesATexture){this._delayedTextureUpdate={covA:e,covB:t,colors:n,centers:this._splatPositions,sh:r};const s=Float32Array.from(this._splatPositions),a=this._vertexCount;this._worker.postMessage({positions:s,vertexCount:a},[s.buffer]),this._postToWorker(!0)}else{if(this._covariancesATexture=c(e,s.x,s.y,5),this._covariancesBTexture=c(t,s.x,s.y,this._useRGBACovariants?5:7),this._centersTexture=a(this._splatPositions,s.x,s.y,5),this._colorsTexture=i(n,s.x,s.y,5),r){this._shTextures=[];for(const e of r){const t=o(new Uint32Array(e.buffer),s.x,s.y,11);t.wrapU=0,t.wrapV=0,this._shTextures.push(t)}}this._instanciateWorker()}}*_updateData(e,t,n){this._covariancesATexture||(this._readyToDisplay=!1);const r=new Uint8Array(e),s=new Float32Array(r.buffer);this._keepInRam&&(this._splatsData=e,n&&(this._sh=n));const a=r.length/R._RowOutputLength;a!=this._vertexCount&&this._updateSplatIndexBuffer(a),this._vertexCount=a,this._shDegree=n?n.length:0;const i=this._getTextureSize(a),o=i.x*i.y,l=R.ProgressiveUpdateAmount??i.y,u=i.x*l;this._splatPositions=new Float32Array(4*o);const f=new Uint16Array(4*o),h=new Uint16Array((this._useRGBACovariants?4:2)*o),d=new Uint8Array(4*o),_=new c.Pq(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),p=new c.Pq(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);if(R.ProgressiveUpdateAmount){this._updateTextures(f,h,d,n),this.setEnabled(!0);const e=Math.ceil(i.y/l);for(let n=0;n<e;n++){const e=n*l,a=e*i.x;for(let e=0;e<u;e++)this._makeSplat(a+e,s,r,f,h,d,_,p);this._updateSubTextures(this._splatPositions,f,h,d,e,Math.min(l,i.y-e)),this.getBoundingInfo().reConstruct(_,p,this.getWorldMatrix()),t&&(yield)}const a=Float32Array.from(this._splatPositions),o=this._vertexCount;this._worker.postMessage({positions:a,vertexCount:o},[a.buffer]),this._sortIsDirty=!0}else{for(let e=0;e<a;e++)this._makeSplat(e,s,r,f,h,d,_,p),t&&e%R._SplatBatchSize===0&&(yield);this._updateTextures(f,h,d,n),this.getBoundingInfo().reConstruct(_,p,this.getWorldMatrix()),this.setEnabled(!0)}this._postToWorker(!0)}async updateDataAsync(e,t){return await(0,A.kj)(this._updateData(e,!0,t),(0,A.VP)())}updateData(e,t){(0,A.V1)(this._updateData(e,!1,t))}refreshBoundingInfo(){return this.thinInstanceRefreshBoundingInfo(!1),this}_updateSplatIndexBuffer(e){(!this._splatIndex||e>this._splatIndex.length)&&(this._splatIndex=new Float32Array(e),this.thinInstanceSetBuffer("splatIndex",this._splatIndex,1,!1)),this.forcedInstanceCount=e}_updateSubTextures(e,t,n,r,s,a,i){const o=(e,t,n,r,s)=>{this.getEngine().updateTextureData(e.getInternalTexture(),t,0,r,n,s,0,0,!1)},c=this._getTextureSize(this._vertexCount),l=this._useRGBACovariants?4:2,u=s*c.x,f=a*c.x,h=new Uint16Array(t.buffer,4*u*Uint16Array.BYTES_PER_ELEMENT,4*f),d=new Uint16Array(n.buffer,u*l*Uint16Array.BYTES_PER_ELEMENT,f*l),_=new Uint8Array(r.buffer,4*u,4*f),p=new Float32Array(e.buffer,4*u*Float32Array.BYTES_PER_ELEMENT,4*f);if(o(this._covariancesATexture,h,c.x,s,a),o(this._covariancesBTexture,d,c.x,s,a),o(this._centersTexture,p,c.x,s,a),o(this._colorsTexture,_,c.x,s,a),i)for(let e=0;e<i.length;e++){const t=4,n=new Uint8Array(this._sh[e].buffer,u*t,f*t);o(this._shTextures[e],n,c.x,s,a)}}_instanciateWorker(){if(!this._vertexCount)return;this._updateSplatIndexBuffer(this._vertexCount),this._worker?.terminate(),this._worker=new Worker(URL.createObjectURL(new Blob(["(",R._CreateWorker.toString(),")(self)"],{type:"application/javascript"}))),this._depthMix=new BigInt64Array(this._vertexCount);const e=Float32Array.from(this._splatPositions),t=this._vertexCount;this._worker.postMessage({positions:e,vertexCount:t},[e.buffer]),this._worker.onmessage=e=>{this._depthMix=e.data.depthMix;const n=new Uint32Array(e.data.depthMix.buffer);if(this._splatIndex)for(let e=0;e<this._vertexCount;e++)this._splatIndex[e]=n[2*e];if(this._delayedTextureUpdate){const e=this._getTextureSize(t);this._updateSubTextures(this._delayedTextureUpdate.centers,this._delayedTextureUpdate.covA,this._delayedTextureUpdate.covB,this._delayedTextureUpdate.colors,0,e.y,this._delayedTextureUpdate.sh),this._delayedTextureUpdate=null}this.thinInstanceBufferUpdated("splatIndex"),this._canPostToWorker=!0,this._readyToDisplay=!0,this._sortIsDirty&&(this._postToWorker(!0),this._sortIsDirty=!1)}}_getTextureSize(e){const t=this._scene.getEngine(),n=t.getCaps().maxTextureSize;let r=1;if(1!==t.version||t.isWebGPU)r=Math.ceil(e/n);else for(;n*r<e;)r*=2;return r>n&&(l.V.Error("GaussianSplatting texture size: ("+n+", "+r+"), maxTextureSize: "+n),r=n),new c.I9(n,r)}}R._RowOutputLength=32,R._SH_C0=.28209479177387814,R._SplatBatchSize=327680,R._PlyConversionBatchSize=32768,R.ProgressiveUpdateAmount=0,R._CreateWorker=function(e){let t,n,r,s,a=0;e.onmessage=i=>{if(i.data.positions)t=i.data.positions,a=i.data.vertexCount;else{const o=i.data.view;if(!t||!o)throw new Error("positions or view is not defined!");n=i.data.depthMix,r=new Uint32Array(n.buffer),s=new Float32Array(n.buffer);for(let e=0;e<a;e++)r[2*e]=e;let c=-1;i.data.useRightHandedSystem&&(c=1);for(let e=0;e<a;e++)s[2*e+1]=1e4+(o[2]*t[4*e+0]+o[6]*t[4*e+1]+o[10]*t[4*e+2])*c;n.sort(),e.postMessage({depthMix:n},[n.buffer])}}};var z=n(97762),F=n(62956);class V{constructor(e,t,n,r,s){this.idx=0,this.color=new F.ov(1,1,1,1),this.position=F.Pq.Zero(),this.rotation=F.Pq.Zero(),this.uv=new F.I9(0,0),this.velocity=F.Pq.Zero(),this.pivot=F.Pq.Zero(),this.translateFromPivot=!1,this._pos=0,this._ind=0,this.groupId=0,this.idxInGroup=0,this._stillInvisible=!1,this._rotationMatrix=[1,0,0,0,1,0,0,0,1],this.parentId=null,this._globalPosition=F.Pq.Zero(),this.idx=e,this._group=t,this.groupId=n,this.idxInGroup=r,this._pcs=s}get size(){return this.size}set size(e){this.size=e}get quaternion(){return this.rotationQuaternion}set quaternion(e){this.rotationQuaternion=e}intersectsMesh(e,t){if(!e.hasBoundingInfo)return!1;if(!this._pcs.mesh)throw new Error("Point Cloud System doesnt contain the Mesh");if(t)return e.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));const n=e.getBoundingInfo().boundingBox,r=n.maximumWorld.x,s=n.minimumWorld.x,a=n.maximumWorld.y,i=n.minimumWorld.y,o=n.maximumWorld.z,c=n.minimumWorld.z,l=this.position.x+this._pcs.mesh.position.x,u=this.position.y+this._pcs.mesh.position.y,f=this.position.z+this._pcs.mesh.position.z;return s<=l&&l<=r&&i<=u&&u<=a&&c<=f&&f<=o}getRotationMatrix(e){let t;if(this.rotationQuaternion)t=this.rotationQuaternion;else{t=F.AA.Quaternion[0];const e=this.rotation;F.PT.RotationYawPitchRollToRef(e.y,e.x,e.z,t)}t.toRotationMatrix(e)}}class H{get groupID(){return this.groupId}set groupID(e){this.groupId=e}constructor(e,t){this.groupId=e,this._positionFunction=t}}var O,G=n(9138),U=n(2093),N=n(82667);!function(e){e[e.Color=2]="Color",e[e.UV=1]="UV",e[e.Random=0]="Random",e[e.Stated=3]="Stated"}(O||(O={}));class k{get positions(){return this._positions32}get colors(){return this._colors32}get uvs(){return this._uvs32}constructor(e,t,n,r){this.particles=new Array,this.nbParticles=0,this.counter=0,this.vars={},this._promises=[],this._positions=new Array,this._indices=new Array,this._normals=new Array,this._colors=new Array,this._uvs=new Array,this._updatable=!0,this._isVisibilityBoxLocked=!1,this._alwaysVisible=!1,this._groups=new Array,this._groupCounter=0,this._computeParticleColor=!0,this._computeParticleTexture=!0,this._computeParticleRotation=!0,this._computeBoundingBox=!1,this._isReady=!1,this.name=e,this._size=t,this._scene=n||E.q.LastCreatedScene,r&&void 0!==r.updatable?this._updatable=r.updatable:this._updatable=!0}async buildMeshAsync(e){return await Promise.all(this._promises),this._isReady=!0,await this._buildMeshAsync(e)}async _buildMeshAsync(e){0===this.nbParticles&&this.addPoints(1),this._positions32=new Float32Array(this._positions),this._uvs32=new Float32Array(this._uvs),this._colors32=new Float32Array(this._colors);const t=new o.P;t.set(this._positions32,f.R.PositionKind),this._uvs32.length>0&&t.set(this._uvs32,f.R.UVKind);let n=0;this._colors32.length>0&&(n=1,t.set(this._colors32,f.R.ColorKind));const r=new i.e(this.name,this._scene);t.applyToMesh(r,this._updatable),this.mesh=r,this._positions=null,this._uvs=null,this._colors=null,this._updatable||(this.particles.length=0);let s=e;return s||(s=new U.F("point cloud material",this._scene),s.emissiveColor=new F.v9(n,n,n),s.disableLighting=!0,s.pointsCloud=!0,s.pointSize=this._size),r.material=s,r}_addParticle(e,t,n,r){const s=new V(e,t,n,r,this);return this.particles.push(s),s}_randomUnitVector(e){e.position=new c.Pq(Math.random(),Math.random(),Math.random()),e.color=new F.ov(1,1,1,1)}_getColorIndicesForCoord(e,t,n,r){const s=e._groupImageData,a=n*(4*r)+4*t,i=[a,a+1,a+2,a+3],o=i[1],c=i[2],l=i[3],u=s[i[0]],f=s[o],h=s[c],d=s[l];return new F.ov(u/255,f/255,h/255,d)}_setPointsColorOrUV(e,t,n,r,s,a,i,o){o=o??0,n&&e.updateFacetData();const l=2*e.getBoundingInfo().boundingSphere.radius;let u=e.getVerticesData(f.R.PositionKind);const h=e.getIndices(),d=e.getVerticesData(f.R.UVKind+(o?o+1:"")),_=e.getVerticesData(f.R.ColorKind),p=c.Pq.Zero();e.computeWorldMatrix();const x=e.getWorldMatrix();if(!x.isIdentity()){u=u.slice(0);for(let e=0;e<u.length/3;e++)c.Pq.TransformCoordinatesFromFloatsToRef(u[3*e],u[3*e+1],u[3*e+2],x,p),u[3*e]=p.x,u[3*e+1]=p.y,u[3*e+2]=p.z}let v=0,m=0,g=0,S=0,y=0,I=0,w=0,P=0,A=0,E=0,D=0,T=0,b=0;const M=c.Pq.Zero(),B=c.Pq.Zero(),L=c.Pq.Zero(),R=c.Pq.Zero(),z=c.Pq.Zero();let V=0,H=0,O=0,U=0,N=0,k=0;const W=c.I9.Zero(),q=c.I9.Zero(),Z=c.I9.Zero(),X=c.I9.Zero(),K=c.I9.Zero();let Y=0,j=0,Q=0,$=0,J=0,ee=0,te=0,ne=0,re=0,se=0,ae=0,ie=0;const oe=c.IU.Zero(),ce=c.IU.Zero(),le=c.IU.Zero(),ue=c.IU.Zero(),fe=c.IU.Zero();let he,de,_e=0,pe=0;i=i||0;let xe=new c.IU(0,0,0,0),ve=c.Pq.Zero(),me=c.Pq.Zero(),ge=c.Pq.Zero(),Se=0,ye=c.Pq.Zero(),Ie=0,Ce=0;const we=new G.Ray(c.Pq.Zero(),new c.Pq(1,0,0));let Pe,Ae=c.Pq.Zero();for(let o=0;o<h.length/3;o++){let f,p,x,G,Ee,De,Te,be;m=h[3*o],g=h[3*o+1],S=h[3*o+2],y=u[3*m],I=u[3*m+1],w=u[3*m+2],P=u[3*g],A=u[3*g+1],E=u[3*g+2],D=u[3*S],T=u[3*S+1],b=u[3*S+2],M.set(y,I,w),B.set(P,A,E),L.set(D,T,b),B.subtractToRef(M,R),L.subtractToRef(B,z),d&&(V=d[2*m],H=d[2*m+1],O=d[2*g],U=d[2*g+1],N=d[2*S],k=d[2*S+1],W.set(V,H),q.set(O,U),Z.set(N,k),q.subtractToRef(W,X),Z.subtractToRef(q,K)),_&&r&&(Y=_[4*m],j=_[4*m+1],Q=_[4*m+2],$=_[4*m+3],J=_[4*g],ee=_[4*g+1],te=_[4*g+2],ne=_[4*g+3],re=_[4*S],se=_[4*S+1],ae=_[4*S+2],ie=_[4*S+3],oe.set(Y,j,Q,$),ce.set(J,ee,te,ne),le.set(re,se,ae,ie),ce.subtractToRef(oe,ue),le.subtractToRef(ce,fe));const Me=new F.v9(0,0,0),Be=new F.v9(0,0,0);let Le,Re;for(let u=0;u<t._groupDensity[o];u++)v=this.particles.length,this._addParticle(v,t,this._groupCounter,o+u),Re=this.particles[v],_e=Math.sqrt((0,C.RandomRange)(0,1)),pe=(0,C.RandomRange)(0,1),he=M.add(R.scale(_e)).add(z.scale(_e*pe)),n&&(ve=e.getFacetNormal(o).normalize().scale(-1),me=R.clone().normalize(),ge=c.Pq.Cross(ve,me),Se=(0,C.RandomRange)(0,2*Math.PI),ye=me.scale(Math.cos(Se)).add(ge.scale(Math.sin(Se))),Se=(0,C.RandomRange)(.1,Math.PI/2),Ae=ye.scale(Math.cos(Se)).add(ve.scale(Math.sin(Se))),we.origin=he.add(Ae.scale(1e-5)),we.direction=Ae,we.length=l,Pe=we.intersectsMesh(e),Pe.hit&&(Ce=Pe.pickedPoint.subtract(he).length(),Ie=(0,C.RandomRange)(0,1)*Ce,he.addInPlace(Ae.scale(Ie)))),Re.position=he.clone(),this._positions.push(Re.position.x,Re.position.y,Re.position.z),void 0!==r?d&&(de=W.add(X.scale(_e)).add(K.scale(_e*pe)),r?s&&null!==t._groupImageData?(f=t._groupImgWidth,p=t._groupImgHeight,Le=this._getColorIndicesForCoord(t,Math.round(de.x*f),Math.round(de.y*p),f),Re.color=Le,this._colors.push(Le.r,Le.g,Le.b,Le.a)):_?(xe=oe.add(ue.scale(_e)).add(fe.scale(_e*pe)),Re.color=new F.ov(xe.x,xe.y,xe.z,xe.w),this._colors.push(xe.x,xe.y,xe.z,xe.w)):(xe=oe.set(Math.random(),Math.random(),Math.random(),1),Re.color=new F.ov(xe.x,xe.y,xe.z,xe.w),this._colors.push(xe.x,xe.y,xe.z,xe.w)):(Re.uv=de.clone(),this._uvs.push(Re.uv.x,Re.uv.y))):(a?(Me.set(a.r,a.g,a.b),x=(0,C.RandomRange)(-i,i),G=(0,C.RandomRange)(-i,i),be=Me.toHSV(),Ee=be.r,De=be.g+x,Te=be.b+G,De<0&&(De=0),De>1&&(De=1),Te<0&&(Te=0),Te>1&&(Te=1),F.v9.HSVtoRGBToRef(Ee,De,Te,Be),xe.set(Be.r,Be.g,Be.b,1)):xe=oe.set(Math.random(),Math.random(),Math.random(),1),Re.color=new F.ov(xe.x,xe.y,xe.z,xe.w),this._colors.push(xe.x,xe.y,xe.z,xe.w))}}_colorFromTexture(e,t,n){if(null===e.material)return l.V.Warn(e.name+"has no material."),t._groupImageData=null,void this._setPointsColorOrUV(e,t,n,!0,!1);const r=e.material.getActiveTextures();if(0===r.length)return l.V.Warn(e.name+"has no usable texture."),t._groupImageData=null,void this._setPointsColorOrUV(e,t,n,!0,!1);const s=e.clone();s.setEnabled(!1),this._promises.push(new Promise(e=>{N.t.WhenAllReady(r,()=>{let a=t._textureNb;a<0&&(a=0),a>r.length-1&&(a=r.length-1);const i=()=>{t._groupImgWidth=r[a].getSize().width,t._groupImgHeight=r[a].getSize().height,this._setPointsColorOrUV(s,t,n,!0,!0,void 0,void 0,r[a].coordinatesIndex),s.dispose(),e()};t._groupImageData=null;const o=r[a].readPixels();o?o.then(e=>{t._groupImageData=e,i()}):i()})}))}_calculateDensity(e,t,n){let r,s,a,i,o,l,u,f,h,d,_,p;const x=c.Pq.Zero(),v=c.Pq.Zero(),m=c.Pq.Zero(),g=c.Pq.Zero(),S=c.Pq.Zero(),y=c.Pq.Zero();let I;const C=[];let w=0;const P=n.length/3;for(let e=0;e<P;e++)r=n[3*e],s=n[3*e+1],a=n[3*e+2],i=t[3*r],o=t[3*r+1],l=t[3*r+2],u=t[3*s],f=t[3*s+1],h=t[3*s+2],d=t[3*a],_=t[3*a+1],p=t[3*a+2],x.set(i,o,l),v.set(u,f,h),m.set(d,_,p),v.subtractToRef(x,g),m.subtractToRef(v,S),c.Pq.CrossToRef(g,S,y),I=.5*y.length(),w+=I,C[e]=w;const A=new Array(P);let E=e;for(let e=P-1;e>0;e--){const t=C[e];if(0===t)A[e]=0;else{const n=(t-C[e-1])/t*E,r=Math.floor(n),s=n-r,a=r+Number(Math.random()<s);A[e]=a,E-=a}}return A[0]=E,A}addPoints(e,t=this._randomUnitVector){const n=new H(this._groupCounter,t);let r,s=this.nbParticles;for(let t=0;t<e;t++)r=this._addParticle(s,n,this._groupCounter,t),n&&n._positionFunction&&n._positionFunction(r,s,t),this._positions.push(r.position.x,r.position.y,r.position.z),r.color&&this._colors.push(r.color.r,r.color.g,r.color.b,r.color.a),r.uv&&this._uvs.push(r.uv.x,r.uv.y),s++;return this.nbParticles+=e,this._groupCounter++,this._groupCounter}addSurfacePoints(e,t,n,r,s){let a=n||0;(isNaN(a)||a<0||a>3)&&(a=0);const i=e.getVerticesData(f.R.PositionKind),o=e.getIndices();this._groups.push(this._groupCounter);const c=new H(this._groupCounter,null);switch(c._groupDensity=this._calculateDensity(t,i,o),2===a?c._textureNb=r||0:r=r||new F.ov(1,1,1,1),a){case 2:this._colorFromTexture(e,c,!1);break;case 1:this._setPointsColorOrUV(e,c,!1,!1,!1);break;case 0:this._setPointsColorOrUV(e,c,!1);break;case 3:this._setPointsColorOrUV(e,c,!1,void 0,void 0,r,s)}return this.nbParticles+=t,this._groupCounter++,this._groupCounter-1}addVolumePoints(e,t,n,r,s){let a=n||0;(isNaN(a)||a<0||a>3)&&(a=0);const i=e.getVerticesData(f.R.PositionKind),o=e.getIndices();this._groups.push(this._groupCounter);const c=new H(this._groupCounter,null);switch(c._groupDensity=this._calculateDensity(t,i,o),2===a?c._textureNb=r||0:r=r||new F.ov(1,1,1,1),a){case 2:this._colorFromTexture(e,c,!0);break;case 1:this._setPointsColorOrUV(e,c,!0,!1,!1);break;case 0:this._setPointsColorOrUV(e,c,!0);break;case 3:this._setPointsColorOrUV(e,c,!0,void 0,void 0,r,s)}return this.nbParticles+=t,this._groupCounter++,this._groupCounter-1}setParticles(e=0,t=this.nbParticles-1,n=!0){if(!this._updatable||!this._isReady)return this;this.beforeUpdateParticles(e,t,n);const r=c.AA.Matrix[0],s=this.mesh,a=this._colors32,i=this._positions32,o=this._uvs32,l=c.AA.Vector3,u=l[5].copyFromFloats(1,0,0),h=l[6].copyFromFloats(0,1,0),d=l[7].copyFromFloats(0,0,1),_=l[8].setAll(Number.MAX_VALUE),p=l[9].setAll(-Number.MAX_VALUE);c.uq.IdentityToRef(r);let x=0;if(this.mesh?.isFacetDataEnabled&&(this._computeBoundingBox=!0),t=t>=this.nbParticles?this.nbParticles-1:t,this._computeBoundingBox&&(0!=e||t!=this.nbParticles-1)){const e=this.mesh?.getBoundingInfo();e&&(_.copyFrom(e.minimum),p.copyFrom(e.maximum))}x=0;let v=0,m=0,g=0;for(let n=e;n<=t;n++){const e=this.particles[n];x=e.idx,v=3*x,m=4*x,g=2*x,this.updateParticle(e);const t=e._rotationMatrix,s=e.position,a=e._globalPosition;this._computeParticleRotation&&e.getRotationMatrix(r);if(null!==e.parentId){const n=this.particles[e.parentId],i=n._rotationMatrix,o=n._globalPosition,c=s.x*i[1]+s.y*i[4]+s.z*i[7],l=s.x*i[0]+s.y*i[3]+s.z*i[6],u=s.x*i[2]+s.y*i[5]+s.z*i[8];if(a.x=o.x+l,a.y=o.y+c,a.z=o.z+u,this._computeParticleRotation){const e=r.m;t[0]=e[0]*i[0]+e[1]*i[3]+e[2]*i[6],t[1]=e[0]*i[1]+e[1]*i[4]+e[2]*i[7],t[2]=e[0]*i[2]+e[1]*i[5]+e[2]*i[8],t[3]=e[4]*i[0]+e[5]*i[3]+e[6]*i[6],t[4]=e[4]*i[1]+e[5]*i[4]+e[6]*i[7],t[5]=e[4]*i[2]+e[5]*i[5]+e[6]*i[8],t[6]=e[8]*i[0]+e[9]*i[3]+e[10]*i[6],t[7]=e[8]*i[1]+e[9]*i[4]+e[10]*i[7],t[8]=e[8]*i[2]+e[9]*i[5]+e[10]*i[8]}}else if(a.x=0,a.y=0,a.z=0,this._computeParticleRotation){const e=r.m;t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[4],t[4]=e[5],t[5]=e[6],t[6]=e[8],t[7]=e[9],t[8]=e[10]}const o=l[11];e.translateFromPivot?o.setAll(0):o.copyFrom(e.pivot);const c=l[0];c.copyFrom(e.position);const f=c.x-e.pivot.x,S=c.y-e.pivot.y,y=c.z-e.pivot.z;let I=f*t[0]+S*t[3]+y*t[6],C=f*t[1]+S*t[4]+y*t[7],w=f*t[2]+S*t[5]+y*t[8];I+=o.x,C+=o.y,w+=o.z;const P=i[v]=a.x+u.x*I+h.x*C+d.x*w,A=i[v+1]=a.y+u.y*I+h.y*C+d.y*w,E=i[v+2]=a.z+u.z*I+h.z*C+d.z*w;if(this._computeBoundingBox&&(_.minimizeInPlaceFromFloats(P,A,E),p.maximizeInPlaceFromFloats(P,A,E)),this._computeParticleColor&&e.color){const t=e.color,n=this._colors32;n[m]=t.r,n[m+1]=t.g,n[m+2]=t.b,n[m+3]=t.a}if(this._computeParticleTexture&&e.uv){const t=e.uv,n=this._uvs32;n[g]=t.x,n[g+1]=t.y}}return s&&(n&&(this._computeParticleColor&&s.updateVerticesData(f.R.ColorKind,a,!1,!1),this._computeParticleTexture&&s.updateVerticesData(f.R.UVKind,o,!1,!1),s.updateVerticesData(f.R.PositionKind,i,!1,!1)),this._computeBoundingBox&&(s.hasBoundingInfo?s.getBoundingInfo().reConstruct(_,p,s._worldMatrix):s.buildBoundingInfo(_,p,s._worldMatrix))),this.afterUpdateParticles(e,t,n),this}dispose(){this.mesh?.dispose(),this.vars=null,this._positions=null,this._indices=null,this._normals=null,this._uvs=null,this._colors=null,this._indices32=null,this._positions32=null,this._uvs32=null,this._colors32=null}refreshVisibleSize(){return this._isVisibilityBoxLocked||this.mesh?.refreshBoundingInfo(),this}setVisibilityBox(e){if(!this.mesh)return;const t=e/2;this.mesh.buildBoundingInfo(new c.Pq(-t,-t,-t),new c.Pq(t,t,t))}get isAlwaysVisible(){return this._alwaysVisible}set isAlwaysVisible(e){this.mesh&&(this._alwaysVisible=e,this.mesh.alwaysSelectAsActiveMesh=e)}set computeParticleRotation(e){this._computeParticleRotation=e}set computeParticleColor(e){this._computeParticleColor=e}set computeParticleTexture(e){this._computeParticleTexture=e}get computeParticleColor(){return this._computeParticleColor}get computeParticleTexture(){return this._computeParticleTexture}set computeBoundingBox(e){this._computeBoundingBox=e}get computeBoundingBox(){return this._computeBoundingBox}initParticles(){}recycleParticle(e){return e}updateParticle(e){return e}beforeUpdateParticles(e,t,n){}afterUpdateParticles(e,t,n){}}var W=n(26041);const q=.28209479177387814;async function Z(e,t,n){const r=new Promise((r,s)=>{const a=n.createCanvasImage();if(!a)throw new Error("Failed to create ImageBitmap");let i;if(a.onload=()=>{try{const e=n.createCanvas(a.width,a.height);if(!e)throw new Error("Failed to create canvas");const t=e.getContext("2d");if(!t)throw new Error("Failed to get 2D context");t.drawImage(a,0,0);const s=t.getImageData(0,0,e.width,e.height);r({bits:new Uint8Array(s.data.buffer),width:s.width})}catch(e){s(`Error loading image ${a.src} with exception: ${e}`)}},a.onerror=e=>{s(`Error loading image ${a.src} with exception: ${e}`)},a.crossOrigin="anonymous","string"==typeof e){if(!t)throw new Error("filename is required when using a URL");a.src=e+t}else{const t=new Blob([e],{type:"image/webp"});i=URL.createObjectURL(t),a.src=i}});return await r}async function X(e,t,n){let r,s;if(e instanceof Map){s=e;const t=s.get("meta.json");if(!t)throw new Error("meta.json not found in files Map");r=JSON.parse((new TextDecoder).decode(t))}else r=e;const a=[...r.means.files,...r.scales.files,...r.quats.files,...r.sh0.files];r.shN&&a.push(...r.shN.files);const i=await Promise.all(a.map(async e=>{if(s&&s.has(e)){const t=s.get(e);return await Z(t,e,n.getEngine())}return await Z(t,e,n.getEngine())}));return await async function(e,t,n){const r=e.count?e.count:e.means.shape[0],s=new ArrayBuffer(32*r),a=new Float32Array(s),i=new Float32Array(s),o=new Uint8ClampedArray(s),c=new Uint8ClampedArray(s),l=e=>Math.sign(e)*(Math.exp(Math.abs(e))-1),u=t[0].bits,f=t[1].bits;if(!Array.isArray(e.means.mins)||!Array.isArray(e.means.maxs))throw new Error("Missing arrays in SOG data.");for(let t=0;t<r;t++){const n=4*t;for(let r=0;r<3;r++){const s=e.means.mins[r],i=e.means.maxs[r],o=f[n+r]<<8|u[n+r],c=P.Lerp(s,i,o/65535);a[8*t+r]=l(c)}}const h=t[2].bits;if(2===e.version){if(!e.scales.codebook)throw new Error("Missing codebook in SOG version 2 scales data.");for(let t=0;t<r;t++){const n=4*t;for(let r=0;r<3;r++){const s=e.scales.codebook[h[n+r]],a=Math.exp(s);i[8*t+3+r]=a}}}else{if(!Array.isArray(e.scales.mins)||!Array.isArray(e.scales.maxs))throw new Error("Missing arrays in SOG scales data.");for(let t=0;t<r;t++){const n=4*t;for(let r=0;r<3;r++){const s=h[n+r],a=P.Lerp(e.scales.mins[r],e.scales.maxs[r],s/255),o=Math.exp(a);i[8*t+3+r]=o}}}const d=t[4].bits;if(2===e.version){if(!e.sh0.codebook)throw new Error("Missing codebook in SOG version 2 sh0 data.");for(let t=0;t<r;t++){const n=4*t;for(let r=0;r<3;r++){const s=.5+e.sh0.codebook[d[n+r]]*q;o[32*t+24+r]=Math.max(0,Math.min(255,Math.round(255*s)))}o[32*t+24+3]=d[n+3]}}else{if(!Array.isArray(e.sh0.mins)||!Array.isArray(e.sh0.maxs))throw new Error("Missing arrays in SOG sh0 data.");for(let t=0;t<r;t++){const n=4*t;for(let r=0;r<4;r++){const s=e.sh0.mins[r],a=e.sh0.maxs[r],i=d[n+r],c=P.Lerp(s,a,i/255);let l;l=r<3?.5+c*q:1/(1+Math.exp(-c)),o[32*t+24+r]=Math.max(0,Math.min(255,Math.round(255*l)))}}}const _=e=>2*(e/255-.5)/Math.SQRT2,p=t[3].bits;for(let e=0;e<r;e++){const t=p[4*e+0],n=p[4*e+1],r=p[4*e+2],s=p[4*e+3],a=_(t),i=_(n),o=_(r),l=s-252,u=a*a+i*i+o*o,f=Math.sqrt(Math.max(0,1-u));let h;switch(l){case 0:h=[f,a,i,o];break;case 1:h=[a,f,i,o];break;case 2:h=[a,i,f,o];break;case 3:h=[a,i,o,f];break;default:throw new Error("Invalid quaternion mode")}c[32*e+28+0]=127.5*h[0]+127.5,c[32*e+28+1]=127.5*h[1]+127.5,c[32*e+28+2]=127.5*h[2]+127.5,c[32*e+28+3]=127.5*h[3]+127.5}if(e.shN){const a=[0,3,8,15],i=e.shN.bands?a[e.shN.bands]:e.shN.shape[1]/3,o=t[5].bits,c=t[6].bits,l=t[5].width,u=3*i,f=Math.ceil(u/16),h=[],d=n.getEngine().getCaps().maxTextureSize,_=Math.ceil(r/d);for(let e=0;e<f;e++){const e=new Uint8Array(_*d*4*4);h.push(e)}if(2===e.version){if(!e.shN.codebook)throw new Error("Missing codebook in SOG version 2 shN data.");for(let t=0;t<r;t++){const n=c[4*t+0]+(c[4*t+1]<<8),r=n%64*i,s=Math.floor(n/64);for(let n=0;n<i;n++)for(let a=0;a<3;a++){const i=3*n+a,c=Math.floor(i/16),u=h[c],f=i%16,d=16*t,_=127.5*e.shN.codebook[o[4*(r+n)+a+s*l*4]]+127.5;u[f+d]=Math.max(0,Math.min(255,_))}}}else for(let t=0;t<r;t++){const n=c[4*t+0]+(c[4*t+1]<<8),r=n%64*i,s=Math.floor(n/64),a=e.shN.mins,u=e.shN.maxs;for(let e=0;e<3;e++)for(let n=0;n<i/3;n++){const i=3*n+e,c=Math.floor(i/16),f=h[c],d=i%16,_=16*t,p=127.5*P.Lerp(a,u,o[4*(r+n)+e+s*l*4]/255)+127.5;f[d+_]=Math.max(0,Math.min(255,p))}}return await new Promise(e=>{e({mode:0,data:s,hasVertexColors:!1,sh:h})})}return await new Promise(e=>{e({mode:0,data:s,hasVertexColors:!1})})}(r,i,n)}class K{constructor(e=K._DefaultLoadingOptions){this.name=s.B.name,this._assetContainer=null,this.extensions=s.B.extensions,this._loadingOptions=e}createPlugin(e){return new K(e[s.B.name])}async importMeshAsync(e,t,n,r,s,a){return await this._parseAsync(e,t,n,r).then(e=>({meshes:e,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]}))}static _BuildPointCloud(e,t){if(!t.byteLength)return!1;const n=new Uint8Array(t),r=new Float32Array(t),s=n.length/32;return e.addPoints(s,function(e,t){const s=r[8*t+0],a=r[8*t+1],i=r[8*t+2];e.position=new c.Pq(s,a,i);const o=n[32*t+24+0]/255,l=n[32*t+24+1]/255,u=n[32*t+24+2]/255;e.color=new W.ov(o,l,u,1)}),!0}static _BuildMesh(e,t){const n=new i.e("PLYMesh",e),r=new Uint8Array(t.data),s=new Float32Array(t.data),a=r.length/32,c=[],l=new o.P;for(let e=0;e<a;e++){const t=s[8*e+0],n=s[8*e+1],r=s[8*e+2];c.push(t,n,r)}if(t.hasVertexColors){const e=new Float32Array(4*a);for(let t=0;t<a;t++){const n=r[32*t+24+0]/255,s=r[32*t+24+1]/255,a=r[32*t+24+2]/255;e[4*t+0]=n,e[4*t+1]=s,e[4*t+2]=a,e[4*t+3]=1}l.colors=e}return l.positions=c,l.indices=t.faces,l.applyToMesh(n),n}async _unzipWithFFlateAsync(e){void 0===window.fflate&&await y.S0.LoadScriptAsync("https://unpkg.com/fflate/umd/index.js");const{unzipSync:t}=window.fflate,n=t(e),r=new Map;for(const[e,t]of Object.entries(n))r.set(e,t);return r}_parseAsync(e,t,n,r){const s=[],a=e=>{t._blockEntityCollection=!!this._assetContainer;const n=new R("GaussianSplatting",null,t,this._loadingOptions.keepInRam);n._parentContainer=this._assetContainer,n.viewDirectionFactor.set(1,-1,1),s.push(n),n.updateData(e.data,e.sh),t._blockEntityCollection=!1};if("string"==typeof n){const e=JSON.parse(n);if(e&&e.means&&e.scales&&e.quats&&e.sh0)return new Promise(n=>{X(e,r,t).then(e=>{a(e),n(s)}).catch(()=>{throw new Error("Failed to parse SOG data.")})})}const i=n instanceof ArrayBuffer?new Uint8Array(n):n;if(80===i[0]&&75===i[1])return new Promise(e=>{this._unzipWithFFlateAsync(i).then(n=>{X(n,r,t).then(t=>{a(t),e(s)}).catch(()=>{throw new Error("Failed to parse SOG zip data.")})})});const o=new ReadableStream({start(e){e.enqueue(new Uint8Array(n)),e.close()}}),c=new DecompressionStream("gzip"),l=o.pipeThrough(c);return new Promise(e=>{new Response(l).arrayBuffer().then(n=>{(function(e,t,n){const r=new Uint8Array(e),s=new Uint32Array(e.slice(0,12)),a=s[2],i=r[12],o=r[13],c=r[14],l=r[15],u=s[1];if(l||1347635022!=s[0]||2!=u&&3!=u)return new Promise(e=>{e({mode:3,data:f,hasVertexColors:!1})});const f=new ArrayBuffer(32*a),h=1/(1<<o),d=new Int32Array(1),_=new Uint8Array(d.buffer),p=function(e,t){return _[0]=e[t+0],_[1]=e[t+1],_[2]=e[t+2],_[3]=128&e[t+2]?255:0,d[0]*h};let x=16;const v=new Float32Array(f),m=new Float32Array(f),g=new Uint8ClampedArray(f),S=new Uint8ClampedArray(f);let y=1,I=0;n.flipY||(y=-1,I=255);for(let e=0;e<a;e++)v[8*e+0]=p(r,x+0),v[8*e+1]=y*p(r,x+3),v[8*e+2]=y*p(r,x+6),x+=9;for(let e=0;e<a;e++){for(let t=0;t<3;t++){const n=(r[x+a+3*e+t]-127.5)/38.25;g[32*e+24+t]=P.Clamp(255*(.5+.282*n),0,255)}g[32*e+24+3]=r[x+e]}x+=4*a;for(let e=0;e<a;e++)m[8*e+3+0]=Math.exp(r[x+0]/16-10),m[8*e+3+1]=Math.exp(r[x+1]/16-10),m[8*e+3+2]=Math.exp(r[x+2]/16-10),x+=3;if(u>=3){const e=Math.SQRT1_2;for(let t=0;t<a;t++){const n=[r[x+0],r[x+1],r[x+2],r[x+3]],s=n[0]+(n[1]<<8)+(n[2]<<16)+(n[3]<<24),a=511,i=[],o=s>>>30;let c=s,l=0;for(let t=3;t>=0;--t)if(t!==o){const n=c&a,r=c>>>9&1;c>>>=10,i[t]=e*(n/a),1===r&&(i[t]=-i[t]),l+=i[t]*i[t]}const u=1-l;i[o]=Math.sqrt(Math.max(u,0)),i[1]*=y,i[2]*=y;const f=[3,0,1,2];for(let e=0;e<4;e++)S[32*t+28+e]=Math.round(127.5+127.5*i[f[e]]);x+=4}}else for(let e=0;e<a;e++){const t=r[x+0],n=r[x+1]*y+I,s=r[x+2]*y+I,a=t/127.5-1,i=n/127.5-1,o=s/127.5-1;S[32*e+28+1]=t,S[32*e+28+2]=n,S[32*e+28+3]=s;const c=1-(a*a+i*i+o*o);S[32*e+28+0]=127.5+127.5*Math.sqrt(c<0?0:c),x+=3}if(i){const e=3*((i+1)*(i+1)-1),n=Math.ceil(e/16);let s=x;const o=[],l=t.getEngine().getCaps().maxTextureSize,u=Math.ceil(a/l);for(let e=0;e<n;e++){const e=new Uint8Array(u*l*4*4);o.push(e)}for(let t=0;t<a;t++)for(let n=0;n<e;n++){const e=r[s++],a=Math.floor(n/16);o[a][n%16+16*t]=e}return new Promise(e=>{e({mode:0,data:f,hasVertexColors:!1,sh:o,trainedWithAntialiasing:!!c})})}return new Promise(e=>{e({mode:0,data:f,hasVertexColors:!1,trainedWithAntialiasing:!!c})})})(n,t,this._loadingOptions).then(n=>{t._blockEntityCollection=!!this._assetContainer;const r=new R("GaussianSplatting",null,t,this._loadingOptions.keepInRam);if(n.trainedWithAntialiasing){const e=r.material;e.kernelSize=.1,e.compensation=!0}r._parentContainer=this._assetContainer,s.push(r),r.updateData(n.data,n.sh),t._blockEntityCollection=!1,e(s)})}).catch(()=>{K._ConvertPLYToSplat(n).then(async n=>{switch(t._blockEntityCollection=!!this._assetContainer,n.mode){case 0:{const e=new R("GaussianSplatting",null,t,this._loadingOptions.keepInRam);e._parentContainer=this._assetContainer,s.push(e),e.updateData(n.data,n.sh),!n.compressed&&n.rawSplat||e.viewDirectionFactor.set(-1,-1,1)}break;case 1:{const e=new k("PointCloud",1,t);K._BuildPointCloud(e,n.data)?await e.buildMeshAsync().then(e=>{s.push(e)}):e.dispose()}break;case 2:if(!n.faces)throw new Error("PLY mesh doesn't contain face informations.");s.push(K._BuildMesh(t,n));break;default:throw new Error("Unsupported Splat mode")}t._blockEntityCollection=!1,e(s)})})})}loadAssetContainerAsync(e,t,n){const r=new z.WZ(e);return this._assetContainer=r,this.importMeshAsync(null,e,t,n).then(e=>{for(const t of e.meshes)r.meshes.push(t);return this._assetContainer=null,r}).catch(e=>{throw this._assetContainer=null,e})}loadAsync(e,t,n){return this.importMeshAsync(null,e,t,n).then(()=>{})}static _ConvertPLYToSplat(e){const t=new Uint8Array(e),n=(new TextDecoder).decode(t.slice(0,10240)),r="end_header\n",s=n.indexOf(r);if(s<0||!n)return new Promise(t=>{t({mode:0,data:e,rawSplat:!0})});const a=parseInt(/element vertex (\d+)\n/.exec(n)[1]),i=/element face (\d+)\n/.exec(n);let o=0;i&&(o=parseInt(i[1]));const c=/element chunk (\d+)\n/.exec(n);let u=0;c&&(u=parseInt(c[1]));let f=0,h=0;const d={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let _;!function(e){e[e.Vertex=0]="Vertex",e[e.Chunk=1]="Chunk",e[e.SH=2]="SH"}(_||(_={}));let p=1;const x=[],v=[],m=n.slice(0,s).split("\n");for(const e of m)if(e.startsWith("property ")){const[,t,n]=e.split(" ");1==p?(v.push({name:n,type:t,offset:h}),h+=d[t]):0==p?(x.push({name:n,type:t,offset:f}),f+=d[t]):2==p&&x.push({name:n,type:t,offset:f}),d[t]||l.V.Warn(`Unsupported property type: ${t}.`)}else if(e.startsWith("element ")){const[,t]=e.split(" ");"chunk"==t?p=1:"vertex"==t?p=0:"sh"==t&&(p=2)}const g=f,S=h;return R.ConvertPLYWithSHToSplatAsync(e).then(async t=>{const n=new DataView(e,s+11);let r=S*u+g*a;const i=[];if(o)for(let e=0;e<o;e++){const e=n.getUint8(r);if(3==e){r+=1;for(let t=0;t<e;t++){const e=n.getUint32(r+4*(2-t),!0);i.push(e)}r+=12}}if(u)return await new Promise(e=>{e({mode:0,data:t.buffer,sh:t.sh,faces:i,hasVertexColors:!1,compressed:!0,rawSplat:!1})});let c=0,l=0;const f=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],h=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let e=0;e<x.length;e++){const t=x[e];f.includes(t.name)&&c++,h.includes(t.name)&&l++}const d=c==f.length&&3==l,_=o?2:d?0:1;return await new Promise(e=>{e({mode:_,data:t.buffer,sh:t.sh,faces:i,hasVertexColors:!!l,compressed:!1,rawSplat:!1})})})}}K._DefaultLoadingOptions={keepInRam:!1,flipY:!1},(0,r.qS)(new K)},38780:(e,t,n)=>{var r=n(69610);const s="logDepthFragment",a="#ifdef LOGARITHMICDEPTH\nfragmentOutputs.fragDepth=log2(fragmentInputs.vFragmentDepth)*uniforms.logarithmicDepthConstant*0.5;\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},39759:(e,t,n)=>{var r=n(69610);const s="clipPlaneFragmentDeclaration",a="#ifdef CLIPPLANE\nvarying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nvarying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nvarying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nvarying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nvarying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nvarying fClipDistance6: f32;\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},55597:(e,t,n)=>{n.r(t),n.d(t,{gaussianSplattingVertexShaderWGSL:()=>c});var r=n(69610);n(98327),n(6874),n(79702),n(77029),n(75757),n(93226);const s="gaussianSplatting",a="fn getDataUV(index: f32,dataTextureSize: vec2f)->vec2<f32> {let y: f32=floor(index/dataTextureSize.x);let x: f32=index-y*dataTextureSize.x;return vec2f((x+0.5),(y+0.5));}\nstruct Splat {center: vec4f,\ncolor: vec4f,\ncovA: vec4f,\ncovB: vec4f,\n#if SH_DEGREE>0\nsh0: vec4<u32>,\n#endif\n#if SH_DEGREE>1\nsh1: vec4<u32>,\n#endif\n#if SH_DEGREE>2\nsh2: vec4<u32>,\n#endif\n};fn readSplat(splatIndex: f32,dataTextureSize: vec2f)->Splat {var splat: Splat;let splatUV=getDataUV(splatIndex,dataTextureSize);let splatUVi32=vec2<i32>(i32(splatUV.x),i32(splatUV.y));splat.center=textureLoad(centersTexture,splatUVi32,0);splat.color=textureLoad(colorsTexture,splatUVi32,0);splat.covA=textureLoad(covariancesATexture,splatUVi32,0)*splat.center.w;splat.covB=textureLoad(covariancesBTexture,splatUVi32,0)*splat.center.w;\n#if SH_DEGREE>0\nsplat.sh0=textureLoad(shTexture0,splatUVi32,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=textureLoad(shTexture1,splatUVi32,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=textureLoad(shTexture2,splatUVi32,0);\n#endif\nreturn splat;}\nfn computeColorFromSHDegree(dir: vec3f,sh: array<vec3<f32>,16>)->vec3f\n{let SH_C0: f32=0.28209479;let SH_C1: f32=0.48860251;var SH_C2: array<f32,5>=array<f32,5>(\n1.092548430,\n-1.09254843,\n0.315391565,\n-1.09254843,\n0.546274215\n);var SH_C3: array<f32,7>=array<f32,7>(\n-0.59004358,\n2.890611442,\n-0.45704579,\n0.373176332,\n-0.45704579,\n1.445305721,\n-0.59004358\n);var result: vec3f=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nlet x: f32=dir.x;let y: f32=dir.y;let z: f32=dir.z;result+=-SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nlet xx: f32=x*x;let yy: f32=y*y;let zz: f32=z*z;let xy: f32=x*y;let yz: f32=y*z;let xz: f32=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0f*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0f*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0f*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0f*zz-3.0f*xx-3.0f*yy)*sh[12] +\nSH_C3[4]*x*(4.0f*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0f*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nfn decompose(value: u32)->vec4f\n{let components : vec4f=vec4f(\nf32((value ) & 255u),\nf32((value>>u32( 8)) & 255u),\nf32((value>>u32(16)) & 255u),\nf32((value>>u32(24)) & 255u));return components*vec4f(2./255.)-vec4f(1.);}\nfn computeSH(splat: Splat,dir: vec3f)->vec3f\n{var sh: array<vec3<f32>,16>;sh[0]=vec3f(0.,0.,0.);\n#if SH_DEGREE>0\nlet sh00: vec4f=decompose(splat.sh0.x);let sh01: vec4f=decompose(splat.sh0.y);let sh02: vec4f=decompose(splat.sh0.z);sh[1]=vec3f(sh00.x,sh00.y,sh00.z);sh[2]=vec3f(sh00.w,sh01.x,sh01.y);sh[3]=vec3f(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nlet sh03: vec4f=decompose(splat.sh0.w);let sh04: vec4f=decompose(splat.sh1.x);let sh05: vec4f=decompose(splat.sh1.y);sh[4]=vec3f(sh02.y,sh02.z,sh02.w);sh[5]=vec3f(sh03.x,sh03.y,sh03.z);sh[6]=vec3f(sh03.w,sh04.x,sh04.y);sh[7]=vec3f(sh04.z,sh04.w,sh05.x);sh[8]=vec3f(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nlet sh06: vec4f=decompose(splat.sh1.z);let sh07: vec4f=decompose(splat.sh1.w);let sh08: vec4f=decompose(splat.sh2.x);let sh09: vec4f=decompose(splat.sh2.y);let sh10: vec4f=decompose(splat.sh2.z);let sh11: vec4f=decompose(splat.sh2.w);sh[9]=vec3f(sh06.x,sh06.y,sh06.z);sh[10]=vec3f(sh06.w,sh07.x,sh07.y);sh[11]=vec3f(sh07.z,sh07.w,sh08.x);sh[12]=vec3f(sh08.y,sh08.z,sh08.w);sh[13]=vec3f(sh09.x,sh09.y,sh09.z);sh[14]=vec3f(sh09.w,sh10.x,sh10.y);sh[15]=vec3f(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\nfn gaussianSplatting(\nmeshPos: vec2<f32>,\nworldPos: vec3<f32>,\nscale: vec2<f32>,\ncovA: vec3<f32>,\ncovB: vec3<f32>,\nworldMatrix: mat4x4<f32>,\nviewMatrix: mat4x4<f32>,\nprojectionMatrix: mat4x4<f32>,\nfocal: vec2f,\ninvViewport: vec2f,\nkernelSize: f32\n)->vec4f {let modelView=viewMatrix*worldMatrix;let camspace=viewMatrix*vec4f(worldPos,1.0);let pos2d=projectionMatrix*camspace;let bounds=1.2*pos2d.w;if (pos2d.z<0. || pos2d.x<-bounds || pos2d.x>bounds || pos2d.y<-bounds || pos2d.y>bounds) {return vec4f(0.0,0.0,2.0,1.0);}\nlet Vrk=mat3x3<f32>(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);let J=mat3x3<f32>(\nfocal.x/camspace.z,0.0,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.0,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.0,0.0,0.0\n);let invy=mat3x3<f32>(\n1.0,0.0,0.0,\n0.0,-1.0,0.0,\n0.0,0.0,1.0\n);let T=invy*transpose(mat3x3<f32>(\nmodelView[0].xyz,\nmodelView[1].xyz,\nmodelView[2].xyz))*J;var cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nlet c00: f32=cov2d[0][0];let c11: f32=cov2d[1][1];let c01: f32=cov2d[0][1];let detOrig: f32=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nlet c2d: vec3f=vec3f(cov2d[0][0],c01,cov2d[1][1]);let detBlur: f32=c2d.x*c2d.z-c2d.y*c2d.y;let compensation: f32=sqrt(max(0.,detOrig/detBlur));vertexOutputs.vColor.w*=compensation;\n#endif\nlet mid=(cov2d[0][0]+cov2d[1][1])/2.0;let radius=length(vec2<f32>((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));let lambda1=mid+radius;let lambda2=mid-radius;if (lambda2<0.0) {return vec4f(0.0,0.0,2.0,1.0);}\nlet diagonalVector=normalize(vec2<f32>(cov2d[0][1],lambda1-cov2d[0][0]));let majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;let minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2<f32>(diagonalVector.y,-diagonalVector.x);let vCenter=vec2<f32>(pos2d.x,pos2d.y);return vec4f(\nvCenter+((meshPos.x*majorAxis+meshPos.y*minorAxis)*invViewport*pos2d.w)*scale,\npos2d.z,\npos2d.w\n);}\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a);n(85197),n(59013),n(81482);const i="gaussianSplattingVertexShader",o="#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n#include<helperFunctions>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\nattribute splatIndex: f32;attribute position: vec2f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;uniform eyePosition: vec3f;uniform viewDirectionFactor: vec3f;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;\n#if SH_DEGREE>0\nvar shTexture0: texture_2d<u32>;\n#endif\n#if SH_DEGREE>1\nvar shTexture1: texture_2d<u32>;\n#endif\n#if SH_DEGREE>2\nvar shTexture2: texture_2d<u32>;\n#endif\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var splat: Splat=readSplat(input.splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position;\n#if SH_DEGREE>0\nlet worldRot: mat3x3f= mat3x3f(mesh.world[0].xyz,mesh.world[1].xyz,mesh.world[2].xyz);let normWorldRot: mat3x3f=inverseMat3(worldRot);var dir: vec3f=normalize(normWorldRot*(worldPos.xyz-uniforms.eyePosition.xyz));dir*=uniforms.viewDirectionFactor;vertexOutputs.vColor=vec4f(splat.color.xyz+computeSH(splat,dir),splat.color.w);\n#else\nvertexOutputs.vColor=splat.color;\n#endif\nvertexOutputs.position=gaussianSplatting(input.position,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n";r.l.ShadersStoreWGSL[i]||(r.l.ShadersStoreWGSL[i]=o);const c={name:i,shader:o}},59013:(e,t,n)=>{var r=n(69610);const s="fogVertex",a="#ifdef FOG\n#ifdef SCENE_UBO\nvertexOutputs.vFogDistance=(scene.view*worldPos).xyz;\n#else\nvertexOutputs.vFogDistance=(uniforms.view*worldPos).xyz;\n#endif\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},60924:(e,t,n)=>{n.r(t),n.d(t,{gaussianSplattingVertexShader:()=>h});var r=n(69610);const s="gaussianSplattingVertexDeclaration",a="attribute vec2 position;uniform mat4 view;uniform mat4 projection;uniform mat4 world;uniform vec4 vEyePosition;";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a);n(28764),n(96467);const i="gaussianSplattingUboDeclaration",o="#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute vec2 position;";r.l.IncludesShadersStore[i]||(r.l.IncludesShadersStore[i]=o);n(71636),n(86560),n(34581),n(73325);const c="gaussianSplatting",l="#if !defined(WEBGL2) && !defined(WEBGPU) && !defined(NATIVE)\nmat3 transpose(mat3 matrix) {return mat3(matrix[0][0],matrix[1][0],matrix[2][0],\nmatrix[0][1],matrix[1][1],matrix[2][1],\nmatrix[0][2],matrix[1][2],matrix[2][2]);}\n#endif\nvec2 getDataUV(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return vec2((x+0.5)/textureSize.x,(y+0.5)/textureSize.y);}\n#if SH_DEGREE>0\nivec2 getDataUVint(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return ivec2(uint(x+0.5),uint(y+0.5));}\n#endif\nstruct Splat {vec4 center;vec4 color;vec4 covA;vec4 covB;\n#if SH_DEGREE>0\nuvec4 sh0; \n#endif\n#if SH_DEGREE>1\nuvec4 sh1;\n#endif\n#if SH_DEGREE>2\nuvec4 sh2;\n#endif\n};Splat readSplat(float splatIndex)\n{Splat splat;vec2 splatUV=getDataUV(splatIndex,dataTextureSize);splat.center=texture2D(centersTexture,splatUV);splat.color=texture2D(colorsTexture,splatUV);splat.covA=texture2D(covariancesATexture,splatUV)*splat.center.w;splat.covB=texture2D(covariancesBTexture,splatUV)*splat.center.w;\n#if SH_DEGREE>0\nivec2 splatUVint=getDataUVint(splatIndex,dataTextureSize);splat.sh0=texelFetch(shTexture0,splatUVint,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=texelFetch(shTexture1,splatUVint,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=texelFetch(shTexture2,splatUVint,0);\n#endif\nreturn splat;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nvec3 computeColorFromSHDegree(vec3 dir,const vec3 sh[16])\n{const float SH_C0=0.28209479;const float SH_C1=0.48860251;float SH_C2[5];SH_C2[0]=1.092548430;SH_C2[1]=-1.09254843;SH_C2[2]=0.315391565;SH_C2[3]=-1.09254843;SH_C2[4]=0.546274215;float SH_C3[7];SH_C3[0]=-0.59004358;SH_C3[1]=2.890611442;SH_C3[2]=-0.45704579;SH_C3[3]=0.373176332;SH_C3[4]=-0.45704579;SH_C3[5]=1.445305721;SH_C3[6]=-0.59004358;vec3 result=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nfloat x=dir.x;float y=dir.y;float z=dir.z;result+=- SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nfloat xx=x*x,yy=y*y,zz=z*z;float xy=x*y,yz=y*z,xz=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0*zz-3.0*xx-3.0*yy)*sh[12] +\nSH_C3[4]*x*(4.0*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nvec4 decompose(uint value)\n{vec4 components=vec4(\nfloat((value ) & 255u),\nfloat((value>>uint( 8)) & 255u),\nfloat((value>>uint(16)) & 255u),\nfloat((value>>uint(24)) & 255u));return components*vec4(2./255.)-vec4(1.);}\nvec3 computeSH(Splat splat,vec3 dir)\n{vec3 sh[16];sh[0]=vec3(0.,0.,0.);\n#if SH_DEGREE>0\nvec4 sh00=decompose(splat.sh0.x);vec4 sh01=decompose(splat.sh0.y);vec4 sh02=decompose(splat.sh0.z);sh[1]=vec3(sh00.x,sh00.y,sh00.z);sh[2]=vec3(sh00.w,sh01.x,sh01.y);sh[3]=vec3(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nvec4 sh03=decompose(splat.sh0.w);vec4 sh04=decompose(splat.sh1.x);vec4 sh05=decompose(splat.sh1.y);sh[4]=vec3(sh02.y,sh02.z,sh02.w);sh[5]=vec3(sh03.x,sh03.y,sh03.z);sh[6]=vec3(sh03.w,sh04.x,sh04.y);sh[7]=vec3(sh04.z,sh04.w,sh05.x);sh[8]=vec3(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nvec4 sh06=decompose(splat.sh1.z);vec4 sh07=decompose(splat.sh1.w);vec4 sh08=decompose(splat.sh2.x);vec4 sh09=decompose(splat.sh2.y);vec4 sh10=decompose(splat.sh2.z);vec4 sh11=decompose(splat.sh2.w);sh[9]=vec3(sh06.x,sh06.y,sh06.z);sh[10]=vec3(sh06.w,sh07.x,sh07.y);sh[11]=vec3(sh07.z,sh07.w,sh08.x);sh[12]=vec3(sh08.y,sh08.z,sh08.w);sh[13]=vec3(sh09.x,sh09.y,sh09.z);sh[14]=vec3(sh09.w,sh10.x,sh10.y);sh[15]=vec3(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\n#else\nvec3 computeSH(Splat splat,vec3 dir)\n{return vec3(0.,0.,0.);}\n#endif\nvec4 gaussianSplatting(vec2 meshPos,vec3 worldPos,vec2 scale,vec3 covA,vec3 covB,mat4 worldMatrix,mat4 viewMatrix,mat4 projectionMatrix)\n{mat4 modelView=viewMatrix*worldMatrix;vec4 camspace=viewMatrix*vec4(worldPos,1.);vec4 pos2d=projectionMatrix*camspace;float bounds=1.2*pos2d.w;if (pos2d.z<-pos2d.w || pos2d.x<-bounds || pos2d.x>bounds\n|| pos2d.y<-bounds || pos2d.y>bounds) {return vec4(0.0,0.0,2.0,1.0);}\nmat3 Vrk=mat3(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);mat3 J=mat3(\nfocal.x/camspace.z,0.,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.,0.,0.\n);mat3 invy=mat3(1,0,0,0,-1,0,0,0,1);mat3 T=invy*transpose(mat3(modelView))*J;mat3 cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nfloat c00=cov2d[0][0];float c11=cov2d[1][1];float c01=cov2d[0][1];float detOrig=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nvec3 c2d=vec3(cov2d[0][0],c01,cov2d[1][1]);float detBlur=c2d.x*c2d.z-c2d.y*c2d.y;float compensation=sqrt(max(0.,detOrig/detBlur));vColor.w*=compensation;\n#endif\nfloat mid=(cov2d[0][0]+cov2d[1][1])/2.0;float radius=length(vec2((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));float epsilon=0.0001;float lambda1=mid+radius+epsilon,lambda2=mid-radius+epsilon;if (lambda2<0.0)\n{return vec4(0.0,0.0,2.0,1.0);}\nvec2 diagonalVector=normalize(vec2(cov2d[0][1],lambda1-cov2d[0][0]));vec2 majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;vec2 minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2(diagonalVector.y,-diagonalVector.x);vec2 vCenter=vec2(pos2d);return vec4(\nvCenter \n+ ((meshPos.x*majorAxis\n+ meshPos.y*minorAxis)*invViewport*pos2d.w)*scale,pos2d.zw);}";r.l.IncludesShadersStore[c]||(r.l.IncludesShadersStore[c]=l);n(47314),n(16470),n(2215);const u="gaussianSplattingVertexShader",f="#include<__decl__gaussianSplattingVertex>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\nattribute float splatIndex;uniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform vec3 eyePosition;uniform vec3 viewDirectionFactor;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;\n#if SH_DEGREE>0\nuniform highp usampler2D shTexture0;\n#endif\n#if SH_DEGREE>1\nuniform highp usampler2D shTexture1;\n#endif\n#if SH_DEGREE>2\nuniform highp usampler2D shTexture2;\n#endif\nvarying vec4 vColor;varying vec2 vPosition;\n#include<gaussianSplatting>\nvoid main () {Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);vec4 worldPos=world*vec4(splat.center.xyz,1.0);vColor=splat.color;vPosition=position;\n#if SH_DEGREE>0\nmat3 worldRot=mat3(world);mat3 normWorldRot=inverseMat3(worldRot);vec3 dir=normalize(normWorldRot*(worldPos.xyz-eyePosition));dir*=viewDirectionFactor;vColor.xyz=splat.color.xyz+computeSH(splat,dir);\n#endif\ngl_Position=gaussianSplatting(position,worldPos.xyz,vec2(1.,1.),covA,covB,world,view,projection);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n";r.l.ShadersStore[u]||(r.l.ShadersStore[u]=f);const h={name:u,shader:f}},66407:(e,t,n)=>{var r=n(69610);const s="fogFragmentDeclaration",a="#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\nconst E=2.71828;uniform vFogInfos: vec4f;uniform vFogColor: vec3f;varying vFogDistance: vec3f;fn CalcFogFactor()->f32\n{var fogCoeff: f32=1.0;var fogStart: f32=uniforms.vFogInfos.y;var fogEnd: f32=uniforms.vFogInfos.z;var fogDensity: f32=uniforms.vFogInfos.w;var fogDistance: f32=length(fragmentInputs.vFogDistance);if (FOGMODE_LINEAR==uniforms.vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==uniforms.vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==uniforms.vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},73325:(e,t,n)=>{var r=n(69610);const s="helperFunctions",a="const float PI=3.1415926535897932384626433832795;const float TWO_PI=6.283185307179586;const float HALF_PI=1.5707963267948966;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float RECIPROCAL_PI4=0.07957747154594767;const float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nmat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}\n#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\n{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\n#else\nreturn\nvec3(\ncolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\nvec3 toGammaSpaceExact(vec3 color)\n{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\n#else\nreturn\nvec3(\ncolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\n#endif\nfloat toLinearSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nvec3 toLinearSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\n#endif\n}\nvec4 toLinearSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfloat toGammaSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,GammaEncodePowerApprox);\n#endif\n}\nvec3 toGammaSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\n#endif\n}\nvec4 toGammaSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfloat square(float value)\n{return value*value;}\nvec3 square(vec3 value)\n{return value*value;}\nfloat pow5(float value) {float sq=value*value;return sq*sq*value;}\nfloat getLuminance(vec3 color)\n{return saturate(dot(color,LuminanceEncodeApprox));}\nfloat getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}\nfloat dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}\nconst float rgbdMaxRange=255.;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =saturate(floor(D)/255.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(saturate(rgb),D);}\nvec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\nvec3 equirectangularToCubemapDirection(vec2 uv) {float longitude=uv.x*TWO_PI-PI;float latitude=HALF_PI-uv.y*PI;vec3 direction;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}\nfloat sqrtClamped(float value) {return sqrt(max(value,0.));}\nfloat avg(vec3 value) {return dot(value,vec3(0.333333333));}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE) \nuint extractBits(uint value,int offset,int width) {return (value>>offset) & ((1u<<width)-1u);}\nint onlyBitPosition(uint value) {return (floatBitsToInt(float(value))>>23)-0x7f;}\n#endif\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a)},75757:(e,t,n)=>{var r=n(69610);const s="fogVertexDeclaration",a="#ifdef FOG\nvarying vFogDistance: vec3f;\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},77029:(e,t,n)=>{var r=n(69610);const s="clipPlaneVertexDeclaration",a="#ifdef CLIPPLANE\nuniform vClipPlane: vec4<f32>;varying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nuniform vClipPlane2: vec4<f32>;varying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nuniform vClipPlane3: vec4<f32>;varying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nuniform vClipPlane4: vec4<f32>;varying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nuniform vClipPlane5: vec4<f32>;varying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nuniform vClipPlane6: vec4<f32>;varying fClipDistance6: f32;\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},79702:(e,t,n)=>{var r=n(69610);const s="helperFunctions",a="const PI: f32=3.1415926535897932384626433832795;const TWO_PI: f32=6.283185307179586;const HALF_PI: f32=1.5707963267948966;const RECIPROCAL_PI: f32=0.3183098861837907;const RECIPROCAL_PI2: f32=0.15915494309189535;const RECIPROCAL_PI4: f32=0.07957747154594767;const HALF_MIN: f32=5.96046448e-08; \nconst LinearEncodePowerApprox: f32=2.2;const GammaEncodePowerApprox: f32=1.0/LinearEncodePowerApprox;const LuminanceEncodeApprox: vec3f=vec3f(0.2126,0.7152,0.0722);const Epsilon:f32=0.0000001;fn square(x: f32)->f32 {return x*x;}\nfn saturate(x: f32)->f32 {return clamp(x,0.0,1.0);}\nfn saturateVec3(x: vec3f)->vec3f {return clamp(x,vec3f(),vec3f(1.0));}\nfn saturateEps(x: f32)->f32 {return clamp(x,Epsilon,1.0);}\nfn maxEps(x: f32)->f32 {return max(x,Epsilon);}\nfn maxEpsVec3(x: vec3f)->vec3f {return max(x,vec3f(Epsilon));}\nfn absEps(x: f32)->f32 {return abs(x)+Epsilon;}\nfn transposeMat3(inMatrix: mat3x3f)->mat3x3f {let i0: vec3f=inMatrix[0];let i1: vec3f=inMatrix[1];let i2: vec3f=inMatrix[2];let outMatrix:mat3x3f=mat3x3f(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nfn inverseMat3(inMatrix: mat3x3f)->mat3x3f {let a00: f32=inMatrix[0][0];let a01: f32=inMatrix[0][1];let a02: f32=inMatrix[0][2];let a10: f32=inMatrix[1][0];let a11: f32=inMatrix[1][1];let a12: f32=inMatrix[1][2];let a20: f32=inMatrix[2][0];let a21: f32=inMatrix[2][1];let a22: f32=inMatrix[2][2];let b01: f32=a22*a11-a12*a21;let b11: f32=-a22*a10+a12*a20;let b21: f32=a21*a10-a11*a20;let det: f32=a00*b01+a01*b11+a02*b21;return mat3x3f(b01/det,(-a22*a01+a02*a21)/det,(a12*a01-a02*a11)/det,\nb11/det,(a22*a00-a02*a20)/det,(-a12*a00+a02*a10)/det,\nb21/det,(-a21*a00+a01*a20)/det,(a11*a00-a01*a10)/det);}\n#if USE_EXACT_SRGB_CONVERSIONS\nfn toLinearSpaceExact(color: vec3f)->vec3f\n{let nearZeroSection: vec3f=0.0773993808*color;let remainingSection: vec3f=pow(0.947867299*(color+vec3f(0.055)),vec3f(2.4));return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3f(0.04045)));}\nfn toGammaSpaceExact(color: vec3f)->vec3f\n{let nearZeroSection: vec3f=12.92*color;let remainingSection: vec3f=1.055*pow(color,vec3f(0.41666))-vec3f(0.055);return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3f(0.0031308)));}\n#endif\nfn toLinearSpace(color: f32)->f32\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nvar nearZeroSection=0.0773993808*color;var remainingSection=pow(0.947867299*(color+0.055),2.4);return select(remainingSection,nearZeroSection,color<=0.04045);\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nfn toLinearSpaceVec3(color: vec3f)->vec3f\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3f(LinearEncodePowerApprox));\n#endif\n}\nfn toLinearSpaceVec4(color: vec4<f32>)->vec4<f32>\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4f(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4f(pow(color.rgb,vec3f(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfn toGammaSpace(color: vec4<f32>)->vec4<f32>\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4<f32>(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4<f32>(pow(color.rgb,vec3f(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfn toGammaSpaceVec3(color: vec3f)->vec3f\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3f(GammaEncodePowerApprox));\n#endif\n}\nfn squareVec3(value: vec3f)->vec3f\n{return value*value;}\nfn pow5(value: f32)->f32 {let sq: f32=value*value;return sq*sq*value;}\nfn getLuminance(color: vec3f)->f32\n{return saturate(dot(color,LuminanceEncodeApprox));}\nfn getRand(seed: vec2<f32>)->f32 {return fract(sin(dot(seed.xy ,vec2<f32>(12.9898,78.233)))*43758.5453);}\nfn dither(seed: vec2<f32>,varianceAmount: f32)->f32 {let rand: f32=getRand(seed);let normVariance: f32=varianceAmount/255.0;let dither: f32=mix(-normVariance,normVariance,rand);return dither;}\nconst rgbdMaxRange: f32=255.0;fn toRGBD(color: vec3f)->vec4<f32> {let maxRGB: f32=max(max(color.r,max(color.g,color.b)),Epsilon);var D: f32 =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);var rgb: vec3f =color.rgb*D;rgb=toGammaSpaceVec3(rgb);return vec4<f32>(saturateVec3(rgb),D);}\nfn fromRGBD(rgbd: vec4<f32>)->vec3f {let rgb=toLinearSpaceVec3(rgbd.rgb);return rgb/rgbd.a;}\nfn parallaxCorrectNormal(vertexPos: vec3f,origVec: vec3f,cubeSize: vec3f,cubePos: vec3f)->vec3f {let invOrigVec: vec3f=vec3f(1.)/origVec;let halfSize: vec3f=cubeSize*0.5;let intersecAtMaxPlane: vec3f=(cubePos+halfSize-vertexPos)*invOrigVec;let intersecAtMinPlane: vec3f=(cubePos-halfSize-vertexPos)*invOrigVec;let largestIntersec: vec3f=max(intersecAtMaxPlane,intersecAtMinPlane);let distance: f32=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);let intersectPositionWS: vec3f=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\nfn equirectangularToCubemapDirection(uv : vec2f)->vec3f {var longitude : f32=uv.x*TWO_PI-PI;var latitude : f32=HALF_PI-uv.y*PI;var direction : vec3f;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}\nfn sqrtClamped(value: f32)->f32 {return sqrt(max(value,0.));}\nfn avg(value: vec3f)->f32 {return dot(value,vec3f(0.333333333));}\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},81482:(e,t,n)=>{var r=n(69610);const s="logDepthVertex",a="#ifdef LOGARITHMICDEPTH\nvertexOutputs.vFragmentDepth=1.0+vertexOutputs.position.w;vertexOutputs.position.z=log2(max(0.000001,vertexOutputs.vFragmentDepth))*uniforms.logarithmicDepthConstant;\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},85197:(e,t,n)=>{var r=n(69610);const s="clipPlaneVertex",a="#ifdef CLIPPLANE\nvertexOutputs.fClipDistance=dot(worldPos,uniforms.vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nvertexOutputs.fClipDistance2=dot(worldPos,uniforms.vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nvertexOutputs.fClipDistance3=dot(worldPos,uniforms.vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nvertexOutputs.fClipDistance4=dot(worldPos,uniforms.vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nvertexOutputs.fClipDistance5=dot(worldPos,uniforms.vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nvertexOutputs.fClipDistance6=dot(worldPos,uniforms.vClipPlane6);\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},86560:(e,t,n)=>{var r=n(69610);const s="fogVertexDeclaration",a="#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a)},90203:(e,t,n)=>{var r=n(85530),s=n(95616),a=n(79923),i=n(51137),o=n(42564);r.e.prototype.thinInstanceAdd=function(e,t=!0){if(!this.getScene().getEngine().getCaps().instancedArrays)return i.V.Error("Thin Instances are not supported on this device as Instanced Array extension not supported"),-1;this._thinInstanceUpdateBufferSize("matrix",Array.isArray(e)?e.length:1);const n=this._thinInstanceDataStorage.instancesCount;if(Array.isArray(e))for(let n=0;n<e.length;++n)this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,e[n],n===e.length-1&&t);else this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,e,t);return n},r.e.prototype.thinInstanceAddSelf=function(e=!0){return this.thinInstanceAdd(a.uq.IdentityReadOnly,e)},r.e.prototype.thinInstanceRegisterAttribute=function(e,t){e===s.R.ColorKind&&(e=s.R.ColorInstanceKind),this.removeVerticesData(e),this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.strides[e]=t,this._userThinInstanceBuffersStorage.sizes[e]=t*Math.max(32,this._thinInstanceDataStorage.instancesCount),this._userThinInstanceBuffersStorage.data[e]=new Float32Array(this._userThinInstanceBuffersStorage.sizes[e]),this._userThinInstanceBuffersStorage.vertexBuffers[e]=new s.R(this.getEngine(),this._userThinInstanceBuffersStorage.data[e],e,!0,!1,t,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e])},r.e.prototype.thinInstanceSetMatrixAt=function(e,t,n=!0){if(!this._thinInstanceDataStorage.matrixData||e>=this._thinInstanceDataStorage.instancesCount)return!1;const r=this._thinInstanceDataStorage.matrixData;return t.copyToArray(r,16*e),this._thinInstanceDataStorage.worldMatrices&&(this._thinInstanceDataStorage.worldMatrices[e]=t),n&&(this.thinInstanceBufferUpdated("matrix"),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)),!0},r.e.prototype.thinInstanceSetAttributeAt=function(e,t,n,r=!0){return e===s.R.ColorKind&&(e=s.R.ColorInstanceKind),!(!this._userThinInstanceBuffersStorage||!this._userThinInstanceBuffersStorage.data[e]||t>=this._thinInstanceDataStorage.instancesCount)&&(this._thinInstanceUpdateBufferSize(e,0),this._userThinInstanceBuffersStorage.data[e].set(n,t*this._userThinInstanceBuffersStorage.strides[e]),r&&this.thinInstanceBufferUpdated(e),!0)},Object.defineProperty(r.e.prototype,"thinInstanceCount",{get:function(){return this._thinInstanceDataStorage.instancesCount},set:function(e){const t=this._thinInstanceDataStorage.matrixData??this.source?._thinInstanceDataStorage.matrixData;e<=(t?t.length/16:0)&&(this._thinInstanceDataStorage.instancesCount=e)},enumerable:!0,configurable:!0}),r.e.prototype._thinInstanceCreateMatrixBuffer=function(e,t,n=!0){const r=new s.h(this.getEngine(),t,!n,16,!1,!0);for(let t=0;t<4;t++)this.setVerticesBuffer(r.createVertexBuffer(e+t,4*t,4));return r},r.e.prototype.thinInstanceSetBuffer=function(e,t,n=0,r=!0){n=n||16,"matrix"===e?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=null,this._thinInstanceDataStorage.matrixBufferSize=t?t.length:32*n,this._thinInstanceDataStorage.matrixData=t,this._thinInstanceDataStorage.worldMatrices=null,null!==t?(this._thinInstanceDataStorage.instancesCount=t.length/n,this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",t,r),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)):(this._thinInstanceDataStorage.instancesCount=0,this.doNotSyncBoundingInfo||this.refreshBoundingInfo())):"previousMatrix"===e?(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=null,this._thinInstanceDataStorage.previousMatrixData=t,null!==t&&(this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",t,r))):(e===s.R.ColorKind&&(e=s.R.ColorInstanceKind),null===t?this._userThinInstanceBuffersStorage?.data[e]&&(this.removeVerticesData(e),delete this._userThinInstanceBuffersStorage.data[e],delete this._userThinInstanceBuffersStorage.strides[e],delete this._userThinInstanceBuffersStorage.sizes[e],delete this._userThinInstanceBuffersStorage.vertexBuffers[e]):(this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.data[e]=t,this._userThinInstanceBuffersStorage.strides[e]=n,this._userThinInstanceBuffersStorage.sizes[e]=t.length,this._userThinInstanceBuffersStorage.vertexBuffers[e]=new s.R(this.getEngine(),t,e,!r,!1,n,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e])))},r.e.prototype.thinInstanceBufferUpdated=function(e){"matrix"===e?(this.thinInstanceAllowAutomaticStaticBufferRecreation&&this._thinInstanceDataStorage.matrixBuffer&&!this._thinInstanceDataStorage.matrixBuffer.isUpdatable()&&this._thinInstanceRecreateBuffer(e),this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData,0,this._thinInstanceDataStorage.instancesCount)):"previousMatrix"===e?(this.thinInstanceAllowAutomaticStaticBufferRecreation&&this._thinInstanceDataStorage.previousMatrixBuffer&&!this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()&&this._thinInstanceRecreateBuffer(e),this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData,0,this._thinInstanceDataStorage.instancesCount)):(e===s.R.ColorKind&&(e=s.R.ColorInstanceKind),this._userThinInstanceBuffersStorage?.vertexBuffers[e]&&(this.thinInstanceAllowAutomaticStaticBufferRecreation&&!this._userThinInstanceBuffersStorage.vertexBuffers[e].isUpdatable()&&this._thinInstanceRecreateBuffer(e),this._userThinInstanceBuffersStorage.vertexBuffers[e].updateDirectly(this._userThinInstanceBuffersStorage.data[e],0)))},r.e.prototype.thinInstancePartialBufferUpdate=function(e,t,n){"matrix"===e?this._thinInstanceDataStorage.matrixBuffer&&this._thinInstanceDataStorage.matrixBuffer.updateDirectly(t,n):(e===s.R.ColorKind&&(e=s.R.ColorInstanceKind),this._userThinInstanceBuffersStorage?.vertexBuffers[e]&&this._userThinInstanceBuffersStorage.vertexBuffers[e].updateDirectly(t,n))},r.e.prototype.thinInstanceGetWorldMatrices=function(){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return[];const e=this._thinInstanceDataStorage.matrixData;if(!this._thinInstanceDataStorage.worldMatrices){this._thinInstanceDataStorage.worldMatrices=[];for(let t=0;t<this._thinInstanceDataStorage.instancesCount;++t)this._thinInstanceDataStorage.worldMatrices[t]=a.uq.FromArray(e,16*t)}return this._thinInstanceDataStorage.worldMatrices},r.e.prototype.thinInstanceRefreshBoundingInfo=function(e=!1,t=!1,n=!1){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return;const r=this._thinInstanceDataStorage.boundingVectors;if(e||!this.rawBoundingInfo){r.length=0,this.refreshBoundingInfo(t,n);const e=this.getBoundingInfo();this.rawBoundingInfo=new o.j(e.minimum,e.maximum)}const s=this.getBoundingInfo(),i=this._thinInstanceDataStorage.matrixData;if(0===r.length)for(let e=0;e<s.boundingBox.vectors.length;++e)r.push(s.boundingBox.vectors[e].clone());a.AA.Vector3[0].setAll(Number.POSITIVE_INFINITY),a.AA.Vector3[1].setAll(Number.NEGATIVE_INFINITY);for(let e=0;e<this._thinInstanceDataStorage.instancesCount;++e){a.uq.FromArrayToRef(i,16*e,a.AA.Matrix[0]);for(let e=0;e<r.length;++e)a.Pq.TransformCoordinatesToRef(r[e],a.AA.Matrix[0],a.AA.Vector3[2]),a.AA.Vector3[0].minimizeInPlace(a.AA.Vector3[2]),a.AA.Vector3[1].maximizeInPlace(a.AA.Vector3[2])}s.reConstruct(a.AA.Vector3[0],a.AA.Vector3[1]),this._updateBoundingInfo()},r.e.prototype._thinInstanceRecreateBuffer=function(e,t=!0){"matrix"===e?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",this._thinInstanceDataStorage.matrixData,t)):"previousMatrix"===e?this._scene.needsPreviousWorldMatrices&&(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",this._thinInstanceDataStorage.previousMatrixData??this._thinInstanceDataStorage.matrixData,t)):(e===s.R.ColorKind&&(e=s.R.ColorInstanceKind),this._userThinInstanceBuffersStorage.vertexBuffers[e]?.dispose(),this._userThinInstanceBuffersStorage.vertexBuffers[e]=new s.R(this.getEngine(),this._userThinInstanceBuffersStorage.data[e],e,!t,!1,this._userThinInstanceBuffersStorage.strides[e],!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e]))},r.e.prototype._thinInstanceUpdateBufferSize=function(e,t=1){e===s.R.ColorKind&&(e=s.R.ColorInstanceKind);const n="matrix"===e;if(!(n||this._userThinInstanceBuffersStorage&&this._userThinInstanceBuffersStorage.strides[e]))return;const r=n?16:this._userThinInstanceBuffersStorage.strides[e],a=n?this._thinInstanceDataStorage.matrixBufferSize:this._userThinInstanceBuffersStorage.sizes[e];let i=n?this._thinInstanceDataStorage.matrixData:this._userThinInstanceBuffersStorage.data[e];const o=(this._thinInstanceDataStorage.instancesCount+t)*r;let c=a;for(;c<o;)c*=2;if(!i||a!=c){if(i){const e=new Float32Array(c);e.set(i,0),i=e}else i=new Float32Array(c);n?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",i,!1),this._thinInstanceDataStorage.matrixData=i,this._thinInstanceDataStorage.matrixBufferSize=c,this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",i,!1))):(this._userThinInstanceBuffersStorage.vertexBuffers[e]?.dispose(),this._userThinInstanceBuffersStorage.data[e]=i,this._userThinInstanceBuffersStorage.sizes[e]=c,this._userThinInstanceBuffersStorage.vertexBuffers[e]=new s.R(this.getEngine(),i,e,!0,!1,r,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e]))}},r.e.prototype._thinInstanceInitializeUserStorage=function(){this._userThinInstanceBuffersStorage||(this._userThinInstanceBuffersStorage={data:{},sizes:{},vertexBuffers:{},strides:{}})},r.e.prototype._disposeThinInstanceSpecificData=function(){this._thinInstanceDataStorage?.matrixBuffer&&(this._thinInstanceDataStorage.matrixBuffer.dispose(),this._thinInstanceDataStorage.matrixBuffer=null),this._thinInstanceDataStorage?.previousMatrixBuffer&&(this._thinInstanceDataStorage.previousMatrixBuffer.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=null)}},93226:(e,t,n)=>{var r=n(69610);const s="logDepthDeclaration",a="#ifdef LOGARITHMICDEPTH\nuniform logarithmicDepthConstant: f32;varying vFragmentDepth: f32;\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},93243:(e,t,n)=>{var r=n(69610);const s="fogFragment",a="#ifdef FOG\nvar fog: f32=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor= vec4f(mix(uniforms.vFogColor,color.rgb,fog),color.a);\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},96041:(e,t,n)=>{n.d(t,{I:()=>s});var r=n(82781);class s extends r.g{constructor(e,t,n,s,a,i=!0,o=!1,c=3,l=0,u,f,h){super(null,a,!i,o,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,u),this.format=s,this._engine&&(this._engine._caps.textureFloatLinearFiltering||1!==l||(c=1),this._engine._caps.textureHalfFloatLinearFiltering||2!==l||(c=1),this._texture=this._engine.createRawTexture(e,t,n,s,i,o,c,null,l,u??0,f??!1),this.wrapU=r.g.CLAMP_ADDRESSMODE,this.wrapV=r.g.CLAMP_ADDRESSMODE,this._waitingForData=!!h&&!e)}update(e){this._getEngine().updateRawTexture(this._texture,e,this._texture.format,this._texture.invertY,null,this._texture.type,this._texture._useSRGBBuffer),this._waitingForData=!1}clone(){if(!this._texture)return super.clone();const e=new s(null,this.getSize().width,this.getSize().height,this.format,this.getScene(),this._texture.generateMipMaps,this._invertY,this.samplingMode,this._texture.type,this._texture._creationFlags,this._useSRGBBuffer);return e._texture=this._texture,this._texture.incrementReferences(),e}isReady(){return super.isReady()&&!this._waitingForData}static CreateLuminanceTexture(e,t,n,r,a=!0,i=!1,o=3){return new s(e,t,n,1,r,a,i,o)}static CreateLuminanceAlphaTexture(e,t,n,r,a=!0,i=!1,o=3){return new s(e,t,n,2,r,a,i,o)}static CreateAlphaTexture(e,t,n,r,a=!0,i=!1,o=3){return new s(e,t,n,0,r,a,i,o)}static CreateRGBTexture(e,t,n,r,a=!0,i=!1,o=3,c=0,l=0,u=!1){return new s(e,t,n,4,r,a,i,o,c,l,u)}static CreateRGBATexture(e,t,n,r,a=!0,i=!1,o=3,c=0,l=0,u=!1,f=!1){return new s(e,t,n,5,r,a,i,o,c,l,u,f)}static CreateRGBAStorageTexture(e,t,n,r,a=!0,i=!1,o=3,c=0,l=!1){return new s(e,t,n,5,r,a,i,o,c,1,l)}static CreateRTexture(e,t,n,a,i=!0,o=!1,c=r.g.TRILINEAR_SAMPLINGMODE,l=1){return new s(e,t,n,6,a,i,o,c,l)}static CreateRStorageTexture(e,t,n,a,i=!0,o=!1,c=r.g.TRILINEAR_SAMPLINGMODE,l=1){return new s(e,t,n,6,a,i,o,c,l,1)}}},96467:(e,t,n)=>{var r=n(69610);const s="meshUboDeclaration",a="#ifdef WEBGL2\nuniform mat4 world;uniform float visibility;\n#else\nlayout(std140,column_major) uniform;uniform Mesh\n{mat4 world;float visibility;};\n#endif\n#define WORLD_UBO\n";r.l.IncludesShadersStore[s]||(r.l.IncludesShadersStore[s]=a)},97715:(e,t,n)=>{var r=n(69610);const s="clipPlaneFragment",a="#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fragmentInputs.fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fragmentInputs.fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fragmentInputs.fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fragmentInputs.fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fragmentInputs.fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fragmentInputs.fClipDistance6>0.0)\n{discard;}\n#endif\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)},98327:(e,t,n)=>{var r=n(69610);const s="sceneUboDeclaration",a="struct Scene {viewProjection : mat4x4<f32>,\n#ifdef MULTIVIEW\nviewProjectionR : mat4x4<f32>,\n#endif \nview : mat4x4<f32>,\nprojection : mat4x4<f32>,\nvEyePosition : vec4<f32>,};\n#define SCENE_UBO\nvar<uniform> scene : Scene;\n";r.l.IncludesShadersStoreWGSL[s]||(r.l.IncludesShadersStoreWGSL[s]=a)}}]);