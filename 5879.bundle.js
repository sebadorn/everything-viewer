"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[5879],{25879:(t,e,i)=>{i.r(e),i.d(e,{AnimationGroup:()=>b,TargetedAnimation:()=>f});var n=i(7540),a=i(99848),s=i(6315),o=i(7503),r=i(36504),h=i(79923);class l{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(t,e,i,a){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=e,this._target=t,this._scene=i,this._host=a,this._activeTargets=[],e._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===n.X5.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=h.uq.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const t={frame:0,value:this._minValue};this._keys.splice(0,0,t)}if(this._target instanceof Array){let t=0;for(const e of this._target)this._preparePath(e,t),this._getOriginalValues(t),t++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const s=e.getEvents();if(s&&s.length>0)for(const t of s)this._events.push(t._clone());this._enableBlending=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(t,e=0){const i=this._animation.targetPropertyPath;if(i.length>1){let n=t;for(let t=0;t<i.length-1;t++){const e=i[t];if(n=n[e],void 0===n)throw new Error(`Invalid property (${e}) in property path (${i.join(".")})`)}this._targetPath=i[i.length-1],this._activeTargets[e]=n}else this._targetPath=i[0],this._activeTargets[e]=t;if(void 0===this._activeTargets[e][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${i.join(".")})`)}get animation(){return this._animation}reset(t=!1){if(t)if(this._target instanceof Array){let t=0;for(const e of this._target)void 0!==this._originalValue[t]&&this._setValue(e,this._activeTargets[t],this._originalValue[t],-1,t),t++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let t=0;t<this._events.length;t++)this._events[t].isDone=!1}isStopped(){return this._stopped}dispose(){const t=this._animation.runtimeAnimations.indexOf(this);t>-1&&this._animation.runtimeAnimations.splice(t,1)}setValue(t,e){if(this._targetIsArray)for(let i=0;i<this._target.length;i++){const n=this._target[i];this._setValue(n,this._activeTargets[i],t,e,i)}else this._setValue(this._target,this._directTarget,t,e,0)}_getOriginalValues(t=0){let e;const i=this._activeTargets[t];e=i.getLocalMatrix&&"_matrix"===this._targetPath?i.getLocalMatrix():i[this._targetPath],e&&e.clone?this._originalValue[t]=e.clone():this._originalValue[t]=e}_registerTargetForLateAnimationBinding(t,e){const i=t.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(i),i._lateAnimationHolders||(i._lateAnimationHolders={}),i._lateAnimationHolders[t.targetPath]||(i._lateAnimationHolders[t.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:e}),t.isAdditive?(i._lateAnimationHolders[t.targetPath].additiveAnimations.push(t),i._lateAnimationHolders[t.targetPath].totalAdditiveWeight+=t.weight):(i._lateAnimationHolders[t.targetPath].animations.push(t),i._lateAnimationHolders[t.targetPath].totalWeight+=t.weight)}_setValue(t,e,i,a,s){if(this._currentActiveTarget=e,this._weight=a,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const t=e[this._targetPath];t.clone?this._originalBlendValue=t.clone():this._originalBlendValue=t}this._originalBlendValue.m?n.X5.AllowMatrixDecomposeForInterpolation?this._currentValue?h.uq.DecomposeLerpToRef(this._originalBlendValue,i,this._blendingFactor,this._currentValue):this._currentValue=h.uq.DecomposeLerp(this._originalBlendValue,i,this._blendingFactor):this._currentValue?h.uq.LerpToRef(this._originalBlendValue,i,this._blendingFactor,this._currentValue):this._currentValue=h.uq.Lerp(this._originalBlendValue,i,this._blendingFactor):this._currentValue=n.X5._UniversalLerp(this._originalBlendValue,i,this._blendingFactor);const a=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=a}else this._currentValue?this._currentValue.copyFrom?this._currentValue.copyFrom(i):this._currentValue=i:this._currentValue=i?.clone?i.clone():i;-1!==a?this._registerTargetForLateAnimationBinding(this,this._originalValue[s]):this._animationState.loopMode===n.X5.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[s],e[this._targetPath]):e[this._targetPath]=this._originalValue[s]+this._currentValue:e[this._targetPath]=this._currentValue,t.markAsDirty&&t.markAsDirty(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(t,e=-1){const i=this._animation.getKeys();t<i[0].frame?t=i[0].frame:t>i[i.length-1].frame&&(t=i[i.length-1].frame);const n=this._events;if(n.length)for(let e=0;e<n.length;e++)n[e].onlyOnce||(n[e].isDone=n[e].frame<t);this._currentFrame=t;const a=this._animation._interpolate(t,this._animationState);this.setValue(a,e)}_prepareForSpeedRatioChange(t){const e=this._previousElapsedTime*(this._animation.framePerSecond*t)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-e}animate(t,e,i,a,s,o=-1){const r=this._animation,h=r.targetPropertyPath;if(!h||h.length<1)return this._stopped=!0,!1;let l,m=!0;const _=this._events;let g=0;if(this._coreRuntimeAnimation)g=i-e,l=this._coreRuntimeAnimation.currentFrame,this._currentFrame=l,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{let o;(e<this._minFrame||e>this._maxFrame)&&(e=this._minFrame),(i<this._minFrame||i>this._maxFrame)&&(i=this._maxFrame),g=i-e;let h=t*(r.framePerSecond*s)/1e3+this._absoluteFrameOffset,d=0,u=!1;const c=a&&this._animationState.loopMode===n.X5.ANIMATIONLOOPMODE_YOYO;if(c){const t=(h-e)/g,i=Math.sin(t*Math.PI);h=Math.abs(i)*g+e;const n=i>=0?1:-1;this._yoyoDirection!==n&&(u=!0),this._yoyoDirection=n}if(this._previousElapsedTime=t,this._previousAbsoluteFrame=h,!a&&i>=e&&(h>=g&&s>0||h<=0&&s<0))m=!1,d=r._getKeyValue(this._maxValue);else if(!a&&e>=i&&(h<=g&&s<0||h>=0&&s>0))m=!1,d=r._getKeyValue(this._minValue);else if(this._animationState.loopMode!==n.X5.ANIMATIONLOOPMODE_CYCLE){const t=i.toString()+e.toString();if(!this._offsetsCache[t]){this._animationState.repeatCount=0,this._animationState.loopMode=n.X5.ANIMATIONLOOPMODE_CYCLE;const a=r._interpolate(e,this._animationState),s=r._interpolate(i,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),r.dataType){case n.X5.ANIMATIONTYPE_FLOAT:this._offsetsCache[t]=s-a;break;case n.X5.ANIMATIONTYPE_QUATERNION:case n.X5.ANIMATIONTYPE_VECTOR3:case n.X5.ANIMATIONTYPE_VECTOR2:case n.X5.ANIMATIONTYPE_SIZE:case n.X5.ANIMATIONTYPE_COLOR3:this._offsetsCache[t]=s.subtract(a)}this._highLimitsCache[t]=s}d=this._highLimitsCache[t],o=this._offsetsCache[t]}if(void 0===o)switch(r.dataType){case n.X5.ANIMATIONTYPE_FLOAT:o=0;break;case n.X5.ANIMATIONTYPE_QUATERNION:o=n.ov;break;case n.X5.ANIMATIONTYPE_VECTOR3:o=n.mA;break;case n.X5.ANIMATIONTYPE_VECTOR2:o=n.fY;break;case n.X5.ANIMATIONTYPE_SIZE:o=n.bn;break;case n.X5.ANIMATIONTYPE_COLOR3:o=n.wF;break;case n.X5.ANIMATIONTYPE_COLOR4:o=n.pO}if(this._host&&this._host.syncRoot){const t=this._host.syncRoot;l=e+g*((t.masterFrame-t.fromFrame)/(t.toFrame-t.fromFrame))}else l=h>0&&e>i||h<0&&e<i?m&&0!==g?i+h%g:e:m&&0!==g?e+h%g:i;if(!c&&(s>0&&this.currentFrame>l||s<0&&this.currentFrame<l)||c&&u){this._onLoop();for(let t=0;t<_.length;t++)_[t].onlyOnce||(_[t].isDone=!1);this._animationState.key=s>0?0:r.getKeys().length-1}this._currentFrame=l,this._animationState.repeatCount=0===g?0:h/g|0,this._animationState.highLimitValue=d,this._animationState.offsetValue=o}const d=r._interpolate(l,this._animationState);if(this.setValue(d,o),_.length)for(let t=0;t<_.length;t++)if(g>=0&&l>=_[t].frame&&_[t].frame>=e||g<0&&l<=_[t].frame&&_[t].frame<=e){const e=_[t];e.isDone||(e.onlyOnce&&(_.splice(t,1),t--),e.isDone=!0,e.action(l))}return m||(this._stopped=!0),m}}var m=i(76237);class _{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(t){this._weight=-1!==t?Math.min(Math.max(t,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(t){for(let e=0;e<this._runtimeAnimations.length;e++){this._runtimeAnimations[e]._prepareForSpeedRatioChange(t)}this._speedRatio=t,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(t,e,i=0,n=100,s=!1,o=1,r,h,l,m=!1,_=0){this.target=e,this.fromFrame=i,this.toFrame=n,this.loopAnimation=s,this.onAnimationEnd=r,this.onAnimationLoop=l,this.isAdditive=m,this.playOrder=_,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this._paused=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new a.cP,this.onAnimationLoopObservable=new a.cP,this._scene=t,h&&this.appendAnimations(e,h),this._speedRatio=o,t._activeAnimatables.push(this)}syncWith(t){if(this._syncRoot=t,t){const t=this._scene._activeAnimatables.indexOf(this);t>-1&&(this._scene._activeAnimatables.splice(t,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(t,e){for(let i=0;i<e.length;i++){const n=e[i],a=new l(t,n,this._scene,this);a._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(a)}}getAnimationByTargetProperty(t){const e=this._runtimeAnimations;for(let i=0;i<e.length;i++)if(e[i].animation.targetProperty===t)return e[i].animation;return null}getRuntimeAnimationByTargetProperty(t){const e=this._runtimeAnimations;for(let i=0;i<e.length;i++)if(e[i].animation.targetProperty===t)return e[i];return null}reset(){const t=this._runtimeAnimations;for(let e=0;e<t.length;e++)t[e].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(t){const e=this._runtimeAnimations;for(let i=0;i<e.length;i++)e[i].animation.enableBlending=!0,e[i].animation.blendingSpeed=t}disableBlending(){const t=this._runtimeAnimations;for(let e=0;e<t.length;e++)t[e].animation.enableBlending=!1}goToFrame(t,e=!1){const i=this._runtimeAnimations;if(i[0]){const e=i[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??i[0].currentFrame;const n=0===this.speedRatio?0:(t-this._frameToSyncFromJump)/e*1e3/this.speedRatio;this._manualJumpDelay=-n}for(let n=0;n<i.length;n++)i[n].goToFrame(t,e?this._weight:-1);this._goToFrame=t}get paused(){return this._paused}pause(){this._paused||(this._paused=!0)}restart(){this._paused=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(t,e,i=!1,n=!1){if(t||e){const a=this._scene._activeAnimatables.indexOf(this);if(a>-1){const s=this._runtimeAnimations;for(let i=s.length-1;i>=0;i--){const n=s[i];t&&n.animation.name!=t||(e&&!e(n.target)||(n.dispose(),s.splice(i,1)))}0==s.length&&(i||this._scene._activeAnimatables.splice(a,1),n||this._raiseOnAnimationEnd())}}else{const t=this._scene._activeAnimatables.indexOf(this);if(t>-1){i||this._scene._activeAnimatables.splice(t,1);const e=this._runtimeAnimations;for(let t=0;t<e.length;t++)e[t].dispose();this._runtimeAnimations.length=0,n||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise(t=>{this.onAnimationEndObservable.add(()=>{t(this)},void 0,void 0,this,!0)})}_animate(t){if(this._paused)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=t),!0;if(null===this._localDelayOffset?(this._localDelayOffset=t,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=t-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,!_.ProcessPausedAnimatables&&0===this._weight&&0===this._previousWeight)return!0;this._previousWeight=this._weight;let e=!1;const i=this._runtimeAnimations;let n;for(n=0;n<i.length;n++){const a=i[n].animate(t-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);e=e||a}if(this.animationStarted=e,!e){if(this.disposeOnEnd)for(n=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(n,1),n=0;n<i.length;n++)i[n].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return e}}function g(t){if(0===t.totalWeight&&0===t.totalAdditiveWeight)return t.originalValue;let e=1;const i=h.AA.Vector3[0],n=h.AA.Vector3[1],a=h.AA.Quaternion[0];let s=0;const o=t.animations[0],r=t.originalValue;let l=1,m=!1;if(t.totalWeight<1)l=1-t.totalWeight,r.decompose(n,a,i);else{if(s=1,e=t.totalWeight,l=o.weight/e,1==l){if(!t.totalAdditiveWeight)return o.currentValue;m=!0}o.currentValue.decompose(n,a,i)}if(!m){n.scaleInPlace(l),i.scaleInPlace(l),a.scaleInPlace(l);for(let o=s;o<t.animations.length;o++){const s=t.animations[o];if(0===s.weight)continue;l=s.weight/e;const r=h.AA.Vector3[2],m=h.AA.Vector3[3],_=h.AA.Quaternion[1];s.currentValue.decompose(m,_,r),m.scaleAndAddToRef(l,n),_.scaleAndAddToRef(h.PT.Dot(a,_)>0?l:-l,a),r.scaleAndAddToRef(l,i)}a.normalize()}for(let e=0;e<t.additiveAnimations.length;e++){const s=t.additiveAnimations[e];if(0===s.weight)continue;const o=h.AA.Vector3[2],r=h.AA.Vector3[3],l=h.AA.Quaternion[1];s.currentValue.decompose(r,l,o),r.multiplyToRef(n,r),h.Pq.LerpToRef(n,r,s.weight,n),a.multiplyToRef(l,l),h.PT.SlerpToRef(a,l,s.weight,a),o.scaleAndAddToRef(s.weight,i)}const _=o?o._animationState.workValue:h.AA.Matrix[0].clone();return h.uq.ComposeToRef(n,a,i,_),_}function d(t,e){if(0===t.totalWeight&&0===t.totalAdditiveWeight)return e;const i=t.animations[0],n=t.originalValue;let a=e;if(0===t.totalWeight&&t.totalAdditiveWeight>0)a.copyFrom(n);else if(1===t.animations.length){if(h.PT.SlerpToRef(n,i.currentValue,Math.min(1,t.totalWeight),a),0===t.totalAdditiveWeight)return a}else if(t.animations.length>1){let i,s,o=1;if(t.totalWeight<1){const e=1-t.totalWeight;i=[],s=[],i.push(n),s.push(e)}else{if(2===t.animations.length&&(h.PT.SlerpToRef(t.animations[0].currentValue,t.animations[1].currentValue,t.animations[1].weight/t.totalWeight,e),0===t.totalAdditiveWeight))return e;i=[],s=[],o=t.totalWeight}for(let e=0;e<t.animations.length;e++){const n=t.animations[e];i.push(n.currentValue),s.push(n.weight/o)}let r=0;for(let t=0;t<i.length;)t?(r+=s[t],h.PT.SlerpToRef(a,i[t],s[t]/r,a),t++):(h.PT.SlerpToRef(i[t],i[t+1],s[t+1]/(s[t]+s[t+1]),e),a=e,r=s[t]+s[t+1],t+=2)}for(let e=0;e<t.additiveAnimations.length;e++){const i=t.additiveAnimations[e];0!==i.weight&&(a.multiplyToRef(i.currentValue,h.AA.Quaternion[0]),h.PT.SlerpToRef(a,h.AA.Quaternion[0],i.weight,a))}return a}_.ProcessPausedAnimatables=!1;var u,c,p=i(48802);u=p.Z,(c=r.$)&&(c.prototype.copyAnimationRange=function(t,e,i,a=!1,s=null){0===this.animations.length&&(this.animations.push(new n.X5(this.name,"_matrix",t.animations[0].framePerSecond,n.X5.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const o=t.animations[0].getRange(e);if(!o)return!1;const r=o.from,h=o.to,l=t.animations[0].getKeys(),m=t.length,_=t.getParent(),g=this.getParent(),d=a&&_&&m&&this.length&&m!==this.length,u=d&&g&&_?g.length/_.length:1,c=a&&!g&&s&&(1!==s.x||1!==s.y||1!==s.z),p=this.animations[0].getKeys();let A,f,b;for(let t=0,e=l.length;t<e;t++)A=l[t],A.frame>=r&&A.frame<=h&&(a?(b=A.value.clone(),d?(f=b.getTranslation(),b.setTranslation(f.scaleInPlace(u))):c&&s?(f=b.getTranslation(),b.setTranslation(f.multiplyInPlace(s))):b=A.value):b=A.value,p.push({frame:A.frame+i,value:b}));return this.animations[0].createRange(e,r+i,h+i),!0}),u&&(u.prototype._animate=function(t){if(!this.animationsEnabled)return;const e=m.j.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=e}this.deltaTime=void 0!==t?t:this.useConstantAnimationDeltaTime?16:(e-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=e;const i=this._activeAnimatables;if(0===i.length)return;this._animationTime+=this.deltaTime;const a=this._animationTime;for(let t=0;t<i.length;t++){const e=i[t];!e._animate(a)&&e.disposeOnEnd&&t--}!function(t){if(t._registeredForLateAnimationBindings.length){for(let e=0;e<t._registeredForLateAnimationBindings.length;e++){const i=t._registeredForLateAnimationBindings.data[e];for(const t in i._lateAnimationHolders){const e=i._lateAnimationHolders[t],a=e.animations[0],s=e.originalValue;if(null==s)continue;const o=n.X5.AllowMatrixDecomposeForInterpolation&&s.m;let r=i[t];if(o)r=g(e);else if(void 0!==s.w)r=d(e,r||h.PT.Identity());else{let t=0,i=1;const o=a&&a._animationState.loopMode===n.X5.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(e.totalWeight<1)r=o?s.clone?s.clone():s:a&&s.scale?s.scale(1-e.totalWeight):a?s*(1-e.totalWeight):s.clone?s.clone():s;else if(a){i=e.totalWeight;const n=a.weight/i;r=1!==n?a.currentValue.scale?a.currentValue.scale(n):a.currentValue*n:a.currentValue,o&&(r.addToRef?r.addToRef(s,r):r+=s),t=1}for(let n=t;n<e.animations.length;n++){const t=e.animations[n],a=t.weight/i;a&&(t.currentValue.scaleAndAddToRef?t.currentValue.scaleAndAddToRef(a,r):r+=t.currentValue*a)}for(let t=0;t<e.additiveAnimations.length;t++){const i=e.additiveAnimations[t],n=i.weight;n&&(i.currentValue.scaleAndAddToRef?i.currentValue.scaleAndAddToRef(n,r):r+=i.currentValue*n)}}i[t]=r}i._lateAnimationHolders={}}t._registeredForLateAnimationBindings.reset()}}(this)},u.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort((t,e)=>t.playOrder-e.playOrder)},u.prototype.beginWeightedAnimation=function(t,e,i,n=1,a,s=1,o,r,h,l,m=!1){const _=this.beginAnimation(t,e,i,a,s,o,r,!1,h,l,m);return _.weight=n,_},u.prototype.beginAnimation=function(t,e,i,n,a=1,s,o,r=!0,h,l,m=!1){if(a<0){const t=e;e=i,i=t,a=-a}e>i&&(a=-a),r&&this.stopAnimation(t,void 0,h),o||(o=new _(this,t,e,i,n,a,s,void 0,l,m));const g=!h||h(t);if(t.animations&&g&&o.appendAnimations(t,t.animations),t.getAnimatables){const m=t.getAnimatables();for(let t=0;t<m.length;t++)this.beginAnimation(m[t],e,i,n,a,s,o,r,h,l)}return o.reset(),o},u.prototype.beginHierarchyAnimation=function(t,e,i,n,a,s=1,o,r,h=!0,l,m,_=!1){const g=t.getDescendants(e),d=[];d.push(this.beginAnimation(t,i,n,a,s,o,r,h,l,void 0,_));for(const t of g)d.push(this.beginAnimation(t,i,n,a,s,o,r,h,l,void 0,_));return d},u.prototype.beginDirectAnimation=function(t,e,i,n,a,s=1,o,r,h=!1){if(s<0){const t=i;i=n,n=t,s=-s}return i>n&&(s=-s),new _(this,t,i,n,a,s,o,e,r,h)},u.prototype.beginDirectHierarchyAnimation=function(t,e,i,n,a,s,o,r,h,l=!1){const m=t.getDescendants(e),_=[];_.push(this.beginDirectAnimation(t,i,n,a,s,o,r,h,l));for(const t of m)_.push(this.beginDirectAnimation(t,i,n,a,s,o,r,h,l));return _},u.prototype.getAnimatableByTarget=function(t){for(let e=0;e<this._activeAnimatables.length;e++)if(this._activeAnimatables[e].target===t)return this._activeAnimatables[e];return null},u.prototype.getAllAnimatablesByTarget=function(t){const e=[];for(let i=0;i<this._activeAnimatables.length;i++)this._activeAnimatables[i].target===t&&e.push(this._activeAnimatables[i]);return e},u.prototype.stopAnimation=function(t,e,i){const n=this.getAllAnimatablesByTarget(t);for(const t of n)t.stop(e,i)},u.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let t=0;t<this._activeAnimatables.length;t++)this._activeAnimatables[t].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const t of this.animationGroups)t.stop()});var A=i(82678);class f{getClassName(){return"TargetedAnimation"}constructor(t){this.parent=t,this.uniqueId=A.K.UniqueId}serialize(){const t={};return t.animation=this.animation.serialize(),t.targetId=this.target.id,t}}class b{get mask(){return this._mask}set mask(t){this._mask!==t&&(this._mask=t,this.syncWithMask(!0))}syncWithMask(t=!1){if(this.mask||t){this._numActiveAnimatables=0;for(let t=0;t<this._animatables.length;++t){const e=this._animatables[t];!this.mask||this.mask.disabled||this.mask.retainsTarget(e.target.name)?(this._numActiveAnimatables++,e.paused&&e.restart()):e.paused||e.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let t=0;t<this._animatables.length;++t){const e=this._animatables[t];this.mask.retainsTarget(e.target.name)||(e.stop(),this._animatables.splice(t,1),--t)}for(let t=0;t<this._targetedAnimations.length;t++){const e=this._targetedAnimations[t];this.mask.retainsTarget(e.target.name)||(this._targetedAnimations.splice(t,1),--t)}}}get from(){return this._from}set from(t){if(this._from!==t){this._from=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].fromFrame=this._from}}}get to(){return this._to}set to(t){if(this._to!==t){this._to=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(t){if(this._speedRatio!==t){this._speedRatio=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(t){if(this._loopAnimation!==t){this._loopAnimation=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(t){if(this._isAdditive!==t){this._isAdditive=t;for(let t=0;t<this._animatables.length;t++){this._animatables[t].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(t){this._weight!==t&&(this._weight=t,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(t){if(this._playOrder!==t&&(this._playOrder=t,this._animatables.length>0)){for(let t=0;t<this._animatables.length;t++)this._animatables[t].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(t){if(this._enableBlending!==t&&(this._enableBlending=t,null!==t))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.enableBlending=t}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(t){if(this._blendingSpeed!==t&&(this._blendingSpeed=t,null!==t))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.blendingSpeed=t}getLength(t,e){t=t??this._from;return((e=e??this._to)-t)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(t,e=!0,i=!1,n){if(0===t.length)return null;n=n??t[0].weight;let a=Number.MAX_VALUE,s=-Number.MAX_VALUE;if(i)for(const e of t)e.from<a&&(a=e.from),e.to>s&&(s=e.to);const o=new b(t[0].name+"_merged",t[0]._scene,n);for(const n of t){i&&n.normalize(a,s);for(const t of n.targetedAnimations)o.addTargetedAnimation(t.animation,t.target);e&&n.dispose()}return o}getScene(){return this._scene}constructor(t,e=null,i=-1,n=0){this.name=t,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new a.cP,this.onAnimationLoopObservable=new a.cP,this.onAnimationGroupLoopObservable=new a.cP,this.onAnimationGroupEndObservable=new a.cP,this.onAnimationGroupPauseObservable=new a.cP,this.onAnimationGroupPlayObservable=new a.cP,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=e||s.q.LastCreatedScene,this._weight=i,this._playOrder=n,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(t,e){const i=new f(this);i.animation=t,i.target=e;const n=t.getKeys();return this._from>n[0].frame&&(this._from=n[0].frame),this._to<n[n.length-1].frame&&(this._to=n[n.length-1].frame),null!==this._enableBlending&&(t.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(t.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(i),this._shouldStart=!0,i}removeTargetedAnimation(t){for(let e=this._targetedAnimations.length-1;e>-1;e--){this._targetedAnimations[e].animation===t&&this._targetedAnimations.splice(e,1)}}normalize(t=null,e=null){null==t&&(t=this._from),null==e&&(e=this._to);for(let i=0;i<this._targetedAnimations.length;i++){const n=this._targetedAnimations[i].animation.getKeys(),a=n[0],s=n[n.length-1];if(a.frame>t){const e={frame:t,value:a.value,inTangent:a.inTangent,outTangent:a.outTangent,interpolation:a.interpolation};n.splice(0,0,e)}if(s.frame<e){const t={frame:e,value:s.value,inTangent:s.inTangent,outTangent:s.outTangent,interpolation:s.interpolation};n.push(t)}}return this._from=t,this._to=e,this}_processLoop(t,e,i){t.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(e),this._animationLoopFlags[i]||(this._animationLoopFlags[i]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(t=!1,e=1,i,n,a){if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=t,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let s=0;s<this._targetedAnimations.length;s++){const o=this._targetedAnimations[s],r=this._scene.beginDirectAnimation(o.target,[o.animation],void 0!==i?i:this._from,void 0!==n?n:this._to,t,e,void 0,void 0,void 0!==a?a:this._isAdditive);r.weight=this._weight,r.playOrder=this._playOrder,r.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(o),this._checkAnimationGroupEnded(r)},this._processLoop(r,o,s),this._animatables.push(r)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=e,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let t=0;t<this._animatables.length;t++){this._animatables[t].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(t){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==t&&(this.loopAnimation=t),this.restart()):(this.stop(),this.start(t,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].reset()}return this}restart(){if(!this._isStarted)return this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(t=!1){if(!this._isStarted)return this;const e=this._animatables.slice();for(let i=0;i<e.length;i++)e[i].stop(void 0,void 0,!0,t);let i=0;for(let e=0;e<this._scene._activeAnimatables.length;e++){const n=this._scene._activeAnimatables[e];n._runtimeAnimations.length>0?this._scene._activeAnimatables[i++]=n:t&&this._checkAnimationGroupEnded(n,t)}return this._scene._activeAnimatables.length=i,this._isStarted=!1,this}setWeightForAllAnimatables(t){for(let e=0;e<this._animatables.length;e++){this._animatables[e].weight=t}return this}syncAllAnimationsWith(t){for(let e=0;e<this._animatables.length;e++){this._animatables[e].syncWith(t)}return this}goToFrame(t,e=!1){if(!this._isStarted)return this;for(let i=0;i<this._animatables.length;i++){this._animatables[i].goToFrame(t,e)}return this}getCurrentFrame(){return this.animatables[0]?.masterFrame||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const t=this._scene.animationGroups.indexOf(this);if(t>-1&&this._scene.animationGroups.splice(t,1),this._parentContainer){const t=this._parentContainer.animationGroups.indexOf(this);t>-1&&this._parentContainer.animationGroups.splice(t,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(t,e=!1){const i=this._animatables.indexOf(t);i>-1&&this._animatables.splice(i,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,e||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(t,e,i=!1){const n=new b(t||this.name,this._scene,this._weight,this._playOrder);n._from=this.from,n._to=this.to,n._speedRatio=this.speedRatio,n._loopAnimation=this.loopAnimation,n._isAdditive=this.isAdditive,n._enableBlending=this.enableBlending,n._blendingSpeed=this.blendingSpeed,n.metadata=this.metadata,n.mask=this.mask;for(const t of this._targetedAnimations)n.addTargetedAnimation(i?t.animation.clone():t.animation,e?e(t.target):t.target);return n}serialize(){const t={};t.name=this.name,t.from=this.from,t.to=this.to,t.speedRatio=this.speedRatio,t.loopAnimation=this.loopAnimation,t.isAdditive=this.isAdditive,t.weight=this.weight,t.playOrder=this.playOrder,t.enableBlending=this.enableBlending,t.blendingSpeed=this.blendingSpeed,t.targetedAnimations=[];for(let e=0;e<this.targetedAnimations.length;e++){const i=this.targetedAnimations[e];t.targetedAnimations[e]=i.serialize()}return o.Y&&o.Y.HasTags(this)&&(t.tags=o.Y.GetTags(this)),this.metadata&&(t.metadata=this.metadata),t}static Parse(t,e,i){const a=new b(t.name,e,t.weight,t.playOrder);for(let s=0;s<t.targetedAnimations.length;s++){const o=t.targetedAnimations[s],r=n.X5.Parse(o.animation),h=o.targetId;if("influence"===o.animation.property){const t=e.getMorphTargetById(h);t&&a.addTargetedAnimation(r,t)}else{const t=i?i.get(h):e.getNodeById(h);null!=t&&a.addTargetedAnimation(r,t)}}return o.Y&&o.Y.AddTagsTo(a,t.tags),null!==t.from&&null!==t.to&&a.normalize(t.from,t.to),void 0!==t.speedRatio&&(a._speedRatio=t.speedRatio),void 0!==t.loopAnimation&&(a._loopAnimation=t.loopAnimation),void 0!==t.isAdditive&&(a._isAdditive=t.isAdditive),void 0!==t.weight&&(a._weight=t.weight),void 0!==t.playOrder&&(a._playOrder=t.playOrder),void 0!==t.enableBlending&&(a._enableBlending=t.enableBlending),void 0!==t.blendingSpeed&&(a._blendingSpeed=t.blendingSpeed),void 0!==t.metadata&&(a.metadata=t.metadata),a}static MakeAnimationAdditive(t,e,i,a=!1,s){let o;o="object"==typeof e?e:{referenceFrame:e,range:i,cloneOriginalAnimationGroup:a,clonedAnimationName:s};let r=t;o.cloneOriginalAnimationGroup&&(r=t.clone(o.clonedAnimationGroupName||r.name));const h=r.targetedAnimations;for(let t=0;t<h.length;t++){const e=h[t];e.animation=n.X5.MakeAnimationAdditive(e.animation,o)}if(r.isAdditive=!0,o.clipKeys){let t=Number.MAX_VALUE,e=-Number.MAX_VALUE;const i=r.targetedAnimations;for(let n=0;n<i.length;n++){const a=i[n].animation.getKeys();t>a[0].frame&&(t=a[0].frame),e<a[a.length-1].frame&&(e=a[a.length-1].frame)}r._from=t,r._to=e}return r}static ClipKeys(t,e,i,n,a){const s=t.clone(n||t.name);return b.ClipKeysInPlace(s,e,i,a)}static ClipKeysInPlace(t,e,i,n){return b.ClipInPlace(t,e,i,n,!1)}static ClipFrames(t,e,i,n,a){const s=t.clone(n||t.name);return b.ClipFramesInPlace(s,e,i,a)}static ClipFramesInPlace(t,e,i,n){return b.ClipInPlace(t,e,i,n,!0)}static ClipInPlace(t,e,i,n,a=!1){let s=Number.MAX_VALUE,o=-Number.MAX_VALUE;const r=t.targetedAnimations;for(let t=0;t<r.length;t++){const h=r[t],l=n?h.animation:h.animation.clone();a&&(l.createKeyForFrame(e),l.createKeyForFrame(i));const m=l.getKeys(),_=[];let g=Number.MAX_VALUE;for(let t=0;t<m.length;t++){const n=m[t];if(!a&&t>=e&&t<=i||a&&n.frame>=e&&n.frame<=i){const t={frame:n.frame,value:n.value.clone?n.value.clone():n.value,inTangent:n.inTangent,outTangent:n.outTangent,interpolation:n.interpolation,lockedTangent:n.lockedTangent};g===Number.MAX_VALUE&&(g=t.frame),t.frame-=g,_.push(t)}}0!==_.length?(s>_[0].frame&&(s=_[0].frame),o<_[_.length-1].frame&&(o=_[_.length-1].frame),l.setKeys(_,!0),h.animation=l):(r.splice(t,1),t--)}return t._from=s,t._to=o,t}getClassName(){return"AnimationGroup"}toString(t){let e="Name: "+this.name;return e+=", type: "+this.getClassName(),t&&(e+=", from: "+this._from,e+=", to: "+this._to,e+=", isStarted: "+this._isStarted,e+=", speedRatio: "+this._speedRatio,e+=", targetedAnimations length: "+this._targetedAnimations.length,e+=", animatables length: "+this._animatables),e}}}}]);