"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[7728],{85296:(e,t,r)=>{function o(e,t,r,o){const n=e;let a=null,s=null,i=null,d=null;const c={},l=t.find((e=>"POSITION"===e.dracoName));if(!l)throw new Error("Position attribute is required for Draco encoding");if(!r){const e=l.data.length/l.size;r=new(e>65535?Uint32Array:Uint16Array)(e);for(let t=0;t<e;t++)r[t]=t}try{a=new n.Encoder,s=new n.MeshBuilder,i=new n.Mesh,s.AddFacesToMesh(i,r.length/3,r);const e=new Map([[Float32Array,(e,t,r,o,n,a)=>e.AddFloatAttribute(t,r,o,n,a)],[Uint32Array,(e,t,r,o,n,a)=>e.AddUInt32Attribute(t,r,o,n,a)],[Uint16Array,(e,t,r,o,n,a)=>e.AddUInt16Attribute(t,r,o,n,a)],[Uint8Array,(e,t,r,o,n,a)=>e.AddUInt8Attribute(t,r,o,n,a)],[Int32Array,(e,t,r,o,n,a)=>e.AddInt32Attribute(t,r,o,n,a)],[Int16Array,(e,t,r,o,n,a)=>e.AddInt16Attribute(t,r,o,n,a)],[Int8Array,(e,t,r,o,n,a)=>e.AddInt8Attribute(t,r,o,n,a)]]);for(const r of t){r.data instanceof Uint8ClampedArray&&(r.data=new Uint8Array(r.data));const t=e.get(r.data.constructor),d=r.data.length/r.size;c[r.kind]=t(s,i,n[r.dracoName],d,r.size,r.data),o.quantizationBits&&o.quantizationBits[r.dracoName]&&a.SetAttributeQuantization(n[r.dracoName],o.quantizationBits[r.dracoName])}o.method&&a.SetEncodingMethod(n[o.method]),void 0!==o.encodeSpeed&&void 0!==o.decodeSpeed&&a.SetSpeedOptions(o.encodeSpeed,o.decodeSpeed),d=new n.DracoInt8Array;const l=a.EncodeMeshToDracoBuffer(i,d);if(l<=0)throw new Error("Draco encoding failed.");const u=new Int8Array(l);for(let e=0;e<l;e++)u[e]=d.GetValue(e);return{data:u,attributeIDs:c}}finally{i&&n.destroy(i),s&&n.destroy(s),a&&n.destroy(a),d&&n.destroy(d)}}function n(){let e;onmessage=t=>{const r=t.data;switch(r.id){case"init":{r.url&&importScripts(r.url);const t=r.wasmBinary?{wasmBinary:r.wasmBinary}:{};e=DracoEncoderModule(t),postMessage({id:"initDone"});break}case"encodeMesh":if(!e)throw new Error("Draco encoder module is not available");e.then((e=>{const t=o(e,r.attributes,r.indices,r.options);postMessage({id:"encodeMeshDone",encodedMeshData:t},t?[t.data.buffer]:void 0)}))}}}function a(e,t,r,o,n){const a=e;let s=null,i=null,d=null;try{let e;s=new a.Decoder,i=new a.DecoderBuffer,i.Init(t,t.byteLength);const c=s.GetEncodedGeometryType(i);switch(c){case a.TRIANGULAR_MESH:{const t=new a.Mesh;if(e=s.DecodeBufferToMesh(i,t),!e.ok()||0===t.ptr)throw new Error(e.error_msg());const r=3*t.num_faces(),n=4*r,c=a._malloc(n);try{s.GetTrianglesUInt32Array(t,n,c);const e=new Uint32Array(r);e.set(new Uint32Array(a.HEAPF32.buffer,c,r)),o(e)}finally{a._free(c)}d=t;break}case a.POINT_CLOUD:{const t=new a.PointCloud;if(e=s.DecodeBufferToPointCloud(i,t),!e.ok()||!t.ptr)throw new Error(e.error_msg());d=t;break}default:throw new Error(`Invalid geometry type ${c}`)}const l=d.num_points(),u=(e,t,r,o)=>{const s=o.data_type(),i=o.num_components(),d=o.normalized(),c=o.byte_stride(),u=o.byte_offset(),y={[a.DT_FLOAT32]:{typedArrayConstructor:Float32Array,heap:a.HEAPF32},[a.DT_INT8]:{typedArrayConstructor:Int8Array,heap:a.HEAP8},[a.DT_INT16]:{typedArrayConstructor:Int16Array,heap:a.HEAP16},[a.DT_INT32]:{typedArrayConstructor:Int32Array,heap:a.HEAP32},[a.DT_UINT8]:{typedArrayConstructor:Uint8Array,heap:a.HEAPU8},[a.DT_UINT16]:{typedArrayConstructor:Uint16Array,heap:a.HEAPU16},[a.DT_UINT32]:{typedArrayConstructor:Uint32Array,heap:a.HEAPU32}}[s];if(!y)throw new Error(`Invalid data type ${s}`);const f=l*i,m=f*y.typedArrayConstructor.BYTES_PER_ELEMENT,w=a._malloc(m);try{e.GetAttributeDataArrayForAllPoints(t,o,s,m,w);const a=new y.typedArrayConstructor(y.heap.buffer,w,f);n(r,a.slice(),i,u,c,d)}finally{a._free(w)}};if(r)for(const e in r){const t=r[e],o=s.GetAttributeByUniqueId(d,t);u(s,d,e,o)}else{const e={position:a.POSITION,normal:a.NORMAL,color:a.COLOR,uv:a.TEX_COORD};for(const t in e){const r=s.GetAttributeId(d,e[t]);if(-1!==r){const e=s.GetAttribute(d,r);u(s,d,t,e)}}}return l}finally{d&&a.destroy(d),i&&a.destroy(i),s&&a.destroy(s)}}function s(){let e;onmessage=t=>{const r=t.data;switch(r.id){case"init":{r.url&&importScripts(r.url);const t=r.wasmBinary?{wasmBinary:r.wasmBinary}:{};e=DracoDecoderModule(t),postMessage({id:"initDone"});break}case"decodeMesh":if(!e)throw new Error("Draco decoder module is not available");e.then((e=>{const t=a(e,r.dataView,r.attributes,(e=>{postMessage({id:"indices",data:e},[e.buffer])}),((e,t,r,o,n,a)=>{postMessage({id:"attribute",kind:e,data:t,size:r,byteOffset:o,byteStride:n,normalized:a},[t.buffer])}));postMessage({id:"decodeMeshDone",totalVertices:t})}))}}}function i(e,t,r){return new Promise(((o,n)=>{const a=t=>{e.removeEventListener("error",a),e.removeEventListener("message",s),n(t)},s=t=>{"initDone"===t.data.id&&(e.removeEventListener("error",a),e.removeEventListener("message",s),o(e))};if(e.addEventListener("error",a),e.addEventListener("message",s),t){const o=t.slice(0);e.postMessage({id:"init",url:r,wasmBinary:o},[o])}else e.postMessage({id:"init",url:r})}))}r.d(t,{Ct:()=>o,GX:()=>a,TD:()=>i,ho:()=>s,t:()=>n})},85442:(e,t,r)=>{r.d(t,{$Y:()=>i,AA:()=>d,E5:()=>s});var o=r(998),n=r(97573),a=r(85296);function s(){return"object"==typeof navigator&&navigator.hardwareConcurrency?Math.min(Math.floor(.5*navigator.hardwareConcurrency),4):1}function i(e){return!!(e.wasmUrl&&(e.wasmBinary||e.wasmBinaryUrl)&&"object"==typeof WebAssembly||e.fallbackUrl)}class d{constructor(e){if(e.workerPool)return void(this._workerPoolPromise=Promise.resolve(e.workerPool));const t=e.wasmBinary,r=e.numWorkers??s(),i=r&&"function"==typeof Worker&&"function"==typeof URL,d=i||!e.jsModule,c=e.wasmUrl&&e.wasmBinaryUrl&&"object"==typeof WebAssembly?{url:d?o.S0.GetBabylonScriptURL(e.wasmUrl,!0):"",wasmBinaryPromise:t?Promise.resolve(t):o.S0.LoadFileAsync(o.S0.GetBabylonScriptURL(e.wasmBinaryUrl,!0))}:{url:d?o.S0.GetBabylonScriptURL(e.fallbackUrl):"",wasmBinaryPromise:Promise.resolve(void 0)};i?this._workerPoolPromise=c.wasmBinaryPromise.then((e=>{const t=this._getWorkerContent(),o=URL.createObjectURL(new Blob([t],{type:"application/javascript"}));return new n.h(r,(()=>{const t=new Worker(o);return(0,a.TD)(t,e,c.url)}))})):this._modulePromise=c.wasmBinaryPromise.then((async t=>{if(!this._isModuleAvailable()&&!e.jsModule){if(!c.url)throw new Error("Draco codec module is not available");await o.S0.LoadBabylonScriptAsync(c.url)}return this._createModuleAsync(t,e.jsModule)}))}async whenReadyAsync(){this._workerPoolPromise?await this._workerPoolPromise:this._modulePromise&&await this._modulePromise}dispose(){this._workerPoolPromise&&this._workerPoolPromise.then((e=>{e.dispose()})),delete this._workerPoolPromise,delete this._modulePromise}}},87728:(e,t,r)=>{r.d(t,{Y:()=>c});var o=r(85442),n=r(998),a=r(27050),s=r(56608),i=r(51137),d=r(85296);class c extends o.AA{static get DefaultAvailable(){return(0,o.$Y)(c.DefaultConfiguration)}static get Default(){return c._Default??(c._Default=new c),c._Default}static ResetDefault(e){c._Default&&(e||c._Default.dispose(),c._Default=null)}_isModuleAvailable(){return"undefined"!=typeof DracoDecoderModule}async _createModuleAsync(e,t){return{module:await(t||DracoDecoderModule)({wasmBinary:e})}}_getWorkerContent(){return`${d.GX}(${d.ho})()`}constructor(e=c.DefaultConfiguration){super(e)}decodeMeshToMeshDataAsync(e,t,r){const o=e instanceof ArrayBuffer?new Int8Array(e):new Int8Array(e.buffer,e.byteOffset,e.byteLength);if(this._workerPoolPromise)return this._workerPoolPromise.then((e=>new Promise(((n,a)=>{e.push(((e,s)=>{let d=null;const c=[],l=t=>{e.removeEventListener("error",l),e.removeEventListener("message",u),a(t),s()},u=t=>{const o=t.data;switch(o.id){case"indices":d=o.data;break;case"attribute":c.push({kind:o.kind,data:o.data,size:o.size,byteOffset:o.byteOffset,byteStride:o.byteStride,normalized:(a=o.kind,y=o.normalized,r&&void 0!==r[a]?(y!==r[a]&&i.V.Warn(`Normalized flag from Draco data (${y}) does not match normalized flag from glTF accessor (${r[a]}). Using flag from glTF accessor.`),r[a]):y)});break;case"decodeMeshDone":e.removeEventListener("error",l),e.removeEventListener("message",u),n({indices:d,attributes:c,totalVertices:o.totalVertices}),s()}var a,y};e.addEventListener("error",l),e.addEventListener("message",u);const y=o.slice();e.postMessage({id:"decodeMesh",dataView:y,attributes:t},[y.buffer])}))}))));if(this._modulePromise)return this._modulePromise.then((e=>{let r=null;const n=[],a=(0,d.GX)(e.module,o,t,(e=>{r=e}),((e,t,r,o,a,s)=>{n.push({kind:e,data:t,size:r,byteOffset:o,byteStride:a,normalized:s})}));return{indices:r,attributes:n,totalVertices:a}}));throw new Error("Draco decoder module is not available")}async decodeMeshToGeometryAsync(e,t,r,o){const n=await this.decodeMeshToMeshDataAsync(r,o),i=new a.V(e,t);n.indices&&i.setIndices(n.indices);for(const e of n.attributes)i.setVerticesBuffer(new s.R(t.getEngine(),e.data,e.kind,!1,void 0,e.byteStride,void 0,e.byteOffset,e.size,void 0,e.normalized,!0),n.totalVertices);return i}async _decodeMeshToGeometryForGltfAsync(e,t,r,o,n,i){const d=await this.decodeMeshToMeshDataAsync(r,o,n),c=new a.V(e,t);i&&(c._boundingInfo=i,c.useBoundingInfoFromGeometry=!0),d.indices&&c.setIndices(d.indices);for(const e of d.attributes)c.setVerticesBuffer(new s.R(t.getEngine(),e.data,e.kind,!1,void 0,e.byteStride,void 0,e.byteOffset,e.size,void 0,e.normalized,!0),d.totalVertices);return c}}c.DefaultConfiguration={wasmUrl:`${n.S0._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,wasmBinaryUrl:`${n.S0._DefaultCdnUrl}/draco_decoder_gltf.wasm`,fallbackUrl:`${n.S0._DefaultCdnUrl}/draco_decoder_gltf.js`},c._Default=null}}]);