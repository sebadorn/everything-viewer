"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[917],{10917:(t,s,e)=>{e.r(s),e.d(s,{ShaderMaterial:()=>d});var r=e(26877),i=e(48802),o=e(79923),n=e(95616),a=e(82781),h=e(56552),c=e(82565),f=e(62366),u=e(21644),_=e(6315),l=e(30492),p=e(80467);const x={effect:null,subMesh:null};class d extends u.E{constructor(t,s,e,r={},i=!0){super(t,s,i),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new o.uq,this._cachedWorldViewProjectionMatrix=new o.uq,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=e,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...r}}get shaderPath(){return this._shaderPath}set shaderPath(t){this._shaderPath=t}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(t){-1===this._options.uniforms.indexOf(t)&&this._options.uniforms.push(t)}setTexture(t,s){return-1===this._options.samplers.indexOf(t)&&this._options.samplers.push(t),this._textures[t]=s,this}removeTexture(t){delete this._textures[t]}setTextureArray(t,s){return-1===this._options.samplers.indexOf(t)&&this._options.samplers.push(t),this._checkUniform(t),this._textureArrays[t]=s,this}setExternalTexture(t,s){return-1===this._options.externalTextures.indexOf(t)&&this._options.externalTextures.push(t),this._externalTextures[t]=s,this}setFloat(t,s){return this._checkUniform(t),this._floats[t]=s,this}setInt(t,s){return this._checkUniform(t),this._ints[t]=s,this}setUInt(t,s){return this._checkUniform(t),this._uints[t]=s,this}setFloats(t,s){return this._checkUniform(t),this._floatsArrays[t]=s,this}setColor3(t,s){return this._checkUniform(t),this._colors3[t]=s,this}setColor3Array(t,s){return this._checkUniform(t),this._colors3Arrays[t]=s.reduce((t,s)=>(t.push(s.r,s.g,s.b),t),[]),this}setColor4(t,s){return this._checkUniform(t),this._colors4[t]=s,this}setColor4Array(t,s){return this._checkUniform(t),this._colors4Arrays[t]=s.reduce((t,s)=>(t.push(s.r,s.g,s.b,s.a),t),[]),this}setVector2(t,s){return this._checkUniform(t),this._vectors2[t]=s,this}setVector3(t,s){return this._checkUniform(t),this._vectors3[t]=s,this}setVector4(t,s){return this._checkUniform(t),this._vectors4[t]=s,this}setQuaternion(t,s){return this._checkUniform(t),this._quaternions[t]=s,this}setQuaternionArray(t,s){return this._checkUniform(t),this._quaternionsArrays[t]=s.reduce((t,s)=>(s.toArray(t,t.length),t),[]),this}setMatrix(t,s){return this._checkUniform(t),this._matrices[t]=s,this}setMatrices(t,s){this._checkUniform(t);const e=new Float32Array(16*s.length);for(let t=0;t<s.length;t++){s[t].copyToArray(e,16*t)}return this._matrixArrays[t]=e,this}setMatrix3x3(t,s){return this._checkUniform(t),this._matrices3x3[t]=s,this}setMatrix2x2(t,s){return this._checkUniform(t),this._matrices2x2[t]=s,this}setArray2(t,s){return this._checkUniform(t),this._vectors2Arrays[t]=s,this}setArray3(t,s){return this._checkUniform(t),this._vectors3Arrays[t]=s,this}setArray4(t,s){return this._checkUniform(t),this._vectors4Arrays[t]=s,this}setUniformBuffer(t,s){return-1===this._options.uniformBuffers.indexOf(t)&&this._options.uniformBuffers.push(t),this._uniformBuffers[t]=s,this}setTextureSampler(t,s){return-1===this._options.samplerObjects.indexOf(t)&&this._options.samplerObjects.push(t),this._textureSamplers[t]=s,this}setStorageBuffer(t,s){return-1===this._options.storageBuffers.indexOf(t)&&this._options.storageBuffers.push(t),this._storageBuffers[t]=s,this}setDefine(t,s){const e=t.trimEnd()+" ",r=this.options.defines.findIndex(s=>s===t||s.startsWith(e));return r>=0&&this.options.defines.splice(r,1),("boolean"!=typeof s||s)&&this.options.defines.push(e+s),this}isReadyForSubMesh(t,s,e){return this.isReady(t,e,s)}isReady(t,s,e){const r=e&&this._storeEffectOnSubMeshes;if(this.isFrozen){const t=r?e._drawWrapper:this._drawWrapper;if(t.effect&&t._wasPreviouslyReady&&t._wasPreviouslyUsingInstances===s)return!0}const o=this.getScene(),a=o.getEngine(),h=[],f=[];let u=null,_=this._shaderPath,d=this._options.uniforms,m=this._options.uniformBuffers,y=this._options.samplers;a.getCaps().multiview&&o.activeCamera&&o.activeCamera.outputRenderTarget&&o.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,h.push("#define MULTIVIEW"),-1!==d.indexOf("viewProjection")&&-1===d.indexOf("viewProjectionR")&&d.push("viewProjectionR"));for(let t=0;t<this._options.defines.length;t++){const s=0===this._options.defines[t].indexOf("#define")?this._options.defines[t]:`#define ${this._options.defines[t]}`;h.push(s)}for(let t=0;t<this._options.attributes.length;t++)f.push(this._options.attributes[t]);if(t&&t.isVerticesDataPresent(n.R.ColorKind)&&(-1===f.indexOf(n.R.ColorKind)&&f.push(n.R.ColorKind),h.push("#define VERTEXCOLOR")),s&&(h.push("#define INSTANCES"),(0,p.te)(f,this._materialHelperNeedsPreviousMatrices),t?.hasThinInstances&&(h.push("#define THIN_INSTANCES"),t&&t.isVerticesDataPresent(n.R.ColorInstanceKind)&&(f.push(n.R.ColorInstanceKind),h.push("#define INSTANCESCOLOR")))),t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton){f.push(n.R.MatricesIndicesKind),f.push(n.R.MatricesWeightsKind),t.numBoneInfluencers>4&&(f.push(n.R.MatricesIndicesExtraKind),f.push(n.R.MatricesWeightsExtraKind));const s=t.skeleton;h.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),u=new c.J,u.addCPUSkinningFallback(0,t),s.isUsingTextureForMatrices?(h.push("#define BONETEXTURE"),-1===d.indexOf("boneTextureWidth")&&d.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(h.push("#define BonesPerMesh "+(s.bones.length+1)),-1===d.indexOf("mBones")&&d.push("mBones"))}else h.push("#define NUM_BONE_INFLUENCERS 0");let A=0;const g=t?t.morphTargetManager:null;if(g){const s=-1!==h.indexOf("#define UV1"),e=-1!==h.indexOf("#define UV2"),r=-1!==h.indexOf("#define TANGENT"),i=-1!==h.indexOf("#define NORMAL"),o=-1!==h.indexOf("#define VERTEXCOLOR");A=(0,p.Dk)(g,h,f,t,!0,i,r,s,e,o),g.isUsingTextureForTargets&&(-1===d.indexOf("morphTargetTextureIndices")&&d.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),A>0&&(d=d.slice(),d.push("morphTargetInfluences"),d.push("morphTargetCount"),d.push("morphTargetTextureInfo"),d.push("morphTargetTextureIndices"))}else h.push("#define NUM_MORPH_INFLUENCERS 0");if(t){const s=t.bakedVertexAnimationManager;s&&s.isEnabled&&(h.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===d.indexOf("bakedVertexAnimationSettings")&&d.push("bakedVertexAnimationSettings"),-1===d.indexOf("bakedVertexAnimationTextureSizeInverted")&&d.push("bakedVertexAnimationTextureSizeInverted"),-1===d.indexOf("bakedVertexAnimationTime")&&d.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,p.J2)(f,t,h)}for(const t in this._textures)if(!this._textures[t].isReady())return!1;t&&this.needAlphaTestingForMesh(t)&&h.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,l.Ll)(d),(0,l.r4)(this,o,h)),o.fogEnabled&&t?.applyFog&&o.fogMode!==i.Z.FOGMODE_NONE&&(h.push("#define FOG"),-1===d.indexOf("view")&&d.push("view"),-1===d.indexOf("vFogInfos")&&d.push("vFogInfos"),-1===d.indexOf("vFogColor")&&d.push("vFogColor")),this._useLogarithmicDepth&&(h.push("#define LOGARITHMICDEPTH"),-1===d.indexOf("logarithmicDepthConstant")&&d.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(d=d.slice(),m=m.slice(),y=y.slice(),_=this.customShaderNameResolve(this.name,d,m,y,h,f));const v=e?e.getRenderingMesh():t;if(v&&this.useVertexPulling){h.push("#define USE_VERTEX_PULLING");const t=v.geometry?.getIndexBuffer();t&&(h.push("#define VERTEX_PULLING_USE_INDEX_BUFFER"),t.is32Bits&&h.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS"))}const T=r?e._getDrawWrapper(void 0,!0):this._drawWrapper,M=T?.effect??null,b=T?.defines??null,E=h.join("\n");let O=M;return b!==E&&(O=a.createEffect(_,{attributes:f,uniformsNames:d,uniformBuffersNames:m,samplers:y,defines:E,fallbacks:u,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:A},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},a),r?e.setEffect(O,E,this._materialContext):T&&T.setEffect(O,E),this._onEffectCreatedObservable&&(x.effect=O,x.subMesh=e??t?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(x))),T._wasPreviouslyUsingInstances=!!s,!!O?.isReady()&&(M!==O&&o.resetCachedMaterial(),T._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(t,s){const e=s??this.getEffect();if(!e)return;const r=this._options.uniforms;-1!==r.indexOf("world")&&e.setMatrix("world",t);const i=this.getScene();-1!==r.indexOf("worldView")&&(t.multiplyToRef(i.getViewMatrix(),this._cachedWorldViewMatrix),e.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==r.indexOf("worldViewProjection")&&(t.multiplyToRef(i.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),e.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==r.indexOf("view")&&e.setMatrix("view",i.getViewMatrix())}bindForSubMesh(t,s,e){this.bind(t,s,e._drawWrapperOverride?.effect,e)}bind(t,s,e,r){const i=r&&this._storeEffectOnSubMeshes,o=e??(i?r.effect:this.getEffect());if(!o)return;const n=this.getScene();this._activeEffect=o,this.bindOnlyWorldMatrix(t,e);const a=this._options.uniformBuffers;let h=!1;if(o&&a&&a.length>0&&n.getEngine().supportsUniformBuffers)for(let e=0;e<a.length;++e){switch(a[e]){case"Mesh":s&&(s.getMeshUniformBuffer().bindToEffect(o,"Mesh"),s.transferToEffect(t));break;case"Scene":(0,p._8)(o,n.getSceneUniformBuffer()),n.finalizeSceneUbo(),h=!0}}const c=s&&i?this._mustRebind(n,o,r,s.visibility):n.getCachedMaterial()!==this;if(o&&c){let t;for(t in h||-1===this._options.uniforms.indexOf("view")||o.setMatrix("view",n.getViewMatrix()),h||-1===this._options.uniforms.indexOf("projection")||o.setMatrix("projection",n.getProjectionMatrix()),h||-1===this._options.uniforms.indexOf("viewProjection")||(o.setMatrix("viewProjection",n.getTransformMatrix()),this._multiview&&o.setMatrix("viewProjectionR",n._transformMatrixR)),n.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&o.setVector3("cameraPosition",n.activeCamera.globalPosition),(0,p.f$)(s,o),(0,l.ij)(o,this,n),this._useLogarithmicDepth&&(0,p.DL)(i?r.materialDefines:o.defines,o,n),s&&(0,p.Yy)(n,s,o),this._textures)o.setTexture(t,this._textures[t]);for(t in this._textureArrays)o.setTextureArray(t,this._textureArrays[t]);for(t in this._ints)o.setInt(t,this._ints[t]);for(t in this._uints)o.setUInt(t,this._uints[t]);for(t in this._floats)o.setFloat(t,this._floats[t]);for(t in this._floatsArrays)o.setArray(t,this._floatsArrays[t]);for(t in this._colors3)o.setColor3(t,this._colors3[t]);for(t in this._colors3Arrays)o.setArray3(t,this._colors3Arrays[t]);for(t in this._colors4){const s=this._colors4[t];o.setFloat4(t,s.r,s.g,s.b,s.a)}for(t in this._colors4Arrays)o.setArray4(t,this._colors4Arrays[t]);for(t in this._vectors2)o.setVector2(t,this._vectors2[t]);for(t in this._vectors3)o.setVector3(t,this._vectors3[t]);for(t in this._vectors4)o.setVector4(t,this._vectors4[t]);for(t in this._quaternions)o.setQuaternion(t,this._quaternions[t]);for(t in this._matrices)o.setMatrix(t,this._matrices[t]);for(t in this._matrixArrays)o.setMatrices(t,this._matrixArrays[t]);for(t in this._matrices3x3)o.setMatrix3x3(t,this._matrices3x3[t]);for(t in this._matrices2x2)o.setMatrix2x2(t,this._matrices2x2[t]);for(t in this._vectors2Arrays)o.setArray2(t,this._vectors2Arrays[t]);for(t in this._vectors3Arrays)o.setArray3(t,this._vectors3Arrays[t]);for(t in this._vectors4Arrays)o.setArray4(t,this._vectors4Arrays[t]);for(t in this._quaternionsArrays)o.setArray4(t,this._quaternionsArrays[t]);for(t in this._uniformBuffers){const s=this._uniformBuffers[t].getBuffer();s&&o.bindUniformBuffer(s,t)}const e=n.getEngine(),a=e.setExternalTexture;if(a)for(t in this._externalTextures)a.call(e,t,this._externalTextures[t]);const c=e.setTextureSampler;if(c)for(t in this._textureSamplers)c.call(e,t,this._textureSamplers[t]);const f=e.setStorageBuffer;if(f)for(t in this._storageBuffers)f.call(e,t,this._storageBuffers[t])}if(o&&s&&(c||!this.isFrozen)){(0,p.nR)(s,o),s.morphTargetManager&&s.morphTargetManager.isUsingTextureForTargets&&s.morphTargetManager._bind(o);const t=s.bakedVertexAnimationManager;if(t&&t.isEnabled){const t=i?r._drawWrapper:this._drawWrapper;s.bakedVertexAnimationManager?.bind(o,!!t._wasPreviouslyUsingInstances)}}this._afterBind(s,o,r)}getActiveTextures(){const t=super.getActiveTextures();for(const s in this._textures)t.push(this._textures[s]);for(const s in this._textureArrays){const e=this._textureArrays[s];for(let s=0;s<e.length;s++)t.push(e[s])}return t}hasTexture(t){if(super.hasTexture(t))return!0;for(const s in this._textures)if(this._textures[s]===t)return!0;for(const s in this._textureArrays){const e=this._textureArrays[s];for(let s=0;s<e.length;s++)if(e[s]===t)return!0}return!1}clone(t){const s=r.p.Clone(()=>new d(t,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);s.name=t,s.id=t,"object"==typeof s._shaderPath&&(s._shaderPath={...s._shaderPath}),this._options={...this._options};const e=Object.keys(this._options);for(const t of e){const s=this._options[t];Array.isArray(s)&&(this._options[t]=s.slice(0))}this.stencil.copyTo(s.stencil);for(const t in this._textures)s.setTexture(t,this._textures[t]);for(const t in this._textureArrays)s.setTextureArray(t,this._textureArrays[t]);for(const t in this._externalTextures)s.setExternalTexture(t,this._externalTextures[t]);for(const t in this._ints)s.setInt(t,this._ints[t]);for(const t in this._uints)s.setUInt(t,this._uints[t]);for(const t in this._floats)s.setFloat(t,this._floats[t]);for(const t in this._floatsArrays)s.setFloats(t,this._floatsArrays[t]);for(const t in this._colors3)s.setColor3(t,this._colors3[t]);for(const t in this._colors3Arrays)s._colors3Arrays[t]=this._colors3Arrays[t];for(const t in this._colors4)s.setColor4(t,this._colors4[t]);for(const t in this._colors4Arrays)s._colors4Arrays[t]=this._colors4Arrays[t];for(const t in this._vectors2)s.setVector2(t,this._vectors2[t]);for(const t in this._vectors3)s.setVector3(t,this._vectors3[t]);for(const t in this._vectors4)s.setVector4(t,this._vectors4[t]);for(const t in this._quaternions)s.setQuaternion(t,this._quaternions[t]);for(const t in this._quaternionsArrays)s._quaternionsArrays[t]=this._quaternionsArrays[t];for(const t in this._matrices)s.setMatrix(t,this._matrices[t]);for(const t in this._matrixArrays)s._matrixArrays[t]=this._matrixArrays[t].slice();for(const t in this._matrices3x3)s.setMatrix3x3(t,this._matrices3x3[t]);for(const t in this._matrices2x2)s.setMatrix2x2(t,this._matrices2x2[t]);for(const t in this._vectors2Arrays)s.setArray2(t,this._vectors2Arrays[t]);for(const t in this._vectors3Arrays)s.setArray3(t,this._vectors3Arrays[t]);for(const t in this._vectors4Arrays)s.setArray4(t,this._vectors4Arrays[t]);for(const t in this._uniformBuffers)s.setUniformBuffer(t,this._uniformBuffers[t]);for(const t in this._textureSamplers)s.setTextureSampler(t,this._textureSamplers[t]);for(const t in this._storageBuffers)s.setStorageBuffer(t,this._storageBuffers[t]);return s}dispose(t,s,e){if(s){let t;for(t in this._textures)this._textures[t].dispose();for(t in this._textureArrays){const s=this._textureArrays[t];for(let t=0;t<s.length;t++)s[t].dispose()}}this._textures={},super.dispose(t,s,e)}serialize(){const t=r.p.Serialize(this);let s;for(s in t.customType="BABYLON.ShaderMaterial",t.uniqueId=this.uniqueId,t.options=this._options,t.shaderPath=this._shaderPath,t.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,t.stencil=this.stencil.serialize(),t.textures={},this._textures)t.textures[s]=this._textures[s].serialize();for(s in t.textureArrays={},this._textureArrays){t.textureArrays[s]=[];const e=this._textureArrays[s];for(let r=0;r<e.length;r++)t.textureArrays[s].push(e[r].serialize())}for(s in t.ints={},this._ints)t.ints[s]=this._ints[s];for(s in t.uints={},this._uints)t.uints[s]=this._uints[s];for(s in t.floats={},this._floats)t.floats[s]=this._floats[s];for(s in t.floatsArrays={},this._floatsArrays)t.floatsArrays[s]=this._floatsArrays[s];for(s in t.colors3={},this._colors3){const e=this._colors3[s];t.colors3[s]=[e.r,e.g,e.b]}for(s in t.colors3Arrays={},this._colors3Arrays)t.colors3Arrays[s]=this._colors3Arrays[s];for(s in t.colors4={},this._colors4){const e=this._colors4[s];t.colors4[s]=[e.r,e.g,e.b,e.a]}for(s in t.colors4Arrays={},this._colors4Arrays)t.colors4Arrays[s]=this._colors4Arrays[s];for(s in t.vectors2={},this._vectors2){const e=this._vectors2[s];t.vectors2[s]=[e.x,e.y]}for(s in t.vectors3={},this._vectors3){const e=this._vectors3[s];t.vectors3[s]=[e.x,e.y,e.z]}for(s in t.vectors4={},this._vectors4){const e=this._vectors4[s];t.vectors4[s]=[e.x,e.y,e.z,e.w]}for(s in t.quaternions={},this._quaternions)t.quaternions[s]=this._quaternions[s].asArray();for(s in t.matrices={},this._matrices)t.matrices[s]=this._matrices[s].asArray();for(s in t.matrixArray={},this._matrixArrays)t.matrixArray[s]=this._matrixArrays[s];for(s in t.matrices3x3={},this._matrices3x3)t.matrices3x3[s]=this._matrices3x3[s];for(s in t.matrices2x2={},this._matrices2x2)t.matrices2x2[s]=this._matrices2x2[s];for(s in t.vectors2Arrays={},this._vectors2Arrays)t.vectors2Arrays[s]=this._vectors2Arrays[s];for(s in t.vectors3Arrays={},this._vectors3Arrays)t.vectors3Arrays[s]=this._vectors3Arrays[s];for(s in t.vectors4Arrays={},this._vectors4Arrays)t.vectors4Arrays[s]=this._vectors4Arrays[s];for(s in t.quaternionsArrays={},this._quaternionsArrays)t.quaternionsArrays[s]=this._quaternionsArrays[s];return t}static Parse(t,s,e){const i=r.p.Parse(()=>new d(t.name,s,t.shaderPath,t.options,t.storeEffectOnSubMeshes),t,s,e);let n;for(n in t.stencil&&i.stencil.parse(t.stencil,s,e),t.textures)i.setTexture(n,a.g.Parse(t.textures[n],s,e));for(n in t.textureArrays){const r=t.textureArrays[n],o=[];for(let t=0;t<r.length;t++)o.push(a.g.Parse(r[t],s,e));i.setTextureArray(n,o)}for(n in t.ints)i.setInt(n,t.ints[n]);for(n in t.uints)i.setUInt(n,t.uints[n]);for(n in t.floats)i.setFloat(n,t.floats[n]);for(n in t.floatsArrays)i.setFloats(n,t.floatsArrays[n]);for(n in t.colors3){const s=t.colors3[n];i.setColor3(n,{r:s[0],g:s[1],b:s[2]})}for(n in t.colors3Arrays){const s=t.colors3Arrays[n].reduce((t,s,e)=>(e%3==0?t.push([s]):t[t.length-1].push(s),t),[]).map(t=>({r:t[0],g:t[1],b:t[2]}));i.setColor3Array(n,s)}for(n in t.colors4){const s=t.colors4[n];i.setColor4(n,{r:s[0],g:s[1],b:s[2],a:s[3]})}for(n in t.colors4Arrays){const s=t.colors4Arrays[n].reduce((t,s,e)=>(e%4==0?t.push([s]):t[t.length-1].push(s),t),[]).map(t=>({r:t[0],g:t[1],b:t[2],a:t[3]}));i.setColor4Array(n,s)}for(n in t.vectors2){const s=t.vectors2[n];i.setVector2(n,{x:s[0],y:s[1]})}for(n in t.vectors3){const s=t.vectors3[n];i.setVector3(n,{x:s[0],y:s[1],z:s[2]})}for(n in t.vectors4){const s=t.vectors4[n];i.setVector4(n,{x:s[0],y:s[1],z:s[2],w:s[3]})}for(n in t.quaternions)i.setQuaternion(n,o.PT.FromArray(t.quaternions[n]));for(n in t.matrices)i.setMatrix(n,o.uq.FromArray(t.matrices[n]));for(n in t.matrixArray)i._matrixArrays[n]=new Float32Array(t.matrixArray[n]);for(n in t.matrices3x3)i.setMatrix3x3(n,t.matrices3x3[n]);for(n in t.matrices2x2)i.setMatrix2x2(n,t.matrices2x2[n]);for(n in t.vectors2Arrays)i.setArray2(n,t.vectors2Arrays[n]);for(n in t.vectors3Arrays)i.setArray3(n,t.vectors3Arrays[n]);for(n in t.vectors4Arrays)i.setArray4(n,t.vectors4Arrays[n]);for(n in t.quaternionsArrays)i.setArray4(n,t.quaternionsArrays[n]);return i}static async ParseFromFileAsync(t,s,e,r=""){return await new Promise((i,o)=>{const n=new f.u;n.addEventListener("readystatechange",()=>{if(4==n.readyState)if(200==n.status){const s=JSON.parse(n.responseText),o=this.Parse(s,e||_.q.LastCreatedScene,r);t&&(o.name=t),i(o)}else o("Unable to load the ShaderMaterial")}),n.open("GET",s),n.send()})}static async ParseFromSnippetAsync(t,s,e=""){return await new Promise((r,i)=>{const o=new f.u;o.addEventListener("readystatechange",()=>{if(4==o.readyState)if(200==o.status){const i=JSON.parse(JSON.parse(o.responseText).jsonPayload),n=JSON.parse(i.shaderMaterial),a=this.Parse(n,s||_.q.LastCreatedScene,e);a.snippetId=t,r(a)}else i("Unable to load the snippet "+t)}),o.open("GET",this.SnippetUrl+"/"+t.replace(/#/g,"/")),o.send()})}}d.SnippetUrl="https://snippet.babylonjs.com",d.CreateFromSnippetAsync=d.ParseFromSnippetAsync,(0,h.Y5)("BABYLON.ShaderMaterial",d)}}]);