"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[2940,3486,5961],{5961:(e,t,s)=>{s.r(t),s.d(t,{IblCdfGeneratorSceneComponent:()=>a});var i=s(29794),r=s(16945),n=s(89974);Object.defineProperty(i.Z.prototype,"iblCdfGenerator",{get:function(){return this._iblCdfGenerator},set:function(e){e&&(this._iblCdfGenerator=e)},enumerable:!0,configurable:!0}),i.Z.prototype.enableIblCdfGenerator=function(){return this._iblCdfGenerator?this._iblCdfGenerator:(this._iblCdfGenerator=new n.IblCdfGenerator(this),this._iblCdfGenerator.isSupported?(this.environmentTexture&&(this._iblCdfGenerator.iblSource=this.environmentTexture),this._iblCdfGenerator):(this._iblCdfGenerator=null,null))},i.Z.prototype.disableIblCdfGenerator=function(){this._iblCdfGenerator&&(this._iblCdfGenerator.dispose(),this._iblCdfGenerator=null)};class a{constructor(e){this.name=r.v.NAME_IBLCDFGENERATOR,this._newIblObserver=null,this.scene=e}register(){this._updateIblSource(),this._newIblObserver=this.scene.onEnvironmentTextureChangedObservable.add(this._updateIblSource.bind(this))}rebuild(){}dispose(){this.scene.onEnvironmentTextureChangedObservable.remove(this._newIblObserver)}_updateIblSource(){this.scene.iblCdfGenerator&&this.scene.environmentTexture&&(this.scene.iblCdfGenerator.iblSource=this.scene.environmentTexture)}}n.IblCdfGenerator._SceneComponentInitialization=e=>{let t=e._getComponent(r.v.NAME_IBLCDFGENERATOR);t||(t=new a(e),e._addComponent(t))}},6194:(e,t,s)=>{var i=s(69610);const r="clipPlaneFragmentDeclaration",n="#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=n)},6739:(e,t,s)=>{s.r(t),s.d(t,{geometryVertexShader:()=>h});var i=s(69610);s(69707),s(18959),s(27999),s(90738),s(1218);const r="geometryVertexDeclaration",n="uniform mat4 viewProjection;uniform mat4 view;";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=n);s(28764);const a="geometryUboDeclaration",o="#include<sceneUboDeclaration>\n";i.l.IncludesShadersStore[a]||(i.l.IncludesShadersStore[a]=o);s(71636),s(48451),s(15060),s(3298),s(3361),s(65523),s(47314),s(19440);const l="geometryVertexShader",d="precision highp float;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<instancesDeclaration>\n#include<__decl__geometryVertex>\n#include<clipPlaneVertexDeclaration>\nattribute vec3 position;attribute vec3 normal;\n#ifdef NEED_UV\nvarying vec2 vUV;\n#ifdef ALPHATEST\nuniform mat4 diffuseMatrix;\n#endif\n#ifdef BUMP\nuniform mat4 bumpMatrix;varying vec2 vBumpUV;\n#endif\n#ifdef REFLECTIVITY\nuniform mat4 reflectivityMatrix;uniform mat4 albedoMatrix;varying vec2 vReflectivityUV;varying vec2 vAlbedoUV;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#ifdef BUMP\nvarying mat4 vWorldView;\n#endif\n#ifdef BUMP\nvarying vec3 vNormalW;\n#else\nvarying vec3 vNormalV;\n#endif\nvarying vec4 vViewPos;\n#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\n#endif\n#if defined(VELOCITY) || defined(VELOCITY_LINEAR)\nuniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;vec3 normalUpdated=normal;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef UV2\nvec2 uv2Updated=uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#if (defined(VELOCITY) || defined(VELOCITY_LINEAR)) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=vec4(finalWorld*vec4(positionUpdated,1.0));\n#ifdef BUMP\nvWorldView=view*finalWorld;mat3 normalWorld=mat3(finalWorld);vNormalW=normalize(normalWorld*normalUpdated);\n#else\n#ifdef NORMAL_WORLDSPACE\nvNormalV=normalize(vec3(finalWorld*vec4(normalUpdated,0.0)));\n#else\nvNormalV=normalize(vec3((view*finalWorld)*vec4(normalUpdated,0.0)));\n#endif\n#endif\nvViewPos=view*worldPos;\n#if (defined(VELOCITY) || defined(VELOCITY_LINEAR)) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n#if defined(POSITION) || defined(BUMP)\nvPositionW=worldPos.xyz/worldPos.w;\n#endif\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\n#include<clipPlaneVertex>\n#ifdef NEED_UV\n#ifdef UV1\n#if defined(ALPHATEST) && defined(ALPHATEST_UV1)\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#else\nvUV=uvUpdated;\n#endif\n#ifdef BUMP_UV1\nvBumpUV=vec2(bumpMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef REFLECTIVITY_UV1\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef ALBEDO_UV1\nvAlbedoUV=vec2(albedoMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#endif\n#ifdef UV2\n#if defined(ALPHATEST) && defined(ALPHATEST_UV2)\nvUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));\n#else\nvUV=uv2Updated;\n#endif\n#ifdef BUMP_UV2\nvBumpUV=vec2(bumpMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#ifdef REFLECTIVITY_UV2\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#ifdef ALBEDO_UV2\nvAlbedoUV=vec2(albedoMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#endif\n#endif\n#include<bumpVertex>\n}\n";i.l.ShadersStore[l]||(i.l.ShadersStore[l]=d);const h={name:l,shader:d}},7412:(e,t,s)=>{var i=s(69610);const r="clipPlaneFragment",n="#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{discard;}\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=n)},8269:(e,t,s)=>{var i=s(69610);s(63022);const r="bumpFragmentFunctions",n="#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)\n{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)\n{}\nelse if (currSampledHeight>currRayHeight)\n{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}\nelse\n{currRayHeight-=stepSize;vLastOffset=vCurrOffset;\n#ifdef PARALLAX_RHS\nvCurrOffset-=stepSize*vMaxOffset;\n#else\nvCurrOffset+=stepSize*vMaxOffset;\n#endif\nlastSampledHeight=currSampledHeight;}}\nreturn vCurrOffset;}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;\n#ifdef PARALLAX_RHS\nreturn texCoordOffset;\n#else\nreturn -texCoordOffset;\n#endif\n}\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=n)},13486:(e,t,s)=>{s.r(t);var i=s(90854),r=s(51137),n=s(77008);n.ThinEngine.prototype.restoreSingleAttachment=function(){const e=this._gl;this.bindAttachments([e.BACK])},n.ThinEngine.prototype.restoreSingleAttachmentForRenderTarget=function(){const e=this._gl;this.bindAttachments([e.COLOR_ATTACHMENT0])},n.ThinEngine.prototype.buildTextureLayout=function(e){const t=this._gl,s=[];for(let i=0;i<e.length;i++)e[i]?s.push(t["COLOR_ATTACHMENT"+i]):s.push(t.NONE);return s},n.ThinEngine.prototype.bindAttachments=function(e){this._gl.drawBuffers(e)},n.ThinEngine.prototype.unBindMultiColorAttachmentFramebuffer=function(e,t=!1,s){this._currentRenderTarget=null,e.disableAutomaticMSAAResolve||this.resolveMultiFramebuffer(e),t||this.generateMipMapsMultiFramebuffer(e),s&&(e._MSAAFramebuffer&&this._bindUnboundFramebuffer(e._framebuffer),s()),this._bindUnboundFramebuffer(null)},n.ThinEngine.prototype.createMultipleRenderTarget=function(e,t,s=!0){let n,a=!1,o=!0,l=!1,d=!1,h=1,u=1;let _=[],c=[],f=[],g=[],p=[],m=[],x=[],T=[],b=[],v=!1;const E=this._createHardwareRenderTargetWrapper(!0,!1,e);void 0!==t&&(a=void 0!==t.generateMipMaps&&t.generateMipMaps,o=void 0===t.generateDepthBuffer||t.generateDepthBuffer,l=void 0!==t.generateStencilBuffer&&t.generateStencilBuffer,d=void 0!==t.generateDepthTexture&&t.generateDepthTexture,h=t.textureCount??1,u=t.samples??u,_=t.types||_,c=t.samplingModes||c,f=t.useSRGBBuffers||f,g=t.formats||g,p=t.targetTypes||p,m=t.faceIndex||m,x=t.layerIndex||x,T=t.layerCounts||T,b=t.labels||b,v=t.dontCreateTextures??!1,this.webGLVersion>1&&(13===t.depthTextureFormat||17===t.depthTextureFormat||16===t.depthTextureFormat||14===t.depthTextureFormat||18===t.depthTextureFormat)&&(n=t.depthTextureFormat)),void 0===n&&(n=l?13:14);const P=this._gl,R=this._currentFramebuffer,S=P.createFramebuffer();this._bindUnboundFramebuffer(S);const M=e.width??e,y=e.height??e,D=[],I=[],C=this.webGLVersion>1&&(13===n||17===n||18===n);E.label=t?.label??"MultiRenderTargetWrapper",E._framebuffer=S,E._generateDepthBuffer=d||o,E._generateStencilBuffer=d?C:l,E._depthStencilBuffer=this._setupFramebufferDepthAttachments(E._generateStencilBuffer,E._generateDepthBuffer,M,y,1,n),E._attachments=I;for(let e=0;e<h;e++){let t=c[e]||3,s=_[e]||0,n=f[e]||false;const o=g[e]||5,l=p[e]||3553,d=T[e]??1;(1!==s||this._caps.textureFloatLinearFiltering)&&(2!==s||this._caps.textureHalfFloatLinearFiltering)||(t=1);const h=this._getSamplingParameters(t,a);1!==s||this._caps.textureFloat||(s=0,r.V.Warn("Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type")),n=n&&this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU);const u=this.webGLVersion>1,m=P[u?"COLOR_ATTACHMENT"+e:"COLOR_ATTACHMENT"+e+"_WEBGL"];if(I.push(m),-1===l||v)continue;const x=new i.h(this,6);D[e]=x,P.activeTexture(P["TEXTURE"+e]),P.bindTexture(l,x._hardwareTexture.underlyingResource),P.texParameteri(l,P.TEXTURE_MAG_FILTER,h.mag),P.texParameteri(l,P.TEXTURE_MIN_FILTER,h.min),P.texParameteri(l,P.TEXTURE_WRAP_S,P.CLAMP_TO_EDGE),P.texParameteri(l,P.TEXTURE_WRAP_T,P.CLAMP_TO_EDGE);const R=this._getRGBABufferInternalSizedFormat(s,o,n),S=this._getInternalFormat(o),C=this._getWebGLTextureType(s);if(!u||35866!==l&&32879!==l)if(34067===l){for(let e=0;e<6;e++)P.texImage2D(P.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,R,M,y,0,S,C,null);x.isCube=!0}else P.texImage2D(P.TEXTURE_2D,0,R,M,y,0,S,C,null);else 35866===l?x.is2DArray=!0:x.is3D=!0,x.baseDepth=x.depth=d,P.texImage3D(l,0,R,M,y,d,0,S,C,null);a&&P.generateMipmap(l),this._bindTextureDirectly(l,null),x.baseWidth=M,x.baseHeight=y,x.width=M,x.height=y,x.isReady=!0,x.samples=1,x.generateMipMaps=a,x.samplingMode=t,x.type=s,x._useSRGBBuffer=n,x.format=o,x.label=b[e]??E.label+"-Texture"+e,this._internalTexturesCache.push(x)}if(d&&this._caps.depthTextureExtension&&!v){const e=new i.h(this,14);let t=5,s=P.DEPTH_COMPONENT16,r=P.DEPTH_COMPONENT,o=P.UNSIGNED_SHORT,l=P.DEPTH_ATTACHMENT;this.webGLVersion<2?s=P.DEPTH_COMPONENT:14===n?(t=1,o=P.FLOAT,s=P.DEPTH_COMPONENT32F):18===n?(t=0,o=P.FLOAT_32_UNSIGNED_INT_24_8_REV,s=P.DEPTH32F_STENCIL8,r=P.DEPTH_STENCIL,l=P.DEPTH_STENCIL_ATTACHMENT):16===n?(t=0,o=P.UNSIGNED_INT,s=P.DEPTH_COMPONENT24,l=P.DEPTH_ATTACHMENT):13!==n&&17!==n||(t=12,o=P.UNSIGNED_INT_24_8,s=P.DEPTH24_STENCIL8,r=P.DEPTH_STENCIL,l=P.DEPTH_STENCIL_ATTACHMENT),this._bindTextureDirectly(P.TEXTURE_2D,e,!0),P.texParameteri(P.TEXTURE_2D,P.TEXTURE_MAG_FILTER,P.NEAREST),P.texParameteri(P.TEXTURE_2D,P.TEXTURE_MIN_FILTER,P.NEAREST),P.texParameteri(P.TEXTURE_2D,P.TEXTURE_WRAP_S,P.CLAMP_TO_EDGE),P.texParameteri(P.TEXTURE_2D,P.TEXTURE_WRAP_T,P.CLAMP_TO_EDGE),P.texImage2D(P.TEXTURE_2D,0,s,M,y,0,r,o,null),P.framebufferTexture2D(P.FRAMEBUFFER,l,P.TEXTURE_2D,e._hardwareTexture.underlyingResource,0),this._bindTextureDirectly(P.TEXTURE_2D,null),E._depthStencilTexture=e,E._depthStencilTextureWithStencil=C,e.baseWidth=M,e.baseHeight=y,e.width=M,e.height=y,e.isReady=!0,e.samples=1,e.generateMipMaps=a,e.samplingMode=1,e.format=n,e.type=t,e.label=E.label+"-DepthStencil",D[h]=e,this._internalTexturesCache.push(e)}if(E.setTextures(D),s&&P.drawBuffers(I),this._bindUnboundFramebuffer(R),E.setLayerAndFaceIndices(x,m),this.resetTextureCache(),v){if(u>1){const e=P.createFramebuffer();if(!e)throw new Error("Unable to create multi sampled framebuffer");E._samples=u,E._MSAAFramebuffer=e,h>0&&s&&(this._bindUnboundFramebuffer(e),P.drawBuffers(I),this._bindUnboundFramebuffer(R))}}else this.updateMultipleRenderTargetTextureSampleCount(E,u,s);return E},n.ThinEngine.prototype.updateMultipleRenderTargetTextureSampleCount=function(e,t,s=!0){if(this.webGLVersion<2||!e)return 1;if(e.samples===t)return t;const i=this._gl;t=Math.min(t,this.getCaps().maxMSAASamples),e._depthStencilBuffer&&(i.deleteRenderbuffer(e._depthStencilBuffer),e._depthStencilBuffer=null),e._MSAAFramebuffer&&(i.deleteFramebuffer(e._MSAAFramebuffer),e._MSAAFramebuffer=null);const r=e._attachments.length;for(let t=0;t<r;t++){const s=e.textures[t]._hardwareTexture;s?.releaseMSAARenderBuffers()}if(t>1&&"function"==typeof i.renderbufferStorageMultisample){const n=i.createFramebuffer();if(!n)throw new Error("Unable to create multi sampled framebuffer");e._MSAAFramebuffer=n,this._bindUnboundFramebuffer(n);const a=[];for(let s=0;s<r;s++){const r=e.textures[s],n=r._hardwareTexture,o=i[this.webGLVersion>1?"COLOR_ATTACHMENT"+s:"COLOR_ATTACHMENT"+s+"_WEBGL"],l=this._createRenderBuffer(r.width,r.height,t,-1,this._getRGBABufferInternalSizedFormat(r.type,r.format,r._useSRGBBuffer),o);if(!l)throw new Error("Unable to create multi sampled framebuffer");n.addMSAARenderBuffer(l),r.samples=t,a.push(o)}s&&i.drawBuffers(a)}else this._bindUnboundFramebuffer(e._framebuffer);const n=e._depthStencilTexture?e._depthStencilTexture.format:void 0;return e._depthStencilBuffer=this._setupFramebufferDepthAttachments(e._generateStencilBuffer,e._generateDepthBuffer,e.width,e.height,t,n),this._bindUnboundFramebuffer(null),e._samples=t,t},n.ThinEngine.prototype.generateMipMapsMultiFramebuffer=function(e){const t=e,s=this._gl;if(t.isMulti)for(let e=0;e<t._attachments.length;e++){const i=t.textures[e];!i?.generateMipMaps||i?.isCube||i?.is3D||(this._bindTextureDirectly(s.TEXTURE_2D,i,!0),s.generateMipmap(s.TEXTURE_2D),this._bindTextureDirectly(s.TEXTURE_2D,null))}},n.ThinEngine.prototype.resolveMultiFramebuffer=function(e){const t=e,s=this._gl;if(!t._MSAAFramebuffer||!t.isMulti)return;let i=t.resolveMSAAColors?s.COLOR_BUFFER_BIT:0;i|=t._generateDepthBuffer&&t.resolveMSAADepth?s.DEPTH_BUFFER_BIT:0,i|=t._generateStencilBuffer&&t.resolveMSAAStencil?s.STENCIL_BUFFER_BIT:0;const r=t._attachments,n=r.length;s.bindFramebuffer(s.READ_FRAMEBUFFER,t._MSAAFramebuffer),s.bindFramebuffer(s.DRAW_FRAMEBUFFER,t._framebuffer);for(let e=0;e<n;e++){const a=t.textures[e];for(let e=0;e<n;e++)r[e]=s.NONE;r[e]=s[this.webGLVersion>1?"COLOR_ATTACHMENT"+e:"COLOR_ATTACHMENT"+e+"_WEBGL"],s.readBuffer(r[e]),s.drawBuffers(r),s.blitFramebuffer(0,0,a.width,a.height,0,0,a.width,a.height,i,s.NEAREST)}for(let e=0;e<n;e++)r[e]=s[this.webGLVersion>1?"COLOR_ATTACHMENT"+e:"COLOR_ATTACHMENT"+e+"_WEBGL"];s.drawBuffers(r),s.bindFramebuffer(this._gl.FRAMEBUFFER,t._MSAAFramebuffer)}},17494:(e,t,s)=>{var i=s(69610);const r="bumpFragmentMainFunctions",n="#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\n#if defined(WEBGL2) || defined(WEBGPU)\nmat4 toNormalMatrix(mat4 wMatrix)\n{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}\n#else\nmat4 toNormalMatrix(mat4 m)\n{float\na00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],\na10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],\na20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],\na30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],\nb00=a00*a11-a01*a10,\nb01=a00*a12-a02*a10,\nb02=a00*a13-a03*a10,\nb03=a01*a12-a02*a11,\nb04=a01*a13-a03*a11,\nb05=a02*a13-a03*a12,\nb06=a20*a31-a21*a30,\nb07=a20*a32-a22*a30,\nb08=a20*a33-a23*a30,\nb09=a21*a32-a22*a31,\nb10=a21*a33-a23*a31,\nb11=a22*a33-a23*a32,\ndet=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(\na11*b11-a12*b10+a13*b09,\na02*b10-a01*b11-a03*b09,\na31*b05-a32*b04+a33*b03,\na22*b04-a21*b05-a23*b03,\na12*b08-a10*b11-a13*b07,\na00*b11-a02*b08+a03*b07,\na32*b02-a30*b05-a33*b01,\na20*b05-a22*b02+a23*b01,\na10*b10-a11*b08+a13*b06,\na01*b08-a00*b10-a03*b06,\na30*b04-a31*b02+a33*b00,\na21*b02-a20*b04-a23*b00,\na11*b07-a10*b09-a12*b06,\na00*b09-a01*b07+a02*b06,\na31*b01-a30*b03-a32*b00,\na20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],\nmi[0][1],mi[1][1],mi[2][1],mi[3][1],\nmi[0][2],mi[1][2],mi[2][2],mi[3][2],\nmi[0][3],mi[1][3],mi[2][3],mi[3][3]);}\n#endif\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\n{\n#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*normal);}\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\n{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\n{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=n)},22940:(e,t,s)=>{s.r(t),s.d(t,{IblShadowsRenderPipeline:()=>k});var i=s(6315),r=s(14037),n=s(82781),a=s(51137),o=s(18800),l=s(10917),d=s(96882);s(13486);class h extends d.RenderTargetTexture{get isSupported(){return this._engine?.getCaps().drawBuffersExtension??!1}get textures(){return this._textures}get count(){return this._count}get depthTexture(){return this._textures[this._textures.length-1]}set wrapU(e){if(this._textures)for(let t=0;t<this._textures.length;t++)this._textures[t].wrapU=e}set wrapV(e){if(this._textures)for(let t=0;t<this._textures.length;t++)this._textures[t].wrapV=e}constructor(e,t,s,i,r,n){const a=!(!r||!r.generateMipMaps)&&r.generateMipMaps,o=!(!r||!r.generateDepthTexture)&&r.generateDepthTexture,l=r&&r.depthTextureFormat?r.depthTextureFormat:15,d=!r||void 0===r.doNotChangeAspectRatio||r.doNotChangeAspectRatio,h=!(!r||!r.drawOnlyOnFirstAttachmentByDefault)&&r.drawOnlyOnFirstAttachmentByDefault;if(super(e,t,i,a,d,void 0,void 0,void 0,void 0,void 0,void 0,void 0,!0),!this.isSupported)return void this.dispose();this._textureNames=n;const u=[],_=[],c=[],f=[],g=[],p=[],m=[],x=[];this._initTypes(s,u,_,c,f,g,p,m,x,r);const T=!r||void 0===r.generateDepthBuffer||r.generateDepthBuffer,b=!(!r||void 0===r.generateStencilBuffer)&&r.generateStencilBuffer,v=r&&r.samples?r.samples:1;this._multiRenderTargetOptions={samplingModes:_,generateMipMaps:a,generateDepthBuffer:T,generateStencilBuffer:b,generateDepthTexture:o,depthTextureFormat:l,types:u,textureCount:s,useSRGBBuffers:c,samples:v,formats:f,targetTypes:g,faceIndex:p,layerIndex:m,layerCounts:x,labels:n,label:e},this._count=s,this._drawOnlyOnFirstAttachmentByDefault=h,s>0&&(this._createInternalTextures(),this._createTextures(n))}_initTypes(e,t,s,i,r,a,o,l,d,h){for(let u=0;u<e;u++)h&&h.types&&void 0!==h.types[u]?t.push(h.types[u]):t.push(h&&h.defaultType?h.defaultType:0),h&&h.samplingModes&&void 0!==h.samplingModes[u]?s.push(h.samplingModes[u]):s.push(n.g.BILINEAR_SAMPLINGMODE),h&&h.useSRGBBuffers&&void 0!==h.useSRGBBuffers[u]?i.push(h.useSRGBBuffers[u]):i.push(!1),h&&h.formats&&void 0!==h.formats[u]?r.push(h.formats[u]):r.push(5),h&&h.targetTypes&&void 0!==h.targetTypes[u]?a.push(h.targetTypes[u]):a.push(3553),h&&h.faceIndex&&void 0!==h.faceIndex[u]?o.push(h.faceIndex[u]):o.push(0),h&&h.layerIndex&&void 0!==h.layerIndex[u]?l.push(h.layerIndex[u]):l.push(0),h&&h.layerCounts&&void 0!==h.layerCounts[u]?d.push(h.layerCounts[u]):d.push(1)}_createInternaTextureIndexMapping(){const e={},t=[];if(!this._renderTarget)return t;const s=this._renderTarget.textures;for(let i=0;i<s.length;i++){const r=s[i];if(!r)continue;const n=e[r.uniqueId];void 0!==n?t[i]=n:e[r.uniqueId]=i}return t}_rebuild(e=!1,t=!1,s){if(this._count<1||e)return;const i=this._createInternaTextureIndexMapping();this.releaseInternalTextures(),this._createInternalTextures(),t&&(this._releaseTextures(),this._createTextures(s));const r=this._renderTarget.textures;for(let e=0;e<r.length;e++){const t=this._textures[e];void 0!==i[e]&&this._renderTarget.setTexture(r[i[e]],e),t._texture=r[e],t._texture&&(t._noMipmap=!t._texture.useMipMaps,t._useSRGBBuffer=t._texture._useSRGBBuffer)}1!==this.samples&&this._renderTarget.setSamples(this.samples,!this._drawOnlyOnFirstAttachmentByDefault,!0)}_createInternalTextures(){this._renderTarget=this._getEngine().createMultipleRenderTarget(this._size,this._multiRenderTargetOptions,!this._drawOnlyOnFirstAttachmentByDefault),this._texture=this._renderTarget.texture}_releaseTextures(){if(this._textures)for(let e=0;e<this._textures.length;e++)this._textures[e]._texture=null,this._textures[e].dispose()}_createTextures(e){const t=this._renderTarget.textures;this._textures=[];for(let s=0;s<t.length;s++){const i=new n.g(null,this.getScene());e?.[s]&&(i.name=e[s]),i._texture=t[s],i._texture&&(i._noMipmap=!i._texture.useMipMaps,i._useSRGBBuffer=i._texture._useSRGBBuffer),this._textures.push(i)}}setInternalTexture(e,t,s=!0){if(this.renderTarget&&(0===t&&(this._texture=e),this.renderTarget.setTexture(e,t,s),this.textures[t]||(this.textures[t]=new n.g(null,this.getScene()),this.textures[t].name=this._textureNames?.[t]??this.textures[t].name),this.textures[t]._texture=e,this.textures[t]._noMipmap=!e.useMipMaps,this.textures[t]._useSRGBBuffer=e._useSRGBBuffer,this._count=this.renderTarget.textures?this.renderTarget.textures.length:0,this._multiRenderTargetOptions.types&&(this._multiRenderTargetOptions.types[t]=e.type),this._multiRenderTargetOptions.samplingModes&&(this._multiRenderTargetOptions.samplingModes[t]=e.samplingMode),this._multiRenderTargetOptions.useSRGBBuffers&&(this._multiRenderTargetOptions.useSRGBBuffers[t]=e._useSRGBBuffer),this._multiRenderTargetOptions.targetTypes&&-1!==this._multiRenderTargetOptions.targetTypes[t])){let s=0;s=e.is2DArray?35866:e.isCube?34067:e.is3D?32879:3553,this._multiRenderTargetOptions.targetTypes[t]=s}}setLayerAndFaceIndex(e,t=-1,s=-1){this.textures[e]&&this.renderTarget&&(this._multiRenderTargetOptions.layerIndex&&(this._multiRenderTargetOptions.layerIndex[e]=t),this._multiRenderTargetOptions.faceIndex&&(this._multiRenderTargetOptions.faceIndex[e]=s),this.renderTarget.setLayerAndFaceIndex(e,t,s))}setLayerAndFaceIndices(e,t){this.renderTarget&&(this._multiRenderTargetOptions.layerIndex=e,this._multiRenderTargetOptions.faceIndex=t,this.renderTarget.setLayerAndFaceIndices(e,t))}get samples(){return this._samples}set samples(e){this._renderTarget?this._samples=this._renderTarget.setSamples(e):this._samples=e}resize(e){this._processSizeParameter(e),this._rebuild(!1,void 0,this._textureNames)}updateCount(e,t,s){this._multiRenderTargetOptions.textureCount=e,this._count=e;const i=[],r=[],n=[],a=[],o=[],l=[],d=[],h=[];this._textureNames=s,this._initTypes(e,i,r,n,a,o,l,d,h,t),this._multiRenderTargetOptions.types=i,this._multiRenderTargetOptions.samplingModes=r,this._multiRenderTargetOptions.useSRGBBuffers=n,this._multiRenderTargetOptions.formats=a,this._multiRenderTargetOptions.targetTypes=o,this._multiRenderTargetOptions.faceIndex=l,this._multiRenderTargetOptions.layerIndex=d,this._multiRenderTargetOptions.layerCounts=h,this._multiRenderTargetOptions.labels=s,this._rebuild(!1,!0,s)}_unbindFrameBuffer(e,t){this._renderTarget&&e.unBindMultiColorAttachmentFramebuffer(this._renderTarget,this.isCube,()=>{this.onAfterRenderObservable.notifyObservers(t)})}dispose(e=!1){this._releaseTextures(),e?this._texture=null:this.releaseInternalTextures(),super.dispose()}releaseInternalTextures(){const e=this._renderTarget?.textures;if(e){for(let t=e.length-1;t>=0;t--)this._textures[t]._texture=null;this._renderTarget?.dispose(),this._renderTarget=null}}}var u=s(26041),_=s(99848),c=s(77891),f=s(51584),g=s(84255);class p{getVoxelGrid(){return this._triPlanarVoxelization?this._voxelGridRT:this._voxelGridZaxis}getDebugPassPP(){return this._voxelDebugPass||this._createDebugPass(),this._voxelDebugPass}get triPlanarVoxelization(){return this._triPlanarVoxelization}set triPlanarVoxelization(e){this._triPlanarVoxelization!==e&&(this._triPlanarVoxelization=e,this._disposeVoxelTextures(),this._createTextures())}setWorldScaleMatrix(e){this._invWorldScaleMatrix=e}isVoxelizationInProgress(){return this._voxelizationInProgress}get voxelResolutionExp(){return this._voxelResolutionExp}set voxelResolutionExp(e){this._voxelResolutionExp===e&&this._voxelGridZaxis||(this._voxelResolutionExp=Math.round(Math.min(Math.max(e,3),9)),this._voxelResolution=Math.pow(2,this._voxelResolutionExp),this._disposeVoxelTextures(),this._createTextures())}set voxelDebugAxis(e){this._voxelDebugAxis=e}get voxelDebugAxis(){return this._voxelDebugAxis}setDebugDisplayParams(e,t,s,i){this._debugSizeParams.set(e,t,s,i)}setDebugMipNumber(e){this._debugMipNumber=e}get debugPassName(){return this._debugPassName}get voxelDebugEnabled(){return this._voxelDebugEnabled}set voxelDebugEnabled(e){this._voxelDebugEnabled!==e&&(this._voxelDebugEnabled=e,e&&(this._voxelSlabDebugRT=new d.RenderTargetTexture("voxelSlabDebug",{width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight()},this._scene,{generateDepthBuffer:!0,generateMipMaps:!1,type:0,format:5,samplingMode:1}),this._voxelSlabDebugRT.noPrePassRenderer=!0),this._voxelSlabDebugRT&&this._removeVoxelRTs([this._voxelSlabDebugRT]),this._voxelDebugEnabled?(this._addRTsForRender([this._voxelSlabDebugRT],this._includedMeshes,this._voxelDebugAxis,1,!0),this._setDebugBindingsBound=this._setDebugBindings.bind(this),this._scene.onBeforeRenderObservable.add(this._setDebugBindingsBound)):this._scene.onBeforeRenderObservable.removeCallback(this._setDebugBindingsBound))}_createDebugPass(){const e=this._engine.isWebGPU;if(!this._voxelDebugPass){const t={width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight(),textureFormat:5,textureType:0,samplingMode:1,uniforms:["sizeParams","mipNumber"],samplers:["voxelTexture","voxelSlabTexture"],engine:this._engine,reusable:!1,shaderLanguage:e?1:0,extraInitializations:(e,t)=>{this._isVoxelGrid3D?e?t.push(s.e(4237).then(s.bind(s,84237))):t.push(s.e(6214).then(s.bind(s,96214))):e?t.push(s.e(7537).then(s.bind(s,17537))):t.push(s.e(8188).then(s.bind(s,88188)))}};this._voxelDebugPass=new c.w(this.debugPassName,this._isVoxelGrid3D?"iblVoxelGrid3dDebug":"iblVoxelGrid2dArrayDebug",t),this._voxelDebugPass.onApplyObservable.add(e=>{0===this._voxelDebugAxis?e.setTexture("voxelTexture",this._voxelGridXaxis):1===this._voxelDebugAxis?e.setTexture("voxelTexture",this._voxelGridYaxis):2===this._voxelDebugAxis?e.setTexture("voxelTexture",this._voxelGridZaxis):e.setTexture("voxelTexture",this.getVoxelGrid()),e.setTexture("voxelSlabTexture",this._voxelSlabDebugRT),e.setVector4("sizeParams",this._debugSizeParams),e.setFloat("mipNumber",this._debugMipNumber)})}}constructor(e,t,i=6,n=!0){this._voxelMrtsXaxis=[],this._voxelMrtsYaxis=[],this._voxelMrtsZaxis=[],this._isVoxelGrid3D=!0,this.onVoxelizationCompleteObservable=new _.cP,this._renderTargets=[],this._triPlanarVoxelization=!0,this._voxelizationInProgress=!1,this._invWorldScaleMatrix=r.uq.Identity(),this._voxelResolution=64,this._voxelResolutionExp=6,this._mipArray=[],this._voxelDebugEnabled=!1,this._voxelDebugAxis=-1,this._debugSizeParams=new r.IU(0,0,0,0),this._includedMeshes=[],this._debugMipNumber=0,this._debugPassName="Voxelization Debug Pass",this._scene=e,this._engine=e.getEngine(),this._triPlanarVoxelization=n,this._engine.getCaps().drawBuffersExtension||a.V.Error("Can't do voxel rendering without the draw buffers extension.");const o=this._engine.isWebGPU;this._maxDrawBuffers=this._engine.getCaps().maxDrawBuffers||0,this._copyMipEffectRenderer=new g.J(this._engine),this._copyMipEffectWrapper=new g.$({engine:this._engine,fragmentShader:"copyTexture3DLayerToTexture",useShaderStore:!0,uniformNames:["layerNum"],samplerNames:["textureSampler"],shaderLanguage:o?1:0,extraInitializationsAsync:async()=>{o?await s.e(5176).then(s.bind(s,95176)):await s.e(7383).then(s.bind(s,47383))}}),this.voxelResolutionExp=i}_generateMipMaps(){const e=Math.ceil(Math.log2(this._voxelResolution));for(let t=1;t<e+1;t++)this._generateMipMap(t)}_generateMipMap(e){const t=this._mipArray[e-1];t&&(t.setTexture("srcMip",1===e?this.getVoxelGrid():this._mipArray[e-2]),t.render())}_copyMipMaps(){const e=Math.ceil(Math.log2(this._voxelResolution));for(let t=1;t<e+1;t++)this._copyMipMap(t)}_copyMipMap(e){const t=this._mipArray[e-1];if(!t)return;const s=this.getVoxelGrid();let i;if(i=s instanceof d.RenderTargetTexture&&s.renderTarget?s.renderTarget:s._rtWrapper,i){this._copyMipEffectRenderer.saveStates();const s=t.getSize().width;for(let r=0;r<s;r++)this._engine.bindFramebuffer(i,0,s,s,!0,e,r),this._copyMipEffectRenderer.applyEffectWrapper(this._copyMipEffectWrapper),this._copyMipEffectWrapper.effect.setTexture("textureSampler",t),this._copyMipEffectWrapper.effect.setInt("layerNum",r),this._copyMipEffectRenderer.draw(),this._engine.unBindFramebuffer(i,!0);this._copyMipEffectRenderer.restoreStates()}}_computeNumberOfSlabs(){return Math.ceil(this._voxelResolution/this._maxDrawBuffers)}_createTextures(){const e=this._engine.isWebGPU,t={width:this._voxelResolution,height:this._voxelResolution,layers:this._isVoxelGrid3D?void 0:this._voxelResolution,depth:this._isVoxelGrid3D?this._voxelResolution:void 0},i={generateDepthBuffer:!1,generateMipMaps:!1,type:0,format:6,samplingMode:1},r=this._computeNumberOfSlabs(),a={generateDepthBuffer:!1,generateMipMaps:!0,type:0,format:6,samplingMode:4,shaderLanguage:e?1:0,extraInitializationsAsync:async()=>{e?await s.e(2199).then(s.bind(s,92199)):await s.e(8162).then(s.bind(s,18162))}};this._triPlanarVoxelization?(this._voxelGridXaxis=new d.RenderTargetTexture("voxelGridXaxis",t,this._scene,i),this._voxelGridYaxis=new d.RenderTargetTexture("voxelGridYaxis",t,this._scene,i),this._voxelGridZaxis=new d.RenderTargetTexture("voxelGridZaxis",t,this._scene,i),this._voxelMrtsXaxis=this._createVoxelMRTs("x_axis_",this._voxelGridXaxis,r),this._voxelMrtsYaxis=this._createVoxelMRTs("y_axis_",this._voxelGridYaxis,r),this._voxelMrtsZaxis=this._createVoxelMRTs("z_axis_",this._voxelGridZaxis,r),this._voxelGridRT=new f.p("combinedVoxelGrid",t,"iblCombineVoxelGrids",this._scene,a,!1),this._scene.proceduralTextures.splice(this._scene.proceduralTextures.indexOf(this._voxelGridRT),1),this._voxelGridRT.setFloat("layer",0),this._voxelGridRT.setTexture("voxelXaxisSampler",this._voxelGridXaxis),this._voxelGridRT.setTexture("voxelYaxisSampler",this._voxelGridYaxis),this._voxelGridRT.setTexture("voxelZaxisSampler",this._voxelGridZaxis),this._voxelGridRT.autoClear=!1,this._voxelGridRT.wrapU=n.g.CLAMP_ADDRESSMODE,this._voxelGridRT.wrapV=n.g.CLAMP_ADDRESSMODE):(this._voxelGridZaxis=new d.RenderTargetTexture("voxelGridZaxis",t,this._scene,a),this._voxelMrtsZaxis=this._createVoxelMRTs("z_axis_",this._voxelGridZaxis,r));const o={generateDepthBuffer:!1,generateMipMaps:!1,type:0,format:6,samplingMode:1,shaderLanguage:e?1:0,extraInitializationsAsync:async()=>{e?await s.e(3584).then(s.bind(s,23584)):await s.e(6043).then(s.bind(s,46043))}};this._mipArray=new Array(Math.ceil(Math.log2(this._voxelResolution)));for(let e=1;e<=this._mipArray.length;e++){const t=this._voxelResolution>>e,s={width:t,height:t,depth:t};this._mipArray[e-1]=new f.p("voxelMip"+e,s,"iblGenerateVoxelMip",this._scene,o,!1),this._scene.proceduralTextures.splice(this._scene.proceduralTextures.indexOf(this._mipArray[e-1]),1);const i=this._mipArray[e-1];i.autoClear=!1,i.wrapU=n.g.CLAMP_ADDRESSMODE,i.wrapV=n.g.CLAMP_ADDRESSMODE,i.setTexture("srcMip",e>1?this._mipArray[e-2]:this.getVoxelGrid()),i.setInt("layerNum",0)}this._createVoxelMaterials()}_createVoxelMRTs(e,t,s){t.wrapU=n.g.CLAMP_ADDRESSMODE,t.wrapV=n.g.CLAMP_ADDRESSMODE,t.noPrePassRenderer=!0;const i=[],r=new Array(this._maxDrawBuffers).fill(this._isVoxelGrid3D?32879:35866);for(let n=0;n<s;n++){let s=new Array(this._maxDrawBuffers).fill(0);s=s.map((e,t)=>n*this._maxDrawBuffers+t);let a=new Array(this._maxDrawBuffers).fill("");a=a.map((t,s)=>"voxel_grid_"+e+(n*this._maxDrawBuffers+s));const o=new h("mrt_"+e+n,{width:this._voxelResolution,height:this._voxelResolution,depth:this._isVoxelGrid3D?this._voxelResolution:void 0},this._maxDrawBuffers,this._scene,{types:new Array(this._maxDrawBuffers).fill(0),samplingModes:new Array(this._maxDrawBuffers).fill(3),generateMipMaps:!1,targetTypes:r,formats:new Array(this._maxDrawBuffers).fill(6),faceIndex:new Array(this._maxDrawBuffers).fill(0),layerIndex:s,layerCounts:new Array(this._maxDrawBuffers).fill(this._voxelResolution),generateDepthBuffer:!1,generateStencilBuffer:!1},a);o.clearColor=new u.ov(0,0,0,1),o.noPrePassRenderer=!0;for(let e=0;e<this._maxDrawBuffers;e++)o.setInternalTexture(t.getInternalTexture(),e);i.push(o)}return i}_disposeVoxelTextures(){this._stopVoxelization();for(let e=0;e<this._voxelMrtsZaxis.length;e++)this._triPlanarVoxelization&&(this._voxelMrtsXaxis[e].dispose(!0),this._voxelMrtsYaxis[e].dispose(!0)),this._voxelMrtsZaxis[e].dispose(!0);this._triPlanarVoxelization&&(this._voxelGridXaxis?.dispose(),this._voxelGridYaxis?.dispose(),this._voxelGridRT?.dispose()),this._voxelGridZaxis?.dispose();for(const e of this._mipArray)e.dispose();this._voxelMaterial?.dispose(),this._voxelSlabDebugMaterial?.dispose(),this._mipArray=[],this._voxelMrtsXaxis=[],this._voxelMrtsYaxis=[],this._voxelMrtsZaxis=[]}_createVoxelMaterials(){const e=this._engine.isWebGPU;this._voxelMaterial=new l.ShaderMaterial("voxelization",this._scene,"iblVoxelGrid",{uniforms:["world","viewMatrix","invWorldScale","nearPlane","farPlane","stepSize"],defines:["MAX_DRAW_BUFFERS "+this._maxDrawBuffers],shaderLanguage:e?1:0,extraInitializationsAsync:async()=>{e?await Promise.all([s.e(9107).then(s.bind(s,39107)),s.e(3965).then(s.bind(s,43965))]):await Promise.all([s.e(3414).then(s.bind(s,3414)),s.e(8444).then(s.bind(s,8444))])}}),this._voxelMaterial.cullBackFaces=!1,this._voxelMaterial.backFaceCulling=!1,this._voxelMaterial.depthFunction=o.Engine.ALWAYS,this._voxelSlabDebugMaterial=new l.ShaderMaterial("voxelSlabDebug",this._scene,"iblVoxelSlabDebug",{uniforms:["world","viewMatrix","cameraViewMatrix","projection","invWorldScale","nearPlane","farPlane","stepSize"],defines:["MAX_DRAW_BUFFERS "+this._maxDrawBuffers],shaderLanguage:e?1:0,extraInitializationsAsync:async()=>{e?await Promise.all([s.e(1138).then(s.bind(s,1138)),s.e(6472).then(s.bind(s,26472))]):await Promise.all([s.e(5257).then(s.bind(s,85257)),s.e(1587).then(s.bind(s,93968))])}})}_setDebugBindings(){this._voxelSlabDebugMaterial.setMatrix("projection",this._scene.activeCamera.getProjectionMatrix()),this._voxelSlabDebugMaterial.setMatrix("cameraViewMatrix",this._scene.activeCamera.getViewMatrix())}isReady(){let e=this.getVoxelGrid().isReady();for(let t=0;t<this._mipArray.length;t++){const s=this._mipArray[t].isReady();e&&(e=s)}return!(!e||this._voxelizationInProgress)}_stopVoxelization(){this._removeVoxelRTs(this._voxelMrtsXaxis),this._removeVoxelRTs(this._voxelMrtsYaxis),this._removeVoxelRTs(this._voxelMrtsZaxis)}_removeVoxelRTs(e){const t=this._renderTargets.findIndex(t=>t===e[0]);if(t>=0)this._renderTargets.splice(t,e.length);else{const t=this._scene.customRenderTargets.findIndex(t=>t===e[0]);t>=0&&this._scene.customRenderTargets.splice(t,e.length)}}updateVoxelGrid(e){this._stopVoxelization(),this._includedMeshes=e,this._voxelizationInProgress=!0,this._triPlanarVoxelization?(this._addRTsForRender(this._voxelMrtsXaxis,e,0),this._addRTsForRender(this._voxelMrtsYaxis,e,1),this._addRTsForRender(this._voxelMrtsZaxis,e,2)):this._addRTsForRender(this._voxelMrtsZaxis,e,2),this._voxelDebugEnabled&&this._addRTsForRender([this._voxelSlabDebugRT],e,this._voxelDebugAxis,1,!0),this._renderVoxelGridBound=this._renderVoxelGrid.bind(this),this._scene.onAfterRenderObservable.add(this._renderVoxelGridBound)}_renderVoxelGrid(){if(this._voxelizationInProgress){let e=this.getVoxelGrid().isReady();for(let t=0;t<this._mipArray.length;t++){const s=this._mipArray[t].isReady();e&&(e=s)}for(let t=0;t<this._renderTargets.length;t++){const s=this._renderTargets[t].isReadyForRendering();e&&(e=s)}if(e){for(const e of this._renderTargets)e.render();this._stopVoxelization(),this._triPlanarVoxelization&&this._voxelGridRT.render(),this._generateMipMaps(),this._copyMipEffectWrapper.effect.whenCompiledAsync().then(()=>{this._copyMipMaps(),this._scene.onAfterRenderObservable.removeCallback(this._renderVoxelGridBound),this._voxelizationInProgress=!1,this.onVoxelizationCompleteObservable.notifyObservers()})}}}_addRTsForRender(e,t,s,i=0,n=!1){const a=1/this._computeNumberOfSlabs();let o;o=0===i?this._voxelMaterial:this._voxelSlabDebugMaterial;for(let i=0;i<e.length;i++){const n=e[i];n.renderList=[];const l=i*a,d=(i+1)*a,h=a/this._maxDrawBuffers,u=new r.Pq(0,0,0);let _=new r.Pq(0,0,1);0===s?_=new r.Pq(1,0,0):1===s&&(_=new r.Pq(0,1,0));let c=new r.Pq(0,1,0);if(1===s&&(c=new r.Pq(1,0,0)),n.onBeforeRenderObservable.add(()=>{o.setMatrix("viewMatrix",r.uq.LookAtLH(u,_,c)),o.setMatrix("invWorldScale",this._invWorldScaleMatrix),o.setFloat("nearPlane",l),o.setFloat("farPlane",d),o.setFloat("stepSize",h)}),0===t.length)return;for(const e of t)if(e){e.subMeshes&&e.subMeshes.length>0&&(n.renderList?.push(e),n.setMaterialForRendering(e,o));const t=e.getChildMeshes();for(const e of t)e.subMeshes&&e.subMeshes.length>0&&(n.renderList?.push(e),n.setMaterialForRendering(e,o))}}if(n)for(const t of e)-1===this._scene.customRenderTargets.indexOf(t)&&this._scene.customRenderTargets.push(t);else this._renderTargets=this._renderTargets.concat(e)}resize(){this._voxelSlabDebugRT?.resize({width:this._scene.getEngine().getRenderWidth(),height:this._scene.getEngine().getRenderHeight()})}dispose(){this._disposeVoxelTextures(),this._voxelSlabDebugRT&&(this._removeVoxelRTs([this._voxelSlabDebugRT]),this._voxelSlabDebugRT.dispose()),this._voxelDebugPass&&this._voxelDebugPass.dispose()}}var m=s(95616),x=s(45503),T=s(28986),b=(s(75007),s(6739),s(10633)),v=s(30492),E=s(80467);const P=["world","mBones","viewProjection","diffuseMatrix","view","previousWorld","previousViewProjection","mPreviousBones","bumpMatrix","reflectivityMatrix","albedoMatrix","reflectivityColor","albedoColor","metallic","glossiness","vTangentSpaceParams","vBumpInfos","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","boneTextureWidth"];(0,v.Ll)(P);class R{get normalsAreUnsigned(){return this._normalsAreUnsigned}_linkPrePassRenderer(e){this._linkedWithPrePass=!0,this._prePassRenderer=e,this._multiRenderTarget&&(this._multiRenderTarget.onClearObservable.clear(),this._multiRenderTarget.onClearObservable.add(()=>{}))}_unlinkPrePassRenderer(){this._linkedWithPrePass=!1,this._createRenderTargets()}_resetLayout(){this._enableDepth=!0,this._enableNormal=!0,this._enablePosition=!1,this._enableReflectivity=!1,this._enableVelocity=!1,this._enableVelocityLinear=!1,this._enableScreenspaceDepth=!1,this._attachmentsFromPrePass=[]}_forceTextureType(e,t){e===R.POSITION_TEXTURE_TYPE?(this._positionIndex=t,this._enablePosition=!0):e===R.VELOCITY_TEXTURE_TYPE?(this._velocityIndex=t,this._enableVelocity=!0):e===R.VELOCITY_LINEAR_TEXTURE_TYPE?(this._velocityLinearIndex=t,this._enableVelocityLinear=!0):e===R.REFLECTIVITY_TEXTURE_TYPE?(this._reflectivityIndex=t,this._enableReflectivity=!0):e===R.DEPTH_TEXTURE_TYPE?(this._depthIndex=t,this._enableDepth=!0):e===R.NORMAL_TEXTURE_TYPE?(this._normalIndex=t,this._enableNormal=!0):e===R.SCREENSPACE_DEPTH_TEXTURE_TYPE&&(this._screenspaceDepthIndex=t,this._enableScreenspaceDepth=!0)}_setAttachments(e){this._attachmentsFromPrePass=e}_linkInternalTexture(e){this._multiRenderTarget.setInternalTexture(e,0,!1)}get renderList(){return this._multiRenderTarget.renderList}set renderList(e){this._multiRenderTarget.renderList=e}get isSupported(){return this._multiRenderTarget.isSupported}getTextureIndex(e){switch(e){case R.POSITION_TEXTURE_TYPE:return this._positionIndex;case R.VELOCITY_TEXTURE_TYPE:return this._velocityIndex;case R.VELOCITY_LINEAR_TEXTURE_TYPE:return this._velocityLinearIndex;case R.REFLECTIVITY_TEXTURE_TYPE:return this._reflectivityIndex;case R.DEPTH_TEXTURE_TYPE:return this._depthIndex;case R.NORMAL_TEXTURE_TYPE:return this._normalIndex;case R.SCREENSPACE_DEPTH_TEXTURE_TYPE:return this._screenspaceDepthIndex;default:return-1}}get enableDepth(){return this._enableDepth}set enableDepth(e){this._enableDepth=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get enableNormal(){return this._enableNormal}set enableNormal(e){this._enableNormal=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get enablePosition(){return this._enablePosition}set enablePosition(e){this._enablePosition=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get enableVelocity(){return this._enableVelocity}set enableVelocity(e){this._enableVelocity=e,e||(this._previousTransformationMatrices={}),this._linkedWithPrePass||(this.dispose(),this._createRenderTargets()),this._scene.needsPreviousWorldMatrices=e}get enableVelocityLinear(){return this._enableVelocityLinear}set enableVelocityLinear(e){this._enableVelocityLinear=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get enableReflectivity(){return this._enableReflectivity}set enableReflectivity(e){this._enableReflectivity=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get enableScreenspaceDepth(){return this._enableScreenspaceDepth}set enableScreenspaceDepth(e){this._enableScreenspaceDepth=e,this._linkedWithPrePass||(this.dispose(),this._createRenderTargets())}get scene(){return this._scene}get ratio(){return"object"==typeof this._ratioOrDimensions?1:this._ratioOrDimensions}get shaderLanguage(){return this._shaderLanguage}constructor(e,t=1,s=15,i){this._previousTransformationMatrices={},this._previousBonesTransformationMatrices={},this.excludedSkinnedMeshesFromVelocity=[],this.renderTransparentMeshes=!0,this.generateNormalsInWorldSpace=!1,this._normalsAreUnsigned=!1,this._resizeObserver=null,this._enableDepth=!0,this._enableNormal=!0,this._enablePosition=!1,this._enableVelocity=!1,this._enableVelocityLinear=!1,this._enableReflectivity=!1,this._enableScreenspaceDepth=!1,this._clearColor=new u.ov(0,0,0,0),this._clearDepthColor=new u.ov(0,0,0,1),this._positionIndex=-1,this._velocityIndex=-1,this._velocityLinearIndex=-1,this._reflectivityIndex=-1,this._depthIndex=-1,this._normalIndex=-1,this._screenspaceDepthIndex=-1,this._linkedWithPrePass=!1,this.useSpecificClearForDepthTexture=!1,this._shaderLanguage=0,this._shadersLoaded=!1,this._scene=e,this._ratioOrDimensions=t,this._useUbo=e.getEngine().supportsUniformBuffers,this._depthFormat=s,this._textureTypesAndFormats=i||{},this._initShaderSourceAsync(),R._SceneComponentInitialization(this._scene),this._createRenderTargets()}async _initShaderSourceAsync(){this._scene.getEngine().isWebGPU&&!R.ForceGLSL?(this._shaderLanguage=1,await Promise.all([s.e(2564).then(s.bind(s,2564)),s.e(8574).then(s.bind(s,38574))])):await Promise.all([Promise.resolve().then(s.bind(s,6739)),Promise.resolve().then(s.bind(s,75007))]),this._shadersLoaded=!0}isReady(e,t){if(!this._shadersLoaded)return!1;const s=e.getMaterial();if(s&&s.disableDepthWrite)return!1;const i=[],r=[m.R.PositionKind,m.R.NormalKind],n=e.getMesh();let a=!1,o=!1;if(s){let e=!1;if(s.needAlphaTestingForMesh(n)&&s.getAlphaTestTexture()&&(i.push("#define ALPHATEST"),i.push(`#define ALPHATEST_UV${s.getAlphaTestTexture().coordinatesIndex+1}`),e=!0),(s.bumpTexture||s.normalTexture)&&b.h.BumpTextureEnabled){const t=s.bumpTexture||s.normalTexture;i.push("#define BUMP"),i.push(`#define BUMP_UV${t.coordinatesIndex+1}`),e=!0}if(this._enableReflectivity){let t=!1;"PBRMetallicRoughnessMaterial"===s.getClassName()?(s.metallicRoughnessTexture&&(i.push("#define ORMTEXTURE"),i.push(`#define REFLECTIVITY_UV${s.metallicRoughnessTexture.coordinatesIndex+1}`),i.push("#define METALLICWORKFLOW"),e=!0,t=!0),null!=s.metallic&&(i.push("#define METALLIC"),i.push("#define METALLICWORKFLOW"),t=!0),null!=s.roughness&&(i.push("#define ROUGHNESS"),i.push("#define METALLICWORKFLOW"),t=!0),t&&(s.baseTexture&&(i.push("#define ALBEDOTEXTURE"),i.push(`#define ALBEDO_UV${s.baseTexture.coordinatesIndex+1}`),s.baseTexture.gammaSpace&&i.push("#define GAMMAALBEDO"),e=!0),s.baseColor&&i.push("#define ALBEDOCOLOR"))):"PBRSpecularGlossinessMaterial"===s.getClassName()?(s.specularGlossinessTexture?(i.push("#define SPECULARGLOSSINESSTEXTURE"),i.push(`#define REFLECTIVITY_UV${s.specularGlossinessTexture.coordinatesIndex+1}`),e=!0,s.specularGlossinessTexture.gammaSpace&&i.push("#define GAMMAREFLECTIVITYTEXTURE")):s.specularColor&&i.push("#define REFLECTIVITYCOLOR"),null!=s.glossiness&&i.push("#define GLOSSINESS")):"PBRMaterial"===s.getClassName()?(s.metallicTexture&&(i.push("#define ORMTEXTURE"),i.push(`#define REFLECTIVITY_UV${s.metallicTexture.coordinatesIndex+1}`),i.push("#define METALLICWORKFLOW"),e=!0,t=!0),null!=s.metallic&&(i.push("#define METALLIC"),i.push("#define METALLICWORKFLOW"),t=!0),null!=s.roughness&&(i.push("#define ROUGHNESS"),i.push("#define METALLICWORKFLOW"),t=!0),t?(s.albedoTexture&&(i.push("#define ALBEDOTEXTURE"),i.push(`#define ALBEDO_UV${s.albedoTexture.coordinatesIndex+1}`),s.albedoTexture.gammaSpace&&i.push("#define GAMMAALBEDO"),e=!0),s.albedoColor&&i.push("#define ALBEDOCOLOR")):(s.reflectivityTexture?(i.push("#define SPECULARGLOSSINESSTEXTURE"),i.push(`#define REFLECTIVITY_UV${s.reflectivityTexture.coordinatesIndex+1}`),s.reflectivityTexture.gammaSpace&&i.push("#define GAMMAREFLECTIVITYTEXTURE"),e=!0):s.reflectivityColor&&i.push("#define REFLECTIVITYCOLOR"),null!=s.microSurface&&i.push("#define GLOSSINESS"))):"StandardMaterial"===s.getClassName()&&(s.specularTexture&&(i.push("#define REFLECTIVITYTEXTURE"),i.push(`#define REFLECTIVITY_UV${s.specularTexture.coordinatesIndex+1}`),s.specularTexture.gammaSpace&&i.push("#define GAMMAREFLECTIVITYTEXTURE"),e=!0),s.specularColor&&i.push("#define REFLECTIVITYCOLOR"))}e&&(i.push("#define NEED_UV"),n.isVerticesDataPresent(m.R.UVKind)&&(r.push(m.R.UVKind),i.push("#define UV1"),a=!0),n.isVerticesDataPresent(m.R.UV2Kind)&&(r.push(m.R.UV2Kind),i.push("#define UV2"),o=!0))}this._enableDepth&&(i.push("#define DEPTH"),i.push("#define DEPTH_INDEX "+this._depthIndex)),this._enableNormal&&(i.push("#define NORMAL"),i.push("#define NORMAL_INDEX "+this._normalIndex)),this._enablePosition&&(i.push("#define POSITION"),i.push("#define POSITION_INDEX "+this._positionIndex)),this._enableVelocity&&(i.push("#define VELOCITY"),i.push("#define VELOCITY_INDEX "+this._velocityIndex),-1===this.excludedSkinnedMeshesFromVelocity.indexOf(n)&&i.push("#define BONES_VELOCITY_ENABLED")),this._enableVelocityLinear&&(i.push("#define VELOCITY_LINEAR"),i.push("#define VELOCITY_LINEAR_INDEX "+this._velocityLinearIndex),-1===this.excludedSkinnedMeshesFromVelocity.indexOf(n)&&i.push("#define BONES_VELOCITY_ENABLED")),this._enableReflectivity&&(i.push("#define REFLECTIVITY"),i.push("#define REFLECTIVITY_INDEX "+this._reflectivityIndex)),this._enableScreenspaceDepth&&-1!==this._screenspaceDepthIndex&&(i.push("#define SCREENSPACE_DEPTH_INDEX "+this._screenspaceDepthIndex),i.push("#define SCREENSPACE_DEPTH")),this.generateNormalsInWorldSpace&&i.push("#define NORMAL_WORLDSPACE"),this._normalsAreUnsigned&&i.push("#define ENCODE_NORMAL"),n.useBones&&n.computeBonesUsingShaders&&n.skeleton?(r.push(m.R.MatricesIndicesKind),r.push(m.R.MatricesWeightsKind),n.numBoneInfluencers>4&&(r.push(m.R.MatricesIndicesExtraKind),r.push(m.R.MatricesWeightsExtraKind)),i.push("#define NUM_BONE_INFLUENCERS "+n.numBoneInfluencers),i.push("#define BONETEXTURE "+n.skeleton.isUsingTextureForMatrices),i.push("#define BonesPerMesh "+(n.skeleton.bones.length+1))):(i.push("#define NUM_BONE_INFLUENCERS 0"),i.push("#define BONETEXTURE false"),i.push("#define BonesPerMesh 0"));const l=n.morphTargetManager?(0,E.Dk)(n.morphTargetManager,i,r,n,!0,!0,!1,a,o,!1):0;t&&(i.push("#define INSTANCES"),(0,E.te)(r,this._enableVelocity||this._enableVelocityLinear),e.getRenderingMesh().hasThinInstances&&i.push("#define THIN_INSTANCES")),this._linkedWithPrePass?i.push("#define SCENE_MRT_COUNT "+this._attachmentsFromPrePass.length):i.push("#define SCENE_MRT_COUNT "+this._multiRenderTarget.textures.length),(0,v.r4)(s,this._scene,i);const d=this._scene.getEngine(),h=e._getDrawWrapper(void 0,!0),u=h.defines,_=i.join("\n");return u!==_&&h.setEffect(d.createEffect("geometry",{attributes:r,uniformsNames:P,samplers:["diffuseSampler","bumpSampler","reflectivitySampler","albedoSampler","morphTargets","boneSampler"],defines:_,onCompiled:null,fallbacks:null,onError:null,uniformBuffersNames:["Scene"],indexParameters:{buffersCount:this._multiRenderTarget.textures.length-1,maxSimultaneousMorphTargets:l},shaderLanguage:this.shaderLanguage},d),_),h.effect.isReady()}getGBuffer(){return this._multiRenderTarget}get samples(){return this._multiRenderTarget.samples}set samples(e){this._multiRenderTarget.samples=e}dispose(){if(this._resizeObserver){this._scene.getEngine().onResizeObservable.remove(this._resizeObserver),this._resizeObserver=null}this.getGBuffer().dispose()}_assignRenderTargetIndices(){const e=[],t=[];let s=0;return this._enableDepth&&(this._depthIndex=s,s++,e.push("gBuffer_Depth"),t.push(this._textureTypesAndFormats[R.DEPTH_TEXTURE_TYPE])),this._enableNormal&&(this._normalIndex=s,s++,e.push("gBuffer_Normal"),t.push(this._textureTypesAndFormats[R.NORMAL_TEXTURE_TYPE])),this._enablePosition&&(this._positionIndex=s,s++,e.push("gBuffer_Position"),t.push(this._textureTypesAndFormats[R.POSITION_TEXTURE_TYPE])),this._enableVelocity&&(this._velocityIndex=s,s++,e.push("gBuffer_Velocity"),t.push(this._textureTypesAndFormats[R.VELOCITY_TEXTURE_TYPE])),this._enableVelocityLinear&&(this._velocityLinearIndex=s,s++,e.push("gBuffer_VelocityLinear"),t.push(this._textureTypesAndFormats[R.VELOCITY_LINEAR_TEXTURE_TYPE])),this._enableReflectivity&&(this._reflectivityIndex=s,s++,e.push("gBuffer_Reflectivity"),t.push(this._textureTypesAndFormats[R.REFLECTIVITY_TEXTURE_TYPE])),this._enableScreenspaceDepth&&(this._screenspaceDepthIndex=s,s++,e.push("gBuffer_ScreenspaceDepth"),t.push(this._textureTypesAndFormats[R.SCREENSPACE_DEPTH_TEXTURE_TYPE])),[s,e,t]}_createRenderTargets(){const e=this._scene.getEngine(),[t,s,i]=this._assignRenderTargetIndices();let a=0;e._caps.textureFloat&&e._caps.textureFloatLinearFiltering?a=1:e._caps.textureHalfFloat&&e._caps.textureHalfFloatLinearFiltering&&(a=2);const o=void 0!==this._ratioOrDimensions.width?this._ratioOrDimensions:{width:e.getRenderWidth()*this._ratioOrDimensions,height:e.getRenderHeight()*this._ratioOrDimensions},l=[],d=[];for(const e of i)e?(l.push(e.textureType),d.push(e.textureFormat)):(l.push(a),d.push(5));if(this._normalsAreUnsigned=11===l[R.NORMAL_TEXTURE_TYPE]||13===l[R.NORMAL_TEXTURE_TYPE],this._multiRenderTarget=new h("gBuffer",o,t,this._scene,{generateMipMaps:!1,generateDepthTexture:!0,types:l,formats:d,depthTextureFormat:this._depthFormat},s.concat("gBuffer_DepthBuffer")),!this.isSupported)return;this._multiRenderTarget.wrapU=n.g.CLAMP_ADDRESSMODE,this._multiRenderTarget.wrapV=n.g.CLAMP_ADDRESSMODE,this._multiRenderTarget.refreshRate=1,this._multiRenderTarget.renderParticles=!1,this._multiRenderTarget.renderList=null;const u=[!0],_=[!1],c=[!0];for(let e=1;e<t;++e)u.push(!0),c.push(!1),_.push(!0);const f=e.buildTextureLayout(u),g=e.buildTextureLayout(_),p=e.buildTextureLayout(c);this._multiRenderTarget.onClearObservable.add(e=>{e.bindAttachments(this.useSpecificClearForDepthTexture?g:f),e.clear(this._clearColor,!0,!0,!0),this.useSpecificClearForDepthTexture&&(e.bindAttachments(p),e.clear(this._clearDepthColor,!0,!0,!0)),e.bindAttachments(f)}),this._resizeObserver=e.onResizeObservable.add(()=>{if(this._multiRenderTarget){const t=void 0!==this._ratioOrDimensions.width?this._ratioOrDimensions:{width:e.getRenderWidth()*this._ratioOrDimensions,height:e.getRenderHeight()*this._ratioOrDimensions};this._multiRenderTarget.resize(t)}});const m=e=>{const t=e.getRenderingMesh(),s=e.getEffectiveMesh(),i=this._scene,n=i.getEngine(),a=e.getMaterial();if(!a)return;if(s._internalAbstractMeshDataInfo._isActiveIntermediate=!1,(this._enableVelocity||this._enableVelocityLinear)&&!this._previousTransformationMatrices[s.uniqueId]&&(this._previousTransformationMatrices[s.uniqueId]={world:r.uq.Identity(),viewProjection:i.getTransformMatrix()},t.skeleton)){const e=t.skeleton.getTransformMatrices(t);this._previousBonesTransformationMatrices[t.uniqueId]=this._copyBonesTransformationMatrices(e,new Float32Array(e.length))}const o=t._getInstancesRenderList(e._id,!!e.getReplacementMesh());if(o.mustReturn)return;const l=n.getCaps().instancedArrays&&(null!==o.visibleInstances[e._id]||t.hasThinInstances),d=s.getWorldMatrix();if(this.isReady(e,l)){const r=e._getDrawWrapper();if(!r)return;const h=r.effect;let u;n.enableEffect(r),l||t._bind(e,h,a.fillMode),this._useUbo?((0,E._8)(h,this._scene.getSceneUniformBuffer()),this._scene.finalizeSceneUbo()):(h.setMatrix("viewProjection",i.getTransformMatrix()),h.setMatrix("view",i.getViewMatrix()));if(t._instanceDataStorage.isFrozen||!a.backFaceCulling&&null===a.sideOrientation)u=t._effectiveSideOrientation;else{const e=s._getWorldMatrixDeterminant();u=a._getEffectiveOrientation(t),e<0&&(u=u===T.i.ClockWiseSideOrientation?T.i.CounterClockWiseSideOrientation:T.i.ClockWiseSideOrientation)}if(a._preBind(r,u),a.needAlphaTestingForMesh(s)){const e=a.getAlphaTestTexture();e&&(h.setTexture("diffuseSampler",e),h.setMatrix("diffuseMatrix",e.getTextureMatrix()))}if((a.bumpTexture||a.normalTexture)&&i.getEngine().getCaps().standardDerivatives&&b.h.BumpTextureEnabled){const e=a.bumpTexture||a.normalTexture;h.setFloat3("vBumpInfos",e.coordinatesIndex,1/e.level,a.parallaxScaleBias),h.setMatrix("bumpMatrix",e.getTextureMatrix()),h.setTexture("bumpSampler",e),h.setFloat2("vTangentSpaceParams",a.invertNormalMapX?-1:1,a.invertNormalMapY?-1:1)}if(this._enableReflectivity&&("PBRMetallicRoughnessMaterial"===a.getClassName()?(null!==a.metallicRoughnessTexture&&(h.setTexture("reflectivitySampler",a.metallicRoughnessTexture),h.setMatrix("reflectivityMatrix",a.metallicRoughnessTexture.getTextureMatrix())),null!==a.metallic&&h.setFloat("metallic",a.metallic),null!==a.roughness&&h.setFloat("glossiness",1-a.roughness),null!==a.baseTexture&&(h.setTexture("albedoSampler",a.baseTexture),h.setMatrix("albedoMatrix",a.baseTexture.getTextureMatrix())),null!==a.baseColor&&h.setColor3("albedoColor",a.baseColor)):"PBRSpecularGlossinessMaterial"===a.getClassName()?(null!==a.specularGlossinessTexture?(h.setTexture("reflectivitySampler",a.specularGlossinessTexture),h.setMatrix("reflectivityMatrix",a.specularGlossinessTexture.getTextureMatrix())):null!==a.specularColor&&h.setColor3("reflectivityColor",a.specularColor),null!==a.glossiness&&h.setFloat("glossiness",a.glossiness)):"PBRMaterial"===a.getClassName()?(null!==a.metallicTexture&&(h.setTexture("reflectivitySampler",a.metallicTexture),h.setMatrix("reflectivityMatrix",a.metallicTexture.getTextureMatrix())),null!==a.metallic&&h.setFloat("metallic",a.metallic),null!==a.roughness&&h.setFloat("glossiness",1-a.roughness),null!==a.roughness||null!==a.metallic||null!==a.metallicTexture?(null!==a.albedoTexture&&(h.setTexture("albedoSampler",a.albedoTexture),h.setMatrix("albedoMatrix",a.albedoTexture.getTextureMatrix())),null!==a.albedoColor&&h.setColor3("albedoColor",a.albedoColor)):(null!==a.reflectivityTexture?(h.setTexture("reflectivitySampler",a.reflectivityTexture),h.setMatrix("reflectivityMatrix",a.reflectivityTexture.getTextureMatrix())):null!==a.reflectivityColor&&h.setColor3("reflectivityColor",a.reflectivityColor),null!==a.microSurface&&h.setFloat("glossiness",a.microSurface))):"StandardMaterial"===a.getClassName()&&(null!==a.specularTexture&&(h.setTexture("reflectivitySampler",a.specularTexture),h.setMatrix("reflectivityMatrix",a.specularTexture.getTextureMatrix())),null!==a.specularColor&&h.setColor3("reflectivityColor",a.specularColor))),(0,v.ij)(h,a,this._scene),t.useBones&&t.computeBonesUsingShaders&&t.skeleton){const e=t.skeleton;if(e.isUsingTextureForMatrices&&h.getUniformIndex("boneTextureWidth")>-1){const s=e.getTransformMatrixTexture(t);h.setTexture("boneSampler",s),h.setFloat("boneTextureWidth",4*(e.bones.length+1))}else h.setMatrices("mBones",t.skeleton.getTransformMatrices(t));(this._enableVelocity||this._enableVelocityLinear)&&h.setMatrices("mPreviousBones",this._previousBonesTransformationMatrices[t.uniqueId])}(0,E.nR)(t,h),t.morphTargetManager&&t.morphTargetManager.isUsingTextureForTargets&&t.morphTargetManager._bind(h),(this._enableVelocity||this._enableVelocityLinear)&&(h.setMatrix("previousWorld",this._previousTransformationMatrices[s.uniqueId].world),h.setMatrix("previousViewProjection",this._previousTransformationMatrices[s.uniqueId].viewProjection)),l&&t.hasThinInstances&&h.setMatrix("world",d),t._processRendering(s,e,h,a.fillMode,o,l,(e,t)=>{e||h.setMatrix("world",t)})}(this._enableVelocity||this._enableVelocityLinear)&&(this._previousTransformationMatrices[s.uniqueId].world=d.clone(),this._previousTransformationMatrices[s.uniqueId].viewProjection=this._scene.getTransformMatrix().clone(),t.skeleton&&this._copyBonesTransformationMatrices(t.skeleton.getTransformMatrices(t),this._previousBonesTransformationMatrices[s.uniqueId]))};this._multiRenderTarget.customIsReadyFunction=(t,s,i)=>{if((i||0===s)&&t.subMeshes)for(let s=0;s<t.subMeshes.length;++s){const i=t.subMeshes[s],r=i.getMaterial(),n=i.getRenderingMesh();if(!r)continue;const a=n._getInstancesRenderList(i._id,!!i.getReplacementMesh()),o=e.getCaps().instancedArrays&&(null!==a.visibleInstances[i._id]||n.hasThinInstances);if(!this.isReady(i,o))return!1}return!0},this._multiRenderTarget.customRenderFunction=(t,s,i,r)=>{let n;if(this._linkedWithPrePass){if(!this._prePassRenderer.enabled)return;this._scene.getEngine().bindAttachments(this._attachmentsFromPrePass)}if(r.length){for(e.setColorWrite(!1),n=0;n<r.length;n++)m(r.data[n]);e.setColorWrite(!0)}for(n=0;n<t.length;n++)m(t.data[n]);for(e.setDepthWrite(!1),n=0;n<s.length;n++)m(s.data[n]);if(this.renderTransparentMeshes)for(n=0;n<i.length;n++)m(i.data[n]);e.setDepthWrite(!0)}}_copyBonesTransformationMatrices(e,t){for(let s=0;s<e.length;s++)t[s]=e[s];return t}}R.ForceGLSL=!1,R.DEPTH_TEXTURE_TYPE=0,R.NORMAL_TEXTURE_TYPE=1,R.POSITION_TEXTURE_TYPE=2,R.VELOCITY_TEXTURE_TYPE=3,R.REFLECTIVITY_TEXTURE_TYPE=4,R.SCREENSPACE_DEPTH_TEXTURE_TYPE=5,R.VELOCITY_LINEAR_TEXTURE_TYPE=6,R._SceneComponentInitialization=e=>{throw(0,x.n)("GeometryBufferRendererSceneComponent")};class S{get voxelShadowOpacity(){return this._voxelShadowOpacity}set voxelShadowOpacity(e){this._voxelShadowOpacity=e}get ssShadowOpacity(){return this._ssShadowOpacity}set ssShadowOpacity(e){this._ssShadowOpacity=e}get sssSamples(){return this._sssSamples}set sssSamples(e){this._sssSamples=e}get sssStride(){return this._sssStride}set sssStride(e){this._sssStride=e}get sssMaxDist(){return this._sssMaxDist}set sssMaxDist(e){this._sssMaxDist=e}get sssThickness(){return this._sssThickness}set sssThickness(e){this._sssThickness=e}get voxelNormalBias(){return this._voxelNormalBias}set voxelNormalBias(e){this._voxelNormalBias=e}get voxelDirectionBias(){return this._voxelDirectionBias}set voxelDirectionBias(e){this._voxelDirectionBias=e}get sampleDirections(){return this._sampleDirections}set sampleDirections(e){this._sampleDirections=e}get envRotation(){return this._envRotation}set envRotation(e){this._envRotation=e}getOutputTexture(){return this._outputTexture}getDebugPassPP(){return this._debugPassPP||this._createDebugPass(),this._debugPassPP}get debugPassName(){return this._debugPassName}setWorldScaleMatrix(e){this._invWorldScaleMatrix=e}set coloredShadows(e){this._coloredShadows=e}get coloredShadows(){return this._coloredShadows}setDebugDisplayParams(e,t,s,i){this._debugSizeParams.set(e,t,s,i)}_createDebugPass(){const e=this._engine.isWebGPU;if(!this._debugPassPP){const t={width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight(),uniforms:["sizeParams"],samplers:["debugSampler"],engine:this._engine,reusable:!0,shaderLanguage:e?1:0,extraInitializations:(e,t)=>{e?t.push(s.e(2730).then(s.bind(s,2730))):t.push(s.e(2495).then(s.bind(s,22495)))}};this._debugPassPP=new c.w(this.debugPassName,"iblShadowDebug",t),this._debugPassPP.autoClear=!1,this._debugPassPP.onApplyObservable.add(e=>{e.setTexture("debugSampler",this._outputTexture),e.setVector4("sizeParams",this._debugSizeParams)})}}constructor(e,t){this._voxelShadowOpacity=1,this._sssSamples=16,this._sssStride=8,this._sssMaxDist=.05,this._sssThickness=.5,this._ssShadowOpacity=1,this._cameraInvView=r.uq.Identity(),this._cameraInvProj=r.uq.Identity(),this._invWorldScaleMatrix=r.uq.Identity(),this._frameId=0,this._sampleDirections=4,this._shadowParameters=new r.IU(0,0,0,0),this._sssParameters=new r.IU(0,0,0,0),this._opacityParameters=new r.IU(0,0,0,0),this._voxelBiasParameters=new r.IU(0,0,0,0),this._voxelNormalBias=1.4,this._voxelDirectionBias=1.75,this.enabled=!0,this.debugEnabled=!1,this._debugPassName="Voxel Tracing Debug Pass",this._envRotation=0,this._coloredShadows=!1,this._debugVoxelMarchEnabled=!1,this._debugSizeParams=new r.IU(0,0,0,0),this._renderWhenGBufferReady=null,this._scene=e,this._engine=e.getEngine(),this._renderPipeline=t,this._createTextures()}_createTextures(){const e=this._createDefines(),t=this._engine.isWebGPU,i={type:0,format:5,samplingMode:1,generateDepthBuffer:!1,shaderLanguage:t?1:0,extraInitializationsAsync:async()=>{t?await Promise.all([s.e(9461).then(s.bind(s,9461))]):await Promise.all([s.e(6990).then(s.bind(s,16990))])}};this._outputTexture=new f.p("voxelTracingPass",{width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight()},"iblShadowVoxelTracing",this._scene,i),this._outputTexture.refreshRate=-1,this._outputTexture.autoClear=!1,this._outputTexture.defines=e,this._setBindings(this._scene.activeCamera),this._renderWhenGBufferReady=this._render.bind(this),this._renderPipeline.onVoxelizationCompleteObservable.addOnce(()=>{this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady)})}_createDefines(){let e="";return this._scene.useRightHandedSystem&&(e+="#define RIGHT_HANDED\n"),this._debugVoxelMarchEnabled&&(e+="#define VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION 1u\n"),this._coloredShadows&&(e+="#define COLOR_SHADOWS 1u\n"),e}_setBindings(e){this._outputTexture.defines=this._createDefines(),this._outputTexture.setMatrix("viewMtx",e.getViewMatrix()),this._outputTexture.setMatrix("projMtx",e.getProjectionMatrix()),e.getProjectionMatrix().invertToRef(this._cameraInvProj),e.getViewMatrix().invertToRef(this._cameraInvView),this._outputTexture.setMatrix("invProjMtx",this._cameraInvProj),this._outputTexture.setMatrix("invViewMtx",this._cameraInvView),this._outputTexture.setMatrix("wsNormalizationMtx",this._invWorldScaleMatrix),this._frameId++;let t=0;this._scene.environmentTexture&&(t=this._scene.environmentTexture.rotationY??0),t=this._scene.useRightHandedSystem?-(t+.5*Math.PI):t-.5*Math.PI,t%=2*Math.PI,this._shadowParameters.set(this._sampleDirections,this._frameId,1,t),this._outputTexture.setVector4("shadowParameters",this._shadowParameters);const s=this._renderPipeline._getVoxelGridTexture(),i=Math.floor(Math.log2(s.getSize().width));this._voxelBiasParameters.set(this._voxelNormalBias,this._voxelDirectionBias,i,0),this._outputTexture.setVector4("voxelBiasParameters",this._voxelBiasParameters),this._sssParameters.set(this._sssSamples,this._sssStride,this._sssMaxDist,this._sssThickness),this._outputTexture.setVector4("sssParameters",this._sssParameters),this._opacityParameters.set(this._voxelShadowOpacity,this._ssShadowOpacity,0,0),this._outputTexture.setVector4("shadowOpacity",this._opacityParameters),this._outputTexture.setTexture("voxelGridSampler",s),this._outputTexture.setTexture("blueNoiseSampler",this._renderPipeline._getNoiseTexture());const r=this._scene.iblCdfGenerator;if(!r)return a.V.Warn("IBLShadowsVoxelTracingPass: Can't bind for render because iblCdfGenerator is not enabled."),!1;this._outputTexture.setTexture("icdfSampler",r.getIcdfTexture()),this._coloredShadows&&this._scene.environmentTexture&&this._outputTexture.setTexture("iblSampler",this._scene.environmentTexture);const n=this._scene.geometryBufferRenderer;if(!n)return a.V.Warn("IBLShadowsVoxelTracingPass: Can't bind for render because GeometryBufferRenderer is not enabled."),!1;const o=n.getTextureIndex(R.SCREENSPACE_DEPTH_TEXTURE_TYPE);this._outputTexture.setTexture("depthSampler",n.getGBuffer().textures[o]);const l=n.getTextureIndex(R.NORMAL_TEXTURE_TYPE);return this._outputTexture.setTexture("worldNormalSampler",n.getGBuffer().textures[l]),!0}_render(){this.enabled&&this._outputTexture.isReady()&&this._outputTexture.getEffect()?.isReady()&&this._setBindings(this._scene.activeCamera)&&this._outputTexture.render()}resize(e=1){const t={width:Math.max(1,Math.floor(this._engine.getRenderWidth()*e)),height:Math.max(1,Math.floor(this._engine.getRenderHeight()*e))};this._outputTexture.getSize().width===t.width&&this._outputTexture.getSize().height===t.height||this._outputTexture.resize(t,!1)}isReady(){return this._outputTexture.isReady()&&!(this._debugPassPP&&!this._debugPassPP.isReady())&&this._scene.iblCdfGenerator&&this._scene.iblCdfGenerator.getIcdfTexture().isReady()&&this._renderPipeline._getVoxelGridTexture().isReady()}dispose(){if(this._scene.geometryBufferRenderer&&this._renderWhenGBufferReady){this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady)}this._outputTexture.dispose(),this._debugPassPP&&this._debugPassPP.dispose()}}class M{getOutputTexture(){return this._outputTexture}getDebugPassPP(){return this._debugPassPP||this._createDebugPass(),this._debugPassPP}get debugPassName(){return this._debugPassName}setWorldScale(e){this._worldScale=e}setDebugDisplayParams(e,t,s,i){this._debugSizeParams.set(e,t,s,i)}_createDebugPass(){if(!this._debugPassPP){const e=this._engine.isWebGPU,t={width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight(),textureFormat:5,textureType:0,samplingMode:1,uniforms:["sizeParams"],samplers:["debugSampler"],engine:this._engine,reusable:!1,shaderLanguage:e?1:0,extraInitializations:(e,t)=>{e?t.push(s.e(2730).then(s.bind(s,2730))):t.push(s.e(2495).then(s.bind(s,22495)))}};this._debugPassPP=new c.w(this.debugPassName,"iblShadowDebug",t),this._debugPassPP.autoClear=!1,this._debugPassPP.onApplyObservable.add(e=>{e.setTexture("debugSampler",this._outputTexture),e.setVector4("sizeParams",this._debugSizeParams)})}}constructor(e,t){this._worldScale=1,this._blurParameters=new r.IU(0,0,0,0),this.enabled=!0,this._debugPassName="Spatial Blur Debug Pass",this.debugEnabled=!1,this._debugSizeParams=new r.IU(0,0,0,0),this._renderWhenGBufferReady=null,this._scene=e,this._engine=e.getEngine(),this._renderPipeline=t,this._createTextures()}_createTextures(){const e=this._engine.isWebGPU,t={type:0,format:5,samplingMode:1,generateDepthBuffer:!1,generateMipMaps:!1,shaderLanguage:e?1:0,extraInitializationsAsync:async()=>{e?await Promise.all([s.e(8772).then(s.bind(s,46391))]):await Promise.all([s.e(8605).then(s.bind(s,30986))])}};this._outputTexture=new f.p("spatialBlurPass",{width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight()},"iblShadowSpatialBlur",this._scene,t,!1,!1,0),this._outputTexture.refreshRate=-1,this._outputTexture.autoClear=!1,this._setBindings(),this._renderWhenGBufferReady=this._render.bind(this),this._renderPipeline.onVoxelizationCompleteObservable.addOnce(()=>{this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady)})}_setBindings(){this._outputTexture.setTexture("voxelTracingSampler",this._renderPipeline._getVoxelTracingTexture());this._blurParameters.set(1,this._worldScale,0,0),this._outputTexture.setVector4("blurParameters",this._blurParameters);const e=this._scene.geometryBufferRenderer;if(!e)return!1;const t=e.getTextureIndex(R.SCREENSPACE_DEPTH_TEXTURE_TYPE);this._outputTexture.setTexture("depthSampler",e.getGBuffer().textures[t]);const s=e.getTextureIndex(R.NORMAL_TEXTURE_TYPE);return this._outputTexture.setTexture("worldNormalSampler",e.getGBuffer().textures[s]),!0}_render(){this.enabled&&this._outputTexture.isReady()&&this._outputTexture.getEffect()?.isReady()&&this._setBindings()&&this._outputTexture.render()}resize(e=1){const t={width:Math.max(1,Math.floor(this._engine.getRenderWidth()*e)),height:Math.max(1,Math.floor(this._engine.getRenderHeight()*e))};this._outputTexture.getSize().width===t.width&&this._outputTexture.getSize().height===t.height||this._outputTexture.resize(t,!1)}isReady(){return this._outputTexture.isReady()&&!(this._debugPassPP&&!this._debugPassPP.isReady())}dispose(){if(this._scene.geometryBufferRenderer&&this._renderWhenGBufferReady){this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady)}this._outputTexture.dispose(),this._debugPassPP&&this._debugPassPP.dispose()}}class y{getOutputTexture(){return this._outputTexture}getDebugPassPP(){return this._debugPassPP||this._createDebugPass(),this._debugPassPP}get debugPassName(){return this._debugPassName}get remanence(){return this._remanence}set remanence(e){this._remanence=e}get reset(){return this._reset}set reset(e){this._reset=e}set isMoving(e){this._isMoving=e}setDebugDisplayParams(e,t,s,i){this._debugSizeParams.set(e,t,s,i)}_createDebugPass(){if(!this._debugPassPP){const e=this._engine.isWebGPU,t={width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight(),textureFormat:5,textureType:0,samplingMode:1,uniforms:["sizeParams"],samplers:["debugSampler"],engine:this._engine,reusable:!1,shaderLanguage:e?1:0,extraInitializations:(e,t)=>{e?t.push(s.e(2730).then(s.bind(s,2730))):t.push(s.e(2495).then(s.bind(s,22495)))}};this._debugPassPP=new c.w(this.debugPassName,"iblShadowDebug",t),this._debugPassPP.autoClear=!1,this._debugPassPP.onApplyObservable.add(e=>{e.setTexture("debugSampler",this._outputTexture),e.setVector4("sizeParams",this._debugSizeParams)})}}constructor(e,t){this._accumulationParams=new r.IU(0,0,0,0),this.debugEnabled=!1,this.enabled=!0,this.onReadyObservable=new _.cP,this._debugPassName="Shadow Accumulation Debug Pass",this._remanence=.9,this._reset=!0,this._isMoving=!1,this._debugSizeParams=new r.IU(0,0,0,0),this._renderWhenGBufferReady=null,this._scene=e,this._engine=e.getEngine(),this._renderPipeline=t,this._createTextures()}_createTextures(){const e=this._engine.isWebGPU,t={type:2,format:5,samplingMode:1,generateDepthBuffer:!1,generateMipMaps:!1,shaderLanguage:e?1:0,extraInitializationsAsync:async()=>{e?await Promise.all([s.e(7122).then(s.bind(s,27122))]):await Promise.all([s.e(3470).then(s.bind(s,61089))])}};this._outputTexture=new f.p("shadowAccumulationPass",{width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight()},"iblShadowAccumulation",this._scene,t),this._outputTexture.refreshRate=1,this._outputTexture.autoClear=!1,this._outputTexture.onGeneratedObservable.addOnce(()=>{this.onReadyObservable.notifyObservers()}),this._setOutputTextureBindings(),this._renderWhenGBufferReady=this._render.bind(this),this._renderPipeline.onVoxelizationCompleteObservable.addOnce(()=>{this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady)});const i={type:2,format:5,samplingMode:1,generateDepthBuffer:!1,generateMipMaps:!1,shaderLanguage:e?1:0,extraInitializationsAsync:async()=>{e?await Promise.all([s.e(9965).then(s.bind(s,99965))]):await Promise.all([s.e(9820).then(s.bind(s,79820))])}};this._oldAccumulationCopy=new f.p("oldAccumulationRT",{width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight()},"pass",this._scene,i,!1),this._oldAccumulationCopy.autoClear=!1,this._oldAccumulationCopy.refreshRate=1,this._oldAccumulationCopy.onBeforeGenerationObservable.add(this._setAccumulationCopyBindings.bind(this)),this._setAccumulationCopyBindings();const r={type:2,format:5,samplingMode:1,generateDepthBuffer:!1,generateMipMaps:!1,shaderLanguage:e?1:0,extraInitializationsAsync:async()=>{e?await Promise.all([s.e(9965).then(s.bind(s,99965))]):await Promise.all([s.e(9820).then(s.bind(s,79820))])}};this._oldPositionCopy=new f.p("oldLocalPositionRT",{width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight()},"pass",this._scene,r,!1),this._updatePositionCopy(),this._oldPositionCopy.autoClear=!1,this._oldPositionCopy.refreshRate=1,this._oldPositionCopy.onBeforeGenerationObservable.add(this._updatePositionCopy.bind(this))}_setOutputTextureBindings(){const e=this._isMoving?this.remanence:.99;this._accumulationParams.set(e,this.reset?1:0,this._renderPipeline.voxelGridSize,0),this._outputTexture.setTexture("spatialBlurSampler",this._renderPipeline._getSpatialBlurTexture()),this._outputTexture.setVector4("accumulationParameters",this._accumulationParams),this._outputTexture.setTexture("oldAccumulationSampler",this._oldAccumulationCopy?this._oldAccumulationCopy:this._renderPipeline._dummyTexture2d),this._outputTexture.setTexture("prevPositionSampler",this._oldPositionCopy?this._oldPositionCopy:this._renderPipeline._dummyTexture2d);const t=this._scene.geometryBufferRenderer;if(!t)return!1;const s=t.getTextureIndex(R.VELOCITY_LINEAR_TEXTURE_TYPE);this._outputTexture.setTexture("motionSampler",t.getGBuffer().textures[s]);const i=t.getTextureIndex(R.POSITION_TEXTURE_TYPE);return this._outputTexture.setTexture("positionSampler",t.getGBuffer().textures[i]),this.reset=!1,this._isMoving=!1,!0}_updatePositionCopy(){const e=this._scene.geometryBufferRenderer,t=e.getTextureIndex(R.POSITION_TEXTURE_TYPE);this._oldPositionCopy.setTexture("textureSampler",e.getGBuffer().textures[t])}_setAccumulationCopyBindings(){this._oldAccumulationCopy.setTexture("textureSampler",this._outputTexture)}_render(){this.enabled&&this._outputTexture.isReady()&&this._outputTexture.getEffect()?.isReady()&&this._setOutputTextureBindings()&&this._outputTexture.render()}resize(e=1){const t={width:Math.max(1,Math.floor(this._engine.getRenderWidth()*e)),height:Math.max(1,Math.floor(this._engine.getRenderHeight()*e))};this._outputTexture.getSize().width===t.width&&this._outputTexture.getSize().height===t.height||(this._outputTexture.resize(t,!1),this._oldAccumulationCopy.resize(t,!1),this._oldPositionCopy.resize({width:this._engine.getRenderWidth(),height:this._engine.getRenderHeight()},!1),this.reset=!0)}_disposeTextures(){this._oldAccumulationCopy.dispose(),this._oldPositionCopy.dispose(),this._outputTexture.dispose()}isReady(){return this._oldAccumulationCopy&&this._oldAccumulationCopy.isReady()&&this._oldPositionCopy&&this._oldPositionCopy.isReady()&&this._outputTexture.isReady()&&!(this._debugPassPP&&!this._debugPassPP.isReady())}dispose(){if(this._scene.geometryBufferRenderer&&this._renderWhenGBufferReady){this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady)}this._disposeTextures(),this._debugPassPP&&this._debugPassPP.dispose(),this.onReadyObservable.clear()}}var D=s(75524),I=s(998),C=s(79259),w=s(82678);class A{get name(){return this._name}get cameras(){return this._cameras}get engine(){return this._engine}constructor(e,t){this._engine=e,this.uniqueId=w.K.UniqueId,this._name=t,this._renderEffects={},this._renderEffectsForIsolatedPass=new Array,this._cameras=[]}getClassName(){return"PostProcessRenderPipeline"}get isSupported(){for(const e in this._renderEffects)if(Object.prototype.hasOwnProperty.call(this._renderEffects,e)&&!this._renderEffects[e].isSupported)return!1;return!0}addEffect(e){this._renderEffects[e._name]=e}_rebuild(){}_enableEffect(e,t){const s=this._renderEffects[e];s&&s._enable(I.S0.MakeArray(t||this._cameras))}_disableEffect(e,t){const s=this._renderEffects[e];s&&s._disable(I.S0.MakeArray(t||this._cameras))}_attachCameras(e,t){const s=I.S0.MakeArray(e||this._cameras);if(!s)return;const i=[];let r;for(r=0;r<s.length;r++){const e=s[r];e&&(-1===this._cameras.indexOf(e)?this._cameras.push(e):t&&i.push(r))}for(r=0;r<i.length;r++)s.splice(i[r],1);for(const e in this._renderEffects)Object.prototype.hasOwnProperty.call(this._renderEffects,e)&&this._renderEffects[e]._attachCameras(s)}_detachCameras(e){const t=I.S0.MakeArray(e||this._cameras);if(t){for(const e in this._renderEffects)Object.prototype.hasOwnProperty.call(this._renderEffects,e)&&this._renderEffects[e]._detachCameras(t);for(let e=0;e<t.length;e++)this._cameras.splice(this._cameras.indexOf(t[e]),1)}}_update(){for(const e in this._renderEffects)Object.prototype.hasOwnProperty.call(this._renderEffects,e)&&this._renderEffects[e]._update();for(let e=0;e<this._cameras.length;e++){if(!this._cameras[e])continue;const t=this._cameras[e].name;this._renderEffectsForIsolatedPass[t]&&this._renderEffectsForIsolatedPass[t]._update()}}_reset(){this._renderEffects={},this._renderEffectsForIsolatedPass=new Array}_enableMSAAOnFirstPostProcess(e){if(!this._engine._features.supportMSAA)return!1;const t=Object.keys(this._renderEffects);if(t.length>0){const s=this._renderEffects[t[0]].getPostProcesses();s&&(s[0].samples=e)}return!0}_adaptPostProcessesToViewPort(){const e=Object.keys(this._renderEffects);for(const t of e){const e=this._renderEffects[t].getPostProcesses();if(e)for(const t of e)t.adaptScaleToCurrentViewport=!0}}setPrePassRenderer(e){return!1}dispose(){}}(0,D.Cg)([(0,C.lK)()],A.prototype,"_name",void 0);class O{constructor(e,t,s,i=!0){this._name=t,this._singleInstance=i,this._getPostProcesses=s,this._cameras={},this._indicesForCamera={},this._postProcesses={}}get isSupported(){for(const e in this._postProcesses)if(Object.prototype.hasOwnProperty.call(this._postProcesses,e)){const t=this._postProcesses[e];for(let e=0;e<t.length;e++)if(!t[e].isSupported)return!1}return!0}_update(){}_attachCameras(e){let t;const s=I.S0.MakeArray(e||this._cameras);if(s)for(let e=0;e<s.length;e++){const i=s[e];if(!i)continue;const r=i.name;if(t=this._singleInstance?0:r,!this._postProcesses[t]){const e=this._getPostProcesses();e&&(this._postProcesses[t]=Array.isArray(e)?e:[e])}this._indicesForCamera[r]||(this._indicesForCamera[r]=[]);const n=this._postProcesses[t];for(const e of n){const t=i.attachPostProcess(e);this._indicesForCamera[r].push(t)}this._cameras[r]||(this._cameras[r]=i)}}_detachCameras(e){const t=I.S0.MakeArray(e||this._cameras);if(t)for(let e=0;e<t.length;e++){const s=t[e],i=s.name,r=this._postProcesses[this._singleInstance?0:i];if(r)for(const e of r)s.detachPostProcess(e);this._cameras[i]&&(this._cameras[i]=null),delete this._indicesForCamera[i]}}_enable(e){const t=I.S0.MakeArray(e||this._cameras);if(t)for(let e=0;e<t.length;e++){const s=t[e],i=s.name,r=this._singleInstance?0:i;for(let n=0;n<this._indicesForCamera[i].length;n++){const a=this._indicesForCamera[i][n],o=s._postProcesses[a];null==o&&t[e].attachPostProcess(this._postProcesses[r][n],a)}}}_disable(e){const t=I.S0.MakeArray(e||this._cameras);if(t)for(let e=0;e<t.length;e++){const s=t[e],i=s.name,r=this._postProcesses[this._singleInstance?0:i];for(const e of r)s.detachPostProcess(e)}}getPostProcesses(e){return this._singleInstance?this._postProcesses[0]:e?this._postProcesses[e.name]:null}}var N=s(96041);class B extends n.g{get width(){return this._texture?this._texture.width:0}get height(){return this._texture?this._texture.height:0}get depth(){return this._texture?this._texture.depth:0}constructor(e,t,s,i,r,a,o=!0,l=!1,d=n.g.TRILINEAR_SAMPLINGMODE,h=0,u){super(null,a,!o,l),this.format=r,this._texture=a.getEngine().createRawTexture3D(e,t,s,i,r,o,l,d,null,h,u),this.is3D=!0}update(e){this._texture&&this._getEngine().updateRawTexture3D(this._texture,e,this._texture.format,this._texture.invertY,null,this._texture.type)}}var L=s(79526),V=s(82277),U=s(17595),F=s(56552);class G extends L.M{constructor(){super(...arguments),this.RENDER_WITH_IBL_SHADOWS=!1,this.COLORED_IBL_SHADOWS=!1}}class W extends V.y{get isColored(){return this._isColored}set isColored(e){this._isColored!==e&&(this._isColored=e,this._markAllSubMeshesAsTexturesDirty())}_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}isCompatible(){return!0}constructor(e){super(e,W.Name,310,new G),this.shadowOpacity=1,this._isEnabled=!1,this._isColored=!1,this.isEnabled=!1,this._internalMarkAllSubMeshesAsTexturesDirty=e._dirtyCallbacks[1]}prepareDefines(e){e.RENDER_WITH_IBL_SHADOWS=this._isEnabled,e.COLORED_IBL_SHADOWS=this.isColored}getClassName(){return"IBLShadowsPluginMaterial"}getUniforms(){return{ubo:[{name:"renderTargetSize",size:2,type:"vec2"},{name:"shadowOpacity",size:1,type:"float"}],fragment:"#ifdef RENDER_WITH_IBL_SHADOWS\n                    uniform vec2 renderTargetSize;\n                    uniform float shadowOpacity;\n                #endif"}}getSamplers(e){e.push("iblShadowsTexture")}bindForSubMesh(e){this._isEnabled&&(e.bindTexture("iblShadowsTexture",this.iblShadowsTexture),e.updateFloat2("renderTargetSize",this._material.getScene().getEngine().getRenderWidth(),this._material.getScene().getEngine().getRenderHeight()),e.updateFloat("shadowOpacity",this.shadowOpacity))}getCustomCode(e,t){let s;return 1===t?(s={CUSTOM_FRAGMENT_DEFINITIONS:"\n                #ifdef RENDER_WITH_IBL_SHADOWS\n                    var iblShadowsTextureSampler: sampler;\n                    var iblShadowsTexture: texture_2d<f32>;\n\n                    #ifdef COLORED_IBL_SHADOWS\n                        fn computeIndirectShadow() -> vec3f {\n                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;\n                            var shadowValue: vec3f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rgb;\n                            return mix(shadowValue, vec3f(1.0), 1.0 - uniforms.shadowOpacity);\n                        }\n                    #else\n                        fn computeIndirectShadow() -> vec2f {\n                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;\n                            var shadowValue: vec2f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rg;\n                            return mix(shadowValue, vec2f(1.0), 1.0 - uniforms.shadowOpacity);\n                        }\n                    #endif\n                #endif\n            "},this._material instanceof U.d?s.CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION="\n                #ifdef RENDER_WITH_IBL_SHADOWS\n                    #ifndef UNLIT\n                        #ifdef REFLECTION\n                            #ifdef COLORED_IBL_SHADOWS\n                                var shadowValue: vec3f = computeIndirectShadow();\n                                finalIrradiance *= shadowValue;\n                                finalRadianceScaled *= mix(vec3f(1.0), shadowValue, roughness);\n                            #else\n                                var shadowValue: vec2f = computeIndirectShadow();\n                                finalIrradiance *= vec3f(shadowValue.x);\n                                finalRadianceScaled *= vec3f(mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness));\n                            #endif\n                        #endif\n                    #else\n                        finalDiffuse *= computeIndirectShadow().x;\n                    #endif\n                #endif\n            ":s.CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR="\n                #ifdef RENDER_WITH_IBL_SHADOWS\n                    #ifdef COLORED_IBL_SHADOWS\n                        var shadowValue: vec3f = computeIndirectShadow();\n                        color *= toGammaSpace(vec4f(shadowValue, 1.0f));\n                    #else\n                        var shadowValue: vec2f = computeIndirectShadow();\n                        color *= toGammaSpace(vec4f(shadowValue.x, shadowValue.x, shadowValue.x, 1.0f));\n                    #endif\n                #endif\n            "):(s={CUSTOM_FRAGMENT_DEFINITIONS:"\n                #ifdef RENDER_WITH_IBL_SHADOWS\n                    uniform sampler2D iblShadowsTexture;\n                #ifdef COLORED_IBL_SHADOWS\n                    vec3 computeIndirectShadow() {\n                        vec2 uv = gl_FragCoord.xy / renderTargetSize;\n                        vec3 shadowValue = texture2D(iblShadowsTexture, uv).rgb;\n                        return mix(shadowValue.rgb, vec3(1.0), 1.0 - shadowOpacity);\n                    }\n                #else\n                    vec2 computeIndirectShadow() {\n                        vec2 uv = gl_FragCoord.xy / renderTargetSize;\n                        vec2 shadowValue = texture2D(iblShadowsTexture, uv).rg;\n                        return mix(shadowValue.rg, vec2(1.0), 1.0 - shadowOpacity);\n                    }\n                #endif\n                #endif\n            "},this._material instanceof U.d?s.CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION="\n                #ifdef RENDER_WITH_IBL_SHADOWS\n                    #ifndef UNLIT\n                        #ifdef REFLECTION\n                            #ifdef COLORED_IBL_SHADOWS\n                                vec3 shadowValue = computeIndirectShadow();\n                                finalIrradiance.rgb *= shadowValue.rgb;\n                                finalRadianceScaled *= mix(vec3(1.0), shadowValue.rgb, roughness);\n                            #else\n                                vec2 shadowValue = computeIndirectShadow();\n                                finalIrradiance *= shadowValue.x;\n                                finalRadianceScaled *= mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness);\n                            #endif\n                        #endif\n                    #else\n                        finalDiffuse *= computeIndirectShadow().x;\n                    #endif\n                #endif\n            ":s.CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR="\n                #ifdef RENDER_WITH_IBL_SHADOWS\n                    #ifdef COLORED_IBL_SHADOWS\n                        vec3 shadowValue = computeIndirectShadow();\n                        color.rgb *= toGammaSpace(shadowValue.rgb);\n                    #else\n                        vec2 shadowValue = computeIndirectShadow();\n                        color.rgb *= toGammaSpace(shadowValue.x);\n                    #endif\n                #endif\n            "),"vertex"===e?null:s}}W.Name="IBLShadowsPluginMaterial",(0,D.Cg)([(0,C.lK)()],W.prototype,"shadowOpacity",void 0),(0,D.Cg)([(0,C.lK)(),(0,C.$z)("_markAllSubMeshesAsTexturesDirty")],W.prototype,"isEnabled",void 0),(0,F.Y5)("BABYLON.IBLShadowsPluginMaterial",W);var z=s(2093),H=s(29794),X=s(16945);Object.defineProperty(H.Z.prototype,"geometryBufferRenderer",{get:function(){return this._geometryBufferRenderer},set:function(e){e&&e.isSupported&&(this._geometryBufferRenderer=e)},enumerable:!0,configurable:!0}),H.Z.prototype.enableGeometryBufferRenderer=function(e=1,t=15,s){return this._geometryBufferRenderer||(this._geometryBufferRenderer=new R(this,e,t,s),this._geometryBufferRenderer.isSupported||(this._geometryBufferRenderer=null)),this._geometryBufferRenderer},H.Z.prototype.disableGeometryBufferRenderer=function(){this._geometryBufferRenderer&&(this._geometryBufferRenderer.dispose(),this._geometryBufferRenderer=null)};class Y{constructor(e){this.name=X.v.NAME_GEOMETRYBUFFERRENDERER,this.scene=e}register(){this.scene._gatherRenderTargetsStage.registerStep(X.v.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER,this,this._gatherRenderTargets)}rebuild(){}dispose(){}_gatherRenderTargets(e){this.scene._geometryBufferRenderer&&e.push(this.scene._geometryBufferRenderer.getGBuffer())}}R._SceneComponentInitialization=e=>{let t=e._getComponent(X.v.NAME_GEOMETRYBUFFERRENDERER);t||(t=new Y(e),e._addComponent(t))};s(5961);class k extends A{resetAccumulation(){this._accumulationPass.reset=!0}get shadowOpacity(){return this._shadowOpacity}set shadowOpacity(e){this._shadowOpacity=e,this._setPluginParameters()}get coloredShadows(){return this._coloredShadows}set coloredShadows(e){this._coloredShadows=e,this._voxelTracingPass.coloredShadows=e,this._setPluginParameters()}get shadowRenderSizeFactor(){return this._renderSizeFactor}set shadowRenderSizeFactor(e){this._renderSizeFactor=Math.max(Math.min(e,1),0),this._voxelTracingPass.resize(e),this._spatialBlurPass.resize(e),this._accumulationPass.resize(e),this._setPluginParameters()}get voxelShadowOpacity(){return this._voxelTracingPass?.voxelShadowOpacity}set voxelShadowOpacity(e){this._voxelTracingPass&&(this._voxelTracingPass.voxelShadowOpacity=e)}get ssShadowOpacity(){return this._voxelTracingPass?.ssShadowOpacity}set ssShadowOpacity(e){this._voxelTracingPass&&(this._voxelTracingPass.ssShadowOpacity=e)}get ssShadowSampleCount(){return this._voxelTracingPass?.sssSamples}set ssShadowSampleCount(e){this._voxelTracingPass&&(this._voxelTracingPass.sssSamples=e)}get ssShadowStride(){return this._voxelTracingPass?.sssStride}set ssShadowStride(e){this._voxelTracingPass&&(this._voxelTracingPass.sssStride=e)}get ssShadowDistanceScale(){return this._sssMaxDistScale}set ssShadowDistanceScale(e){this._sssMaxDistScale=e,this._updateSsShadowParams()}get ssShadowThicknessScale(){return this._sssThicknessScale}set ssShadowThicknessScale(e){this._sssThicknessScale=e,this._updateSsShadowParams()}_getVoxelGridTexture(){const e=this._voxelRenderer?.getVoxelGrid();return e&&e.isReady()?e:this._dummyTexture3d}_getNoiseTexture(){const e=this._noiseTexture;return e&&e.isReady()?e:this._dummyTexture2d}_getVoxelTracingTexture(){const e=this._voxelTracingPass?.getOutputTexture();return e&&e.isReady()?e:this._dummyTexture2d}_getSpatialBlurTexture(){const e=this._spatialBlurPass.getOutputTexture();return e&&e.isReady()?e:this._dummyTexture2d}_getAccumulatedTexture(){const e=this._accumulationPass?.getOutputTexture();return e&&e.isReady()?e:this._dummyTexture2d}get gbufferDebugEnabled(){return this._gbufferDebugEnabled}set gbufferDebugEnabled(e){!e||this.allowDebugPasses?(this._gbufferDebugEnabled=e,e?this._enableEffect(this._getGBufferDebugPass().name,this.cameras):this._disableEffect(this._getGBufferDebugPass().name,this.cameras)):a.V.Warn("Can't enable G-Buffer debug view without setting allowDebugPasses to true.")}get cdfDebugEnabled(){return!!this.scene.iblCdfGenerator&&this.scene.iblCdfGenerator.debugEnabled}set cdfDebugEnabled(e){this.scene.iblCdfGenerator&&(!e||this.allowDebugPasses?e!==this.scene.iblCdfGenerator.debugEnabled&&(this.scene.iblCdfGenerator.debugEnabled=e,e?this._enableEffect(this.scene.iblCdfGenerator.debugPassName,this.cameras):this._disableEffect(this.scene.iblCdfGenerator.debugPassName,this.cameras)):a.V.Warn("Can't enable importance sampling debug view without setting allowDebugPasses to true."))}get voxelDebugEnabled(){return this._voxelRenderer?.voxelDebugEnabled}set voxelDebugEnabled(e){this._voxelRenderer&&(!e||this.allowDebugPasses?(this._voxelRenderer.voxelDebugEnabled=e,e?this._enableEffect(this._voxelRenderer.debugPassName,this.cameras):this._disableEffect(this._voxelRenderer.debugPassName,this.cameras)):a.V.Warn("Can't enable voxel debug view without setting allowDebugPasses to true."))}get voxelDebugAxis(){return this._voxelRenderer?.voxelDebugAxis}set voxelDebugAxis(e){this._voxelRenderer&&(this._voxelRenderer.voxelDebugAxis=e)}set voxelDebugDisplayMip(e){this._voxelRenderer&&this._voxelRenderer.setDebugMipNumber(e)}get voxelTracingDebugEnabled(){return this._voxelTracingPass?.debugEnabled}set voxelTracingDebugEnabled(e){this._voxelTracingPass&&(!e||this.allowDebugPasses?e!==this._voxelTracingPass.debugEnabled&&(this._voxelTracingPass.debugEnabled=e,e?this._enableEffect(this._voxelTracingPass.debugPassName,this.cameras):this._disableEffect(this._voxelTracingPass.debugPassName,this.cameras)):a.V.Warn("Can't enable voxel tracing debug view without setting allowDebugPasses to true."))}get spatialBlurPassDebugEnabled(){return this._spatialBlurPass.debugEnabled}set spatialBlurPassDebugEnabled(e){this._spatialBlurPass&&(!e||this.allowDebugPasses?e!==this._spatialBlurPass.debugEnabled&&(this._spatialBlurPass.debugEnabled=e,e?this._enableEffect(this._spatialBlurPass.debugPassName,this.cameras):this._disableEffect(this._spatialBlurPass.debugPassName,this.cameras)):a.V.Warn("Can't enable spatial blur debug view without setting allowDebugPasses to true."))}get accumulationPassDebugEnabled(){return this._accumulationPass?.debugEnabled}set accumulationPassDebugEnabled(e){this._accumulationPass&&(!e||this.allowDebugPasses?e!==this._accumulationPass.debugEnabled&&(this._accumulationPass.debugEnabled=e,e?this._enableEffect(this._accumulationPass.debugPassName,this.cameras):this._disableEffect(this._accumulationPass.debugPassName,this.cameras)):a.V.Warn("Can't enable accumulation pass debug view without setting allowDebugPasses to true."))}addShadowCastingMesh(e){if(Array.isArray(e))for(const t of e)t&&-1===this._shadowCastingMeshes.indexOf(t)&&this._shadowCastingMeshes.push(t);else e&&-1===this._shadowCastingMeshes.indexOf(e)&&this._shadowCastingMeshes.push(e)}removeShadowCastingMesh(e){if(Array.isArray(e))for(const t of e){const e=this._shadowCastingMeshes.indexOf(t);-1!==e&&this._shadowCastingMeshes.splice(e,1)}else{const t=this._shadowCastingMeshes.indexOf(e);-1!==t&&this._shadowCastingMeshes.splice(t,1)}}clearShadowCastingMeshes(){this._shadowCastingMeshes.length=0}get resolutionExp(){return this._voxelRenderer.voxelResolutionExp}set resolutionExp(e){e!==this._voxelRenderer.voxelResolutionExp&&(this._voxelRenderer.isVoxelizationInProgress()?a.V.Warn("Can't change the resolution of the voxel grid while voxelization is in progress."):(this._voxelRenderer.voxelResolutionExp=Math.max(1,Math.min(e,8)),this._accumulationPass.reset=!0))}get sampleDirections(){return this._voxelTracingPass?.sampleDirections}set sampleDirections(e){this._voxelTracingPass&&(this._voxelTracingPass.sampleDirections=e)}get shadowRemanence(){return this._accumulationPass?.remanence}set shadowRemanence(e){this._accumulationPass&&(this._accumulationPass.remanence=e)}get envRotation(){return this._voxelTracingPass?.envRotation}set envRotation(e){this._voxelTracingPass&&(this._voxelTracingPass.envRotation=e,this._accumulationPass.reset=!0)}get allowDebugPasses(){return this._allowDebugPasses}set allowDebugPasses(e){this._allowDebugPasses!==e&&(this._allowDebugPasses=e,e&&this.scene.iblCdfGenerator?this.scene.iblCdfGenerator.isReady()?this._createDebugPasses():this.scene.iblCdfGenerator.onGeneratedObservable.addOnce(()=>{this._createDebugPasses()}):this._disposeDebugPasses())}static get IsSupported(){const e=i.q.LastCreatedEngine;return!!e&&e._features.supportIBLShadows}toggleShadow(e){this._enabled=e,this._voxelTracingPass.enabled=e,this._spatialBlurPass.enabled=e,this._accumulationPass.enabled=e;for(const t of this._materialsWithRenderPlugin)if(t.pluginManager){t.pluginManager.getPlugin(W.Name).isEnabled=e}this._setPluginParameters()}updateVoxelization(){0!==this._shadowCastingMeshes.length?(this._voxelRenderer.updateVoxelGrid(this._shadowCastingMeshes),this._voxelRenderer.onVoxelizationCompleteObservable.addOnce(()=>{this.onVoxelizationCompleteObservable.notifyObservers()}),this._updateSsShadowParams()):a.V.Warn("IBL Shadows: updateVoxelization called with no shadow-casting meshes to voxelize.")}updateSceneBounds(){const e={min:new r.Pq(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),max:new r.Pq(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)};for(const t of this._shadowCastingMeshes){const s=t.getHierarchyBoundingVectors(!0);e.min=r.Pq.Minimize(e.min,s.min),e.max=r.Pq.Maximize(e.max,s.max)}const t=e.max.subtract(e.min);if(this.voxelGridSize=Math.max(t.x,t.y,t.z),0===this._shadowCastingMeshes.length||!isFinite(this.voxelGridSize)||0===this.voxelGridSize)return a.V.Warn("IBL Shadows: Scene size is invalid. Can't update bounds."),void(this.voxelGridSize=1);const s=this.voxelGridSize/2,i=e.max.add(e.min).multiplyByFloats(-.5,-.5,-.5),n=r.uq.Compose(new r.Pq(1/s,1/s,1/s),new r.PT,new r.Pq(0,0,0));r.uq.Compose(new r.Pq(1,1,1),new r.PT,i).multiplyToRef(n,n),this._voxelTracingPass.setWorldScaleMatrix(n),this._voxelRenderer.setWorldScaleMatrix(n),this._spatialBlurPass.setWorldScale(2*s),this._updateSsShadowParams()}constructor(e,t,s={},i){super(t.getEngine(),e),this._allowDebugPasses=!1,this._debugPasses=[],this._shadowCastingMeshes=[],this._shadowOpacity=.8,this._enabled=!0,this._coloredShadows=!1,this._materialsWithRenderPlugin=[],this.onShadowTextureReadyObservable=new _.cP,this.onNewIblReadyObservable=new _.cP,this.onVoxelizationCompleteObservable=new _.cP,this.voxelGridSize=1,this._renderSizeFactor=1,this._gbufferDebugEnabled=!1,this._gBufferDebugSizeParams=new r.IU(0,0,0,0),this.scene=t,this._cameras=i||[t.activeCamera];const l=new Uint8Array([0,0,0,255]);this._dummyTexture2d=new N.I(l,1,1,o.Engine.TEXTUREFORMAT_RGBA,t,!1),this._dummyTexture3d=new B(l,1,1,1,o.Engine.TEXTUREFORMAT_RGBA,t,!1);const d={};d[R.SCREENSPACE_DEPTH_TEXTURE_TYPE]={textureFormat:6,textureType:1},d[R.VELOCITY_LINEAR_TEXTURE_TYPE]={textureFormat:7,textureType:2},d[R.POSITION_TEXTURE_TYPE]={textureFormat:5,textureType:2},d[R.NORMAL_TEXTURE_TYPE]={textureFormat:5,textureType:2};const h=t.enableGeometryBufferRenderer(void 0,14,d);h?(this._geometryBufferRenderer=h,this._geometryBufferRenderer.enableScreenspaceDepth=!0,this._geometryBufferRenderer.enableVelocityLinear=!0,this._geometryBufferRenderer.enablePosition=!0,this._geometryBufferRenderer.enableNormal=!0,this._geometryBufferRenderer.generateNormalsInWorldSpace=!0,this.scene.enableIblCdfGenerator(),this.shadowOpacity=s.shadowOpacity||.8,this._voxelRenderer=new p(this.scene,this,s?s.resolutionExp:6,void 0===s.triPlanarVoxelization||s.triPlanarVoxelization),this._voxelTracingPass=new S(this.scene,this),this._spatialBlurPass=new M(this.scene,this),this._accumulationPass=new y(this.scene,this),this._accumulationPass.onReadyObservable.addOnce(()=>{this.onShadowTextureReadyObservable.notifyObservers()}),this.sampleDirections=s.sampleDirections||2,this.voxelShadowOpacity=s.voxelShadowOpacity??1,this.envRotation=s.envRotation??0,this.shadowRenderSizeFactor=s.shadowRenderSizeFactor||1,this.ssShadowOpacity=void 0===s.ssShadowsEnabled||s.ssShadowsEnabled?1:0,this.ssShadowDistanceScale=s.ssShadowDistanceScale||1.25,this.ssShadowSampleCount=s.ssShadowSampleCount||16,this.ssShadowStride=s.ssShadowStride||8,this.ssShadowThicknessScale=s.ssShadowThicknessScale||1,this.shadowRemanence=s.shadowRemanence??.75,this._noiseTexture=new n.g("https://assets.babylonjs.com/textures/blue_noise/blue_noise_rgb.png",this.scene,!1,!0,1),t.postProcessRenderPipelineManager.addPipeline(this),this.scene.onActiveCameraChanged.add(this._listenForCameraChanges.bind(this)),this.scene.onBeforeRenderObservable.add(this._updateBeforeRender.bind(this)),this._listenForCameraChanges(),this.scene.getEngine().onResizeObservable.add(this._handleResize.bind(this)),this.scene.iblCdfGenerator&&this.scene.iblCdfGenerator.onGeneratedObservable.add(()=>{this._setPluginParameters(),this.onNewIblReadyObservable.notifyObservers()})):a.V.Error("Geometry buffer renderer is required for IBL shadows to work.")}_handleResize(){this._voxelRenderer.resize(),this._voxelTracingPass.resize(this.shadowRenderSizeFactor),this._spatialBlurPass.resize(this.shadowRenderSizeFactor),this._accumulationPass.resize(this.shadowRenderSizeFactor),this._setPluginParameters()}_getGBufferDebugPass(){if(this._gbufferDebugPass)return this._gbufferDebugPass;const e=this.engine.isWebGPU,t={width:this.scene.getEngine().getRenderWidth(),height:this.scene.getEngine().getRenderHeight(),samplingMode:1,engine:this.scene.getEngine(),textureType:0,textureFormat:5,uniforms:["sizeParams"],samplers:["depthSampler","normalSampler","positionSampler","velocitySampler"],reusable:!1,shaderLanguage:e?1:0,extraInitializations:(e,t)=>{e?t.push(s.e(9533).then(s.bind(s,29533))):t.push(s.e(5634).then(s.bind(s,95634)))}};return this._gbufferDebugPass=new c.w("iblShadowGBufferDebug","iblShadowGBufferDebug",t),this.engine.isWebGPU&&(this._gbufferDebugPass.samples=this.engine.currentSampleCount??1),this._gbufferDebugPass.autoClear=!1,this._gbufferDebugPass.onApplyObservable.add(e=>{const t=this._geometryBufferRenderer.getTextureIndex(R.SCREENSPACE_DEPTH_TEXTURE_TYPE);e.setTexture("depthSampler",this._geometryBufferRenderer.getGBuffer().textures[t]);const s=this._geometryBufferRenderer.getTextureIndex(R.NORMAL_TEXTURE_TYPE);e.setTexture("normalSampler",this._geometryBufferRenderer.getGBuffer().textures[s]);const i=this._geometryBufferRenderer.getTextureIndex(R.POSITION_TEXTURE_TYPE);e.setTexture("positionSampler",this._geometryBufferRenderer.getGBuffer().textures[i]);const r=this._geometryBufferRenderer.getTextureIndex(R.VELOCITY_LINEAR_TEXTURE_TYPE);e.setTexture("velocitySampler",this._geometryBufferRenderer.getGBuffer().textures[r]),e.setVector4("sizeParams",this._gBufferDebugSizeParams),this.scene.activeCamera&&e.setFloat("maxDepth",this.scene.activeCamera.maxZ)}),this._gbufferDebugPass}_createDebugPasses(){this.scene.iblCdfGenerator?this._debugPasses=[{pass:this.scene.iblCdfGenerator.getDebugPassPP(),enabled:this.cdfDebugEnabled}]:this._debugPasses=[],this._debugPasses.push({pass:this._voxelRenderer.getDebugPassPP(),enabled:this.voxelDebugEnabled},{pass:this._voxelTracingPass.getDebugPassPP(),enabled:this.voxelTracingDebugEnabled},{pass:this._spatialBlurPass.getDebugPassPP(),enabled:this.spatialBlurPassDebugEnabled},{pass:this._accumulationPass.getDebugPassPP(),enabled:this.accumulationPassDebugEnabled},{pass:this._getGBufferDebugPass(),enabled:this.gbufferDebugEnabled});for(let e=0;e<this._debugPasses.length;e++)this._debugPasses[e].pass&&this.addEffect(new O(this.scene.getEngine(),this._debugPasses[e].pass.name,()=>this._debugPasses[e].pass,!0));const e=this.cameras.slice();this.scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this.name,this.cameras),this.scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this.name,e);for(let e=0;e<this._debugPasses.length;e++)this._debugPasses[e].pass&&(this._debugPasses[e].enabled?this._enableEffect(this._debugPasses[e].pass.name,this.cameras):this._disableEffect(this._debugPasses[e].pass.name,this.cameras))}_disposeEffectPasses(){this.scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this.name,this.cameras),this._disposeDebugPasses(),this._reset()}_disposeDebugPasses(){for(let e=0;e<this._debugPasses.length;e++)this._disableEffect(this._debugPasses[e].pass.name,this.cameras),this._debugPasses[e].pass.dispose();this._debugPasses=[]}_updateDebugPasses(){let e=0;this._gbufferDebugEnabled&&e++,this.cdfDebugEnabled&&e++,this.voxelDebugEnabled&&e++,this.voxelTracingDebugEnabled&&e++,this.spatialBlurPassDebugEnabled&&e++,this.accumulationPassDebugEnabled&&e++;const t=Math.ceil(Math.sqrt(e)),s=Math.ceil(e/t),i=1/s,r=1/t;let n=0,a=0;this.gbufferDebugEnabled&&(this._gBufferDebugSizeParams.set(n,a,s,t),n-=i,n<=-1&&(n=0,a-=r)),this.cdfDebugEnabled&&this.scene.iblCdfGenerator&&(this.scene.iblCdfGenerator.setDebugDisplayParams(n,a,s,t),n-=i,n<=-1&&(n=0,a-=r)),this.voxelDebugEnabled&&(this._voxelRenderer.setDebugDisplayParams(n,a,s,t),n-=i,n<=-1&&(n=0,a-=r)),this.voxelTracingDebugEnabled&&(this._voxelTracingPass.setDebugDisplayParams(n,a,s,t),n-=i,n<=-1&&(n=0,a-=r)),this.spatialBlurPassDebugEnabled&&(this._spatialBlurPass.setDebugDisplayParams(n,a,s,t),n-=i,n<=-1&&(n=0,a-=r)),this.accumulationPassDebugEnabled&&(this._accumulationPass.setDebugDisplayParams(n,a,s,t),n-=i,n<=-1&&(n=0,a-=r))}_updateSsShadowParams(){this._voxelTracingPass.sssMaxDist=this._sssMaxDistScale*this.voxelGridSize/(1<<this.resolutionExp),this._voxelTracingPass.sssThickness=.005*this._sssThicknessScale*this.voxelGridSize}addShadowReceivingMaterial(e){if(e)if(Array.isArray(e))for(const t of e)this._addShadowSupportToMaterial(t);else this._addShadowSupportToMaterial(e);else for(const e of this.scene.materials)this._addShadowSupportToMaterial(e)}removeShadowReceivingMaterial(e){if(Array.isArray(e))for(const t of e){const e=this._materialsWithRenderPlugin.indexOf(t);if(-1!==e){this._materialsWithRenderPlugin.splice(e,1);const s=t.pluginManager?.getPlugin(W.Name);s.isEnabled=!1}}else{const t=this._materialsWithRenderPlugin.indexOf(e);if(-1!==t){this._materialsWithRenderPlugin.splice(t,1);e.pluginManager.getPlugin(W.Name).isEnabled=!1}}}clearShadowReceivingMaterials(){for(const e of this._materialsWithRenderPlugin){const t=e.pluginManager?.getPlugin(W.Name);t&&(t.isEnabled=!1)}this._materialsWithRenderPlugin.length=0}_addShadowSupportToMaterial(e){if(!(e instanceof U.d||e instanceof z.F))return;let t=e.pluginManager?.getPlugin(W.Name);t||(t=new W(e)),-1===this._materialsWithRenderPlugin.indexOf(e)&&(this._enabled&&(t.iblShadowsTexture=this._getAccumulatedTexture().getInternalTexture(),t.shadowOpacity=this.shadowOpacity),t.isEnabled=this._enabled,t.isColored=this._coloredShadows,this._materialsWithRenderPlugin.push(e))}_setPluginParameters(){if(this._enabled)for(const e of this._materialsWithRenderPlugin)if(e.pluginManager){const t=e.pluginManager.getPlugin(W.Name);t.iblShadowsTexture=this._getAccumulatedTexture().getInternalTexture(),t.shadowOpacity=this.shadowOpacity,t.isColored=this._coloredShadows}}_updateBeforeRender(){this._updateDebugPasses()}_listenForCameraChanges(){this.scene.activeCamera?.onViewMatrixChangedObservable.add(()=>{this._accumulationPass.isMoving=!0})}isReady(){return this._noiseTexture.isReady()&&this._voxelRenderer.isReady()&&this.scene.iblCdfGenerator&&this.scene.iblCdfGenerator.isReady()&&(!this._voxelTracingPass||this._voxelTracingPass.isReady())&&(!this._spatialBlurPass||this._spatialBlurPass.isReady())&&(!this._accumulationPass||this._accumulationPass.isReady())}getClassName(){return"IBLShadowsRenderPipeline"}dispose(){const e=this._materialsWithRenderPlugin.splice(0);for(const t of e)this.removeShadowReceivingMaterial(t);this._disposeEffectPasses(),this._noiseTexture.dispose(),this._voxelRenderer.dispose(),this._voxelTracingPass.dispose(),this._spatialBlurPass.dispose(),this._accumulationPass.dispose(),this._dummyTexture2d.dispose(),this._dummyTexture3d.dispose(),this.onNewIblReadyObservable.clear(),this.onShadowTextureReadyObservable.clear(),this.onVoxelizationCompleteObservable.clear(),super.dispose()}}},27018:(e,t,s)=>{var i=s(69610);const r="bumpFragment",n="vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\n#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\n#else\nfloat normalScale=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#elif defined(BUMP)\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n#else\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#else\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\n#define CUSTOM_FRAGMENT_BUMP_FRAGMENT\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\n#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\n#if DETAIL_NORMALBLENDMETHOD==0 \ndetailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD==1 \ndetailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=n)},63022:(e,t,s)=>{var i=s(69610);const r="samplerFragmentDeclaration",n="#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\nuniform sampler2D _SAMPLERNAME_Sampler;\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=n)},75007:(e,t,s)=>{s.r(t),s.d(t,{geometryPixelShader:()=>l});var i=s(69610);s(6194);const r="mrtFragmentDeclaration",n="#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nlayout(location=0) out vec4 glFragData[{X}];\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=n);s(17494),s(8269),s(73325),s(7412),s(27018);const a="geometryPixelShader",o="#extension GL_EXT_draw_buffers : require\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\n#ifdef BUMP\nvarying mat4 vWorldView;varying vec3 vNormalW;\n#else\nvarying vec3 vNormalV;\n#endif\nvarying vec4 vViewPos;\n#if defined(POSITION) || defined(BUMP)\nvarying vec3 vPositionW;\n#endif\n#if defined(VELOCITY) || defined(VELOCITY_LINEAR)\nvarying vec4 vCurrentPosition;varying vec4 vPreviousPosition;\n#endif\n#ifdef NEED_UV\nvarying vec2 vUV;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;\n#endif\n#if defined(REFLECTIVITY)\n#if defined(ORMTEXTURE) || defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)\nuniform sampler2D reflectivitySampler;varying vec2 vReflectivityUV;\n#endif\n#ifdef ALBEDOTEXTURE\nvarying vec2 vAlbedoUV;uniform sampler2D albedoSampler;\n#endif\n#ifdef REFLECTIVITYCOLOR\nuniform vec3 reflectivityColor;\n#endif\n#ifdef ALBEDOCOLOR\nuniform vec3 albedoColor;\n#endif\n#ifdef METALLIC\nuniform float metallic;\n#endif\n#if defined(ROUGHNESS) || defined(GLOSSINESS)\nuniform float glossiness;\n#endif\n#endif\n#if defined(ALPHATEST) && defined(NEED_UV)\nuniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<mrtFragmentDeclaration>[SCENE_MRT_COUNT]\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<helperFunctions>\nvoid main() {\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\nvec3 normalOutput;\n#ifdef BUMP\nvec3 normalW=normalize(vNormalW);\n#include<bumpFragment>\n#ifdef NORMAL_WORLDSPACE\nnormalOutput=normalW;\n#else\nnormalOutput=normalize(vec3(vWorldView*vec4(normalW,0.0)));\n#endif\n#else\nnormalOutput=normalize(vNormalV);\n#endif\n#ifdef ENCODE_NORMAL\nnormalOutput=normalOutput*0.5+0.5;\n#endif\n#ifdef DEPTH\ngl_FragData[DEPTH_INDEX]=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\n#endif\n#ifdef NORMAL\ngl_FragData[NORMAL_INDEX]=vec4(normalOutput,1.0);\n#endif\n#ifdef SCREENSPACE_DEPTH\ngl_FragData[SCREENSPACE_DEPTH_INDEX]=vec4(gl_FragCoord.z,0.0,0.0,1.0);\n#endif\n#ifdef POSITION\ngl_FragData[POSITION_INDEX]=vec4(vPositionW,1.0);\n#endif\n#ifdef VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[VELOCITY_INDEX]=vec4(velocity,0.0,1.0);\n#endif\n#ifdef VELOCITY_LINEAR\nvec2 velocity=vec2(0.5)*((vPreviousPosition.xy/vPreviousPosition.w) -\n(vCurrentPosition.xy/vCurrentPosition.w));gl_FragData[VELOCITY_LINEAR_INDEX]=vec4(velocity,0.0,1.0);\n#endif\n#ifdef REFLECTIVITY\nvec4 reflectivity=vec4(0.0,0.0,0.0,1.0);\n#ifdef METALLICWORKFLOW\nfloat metal=1.0;float roughness=1.0;\n#ifdef ORMTEXTURE\nmetal*=texture2D(reflectivitySampler,vReflectivityUV).b;roughness*=texture2D(reflectivitySampler,vReflectivityUV).g;\n#endif\n#ifdef METALLIC\nmetal*=metallic;\n#endif\n#ifdef ROUGHNESS\nroughness*=(1.0-glossiness); \n#endif\nreflectivity.a-=roughness;vec3 color=vec3(1.0);\n#ifdef ALBEDOTEXTURE\ncolor=texture2D(albedoSampler,vAlbedoUV).rgb;\n#ifdef GAMMAALBEDO\ncolor=toLinearSpace(color);\n#endif\n#endif\n#ifdef ALBEDOCOLOR\ncolor*=albedoColor.xyz;\n#endif\nreflectivity.rgb=mix(vec3(0.04),color,metal);\n#else\n#if defined(SPECULARGLOSSINESSTEXTURE) || defined(REFLECTIVITYTEXTURE)\nreflectivity=texture2D(reflectivitySampler,vReflectivityUV);\n#ifdef GAMMAREFLECTIVITYTEXTURE\nreflectivity.rgb=toLinearSpace(reflectivity.rgb);\n#endif\n#else \n#ifdef REFLECTIVITYCOLOR\nreflectivity.rgb=toLinearSpace(reflectivityColor.xyz);reflectivity.a=1.0;\n#endif\n#endif\n#ifdef GLOSSINESSS\nreflectivity.a*=glossiness; \n#endif\n#endif\ngl_FragData[REFLECTIVITY_INDEX]=reflectivity;\n#endif\n}\n";i.l.ShadersStore[a]||(i.l.ShadersStore[a]=o);const l={name:a,shader:o}}}]);