"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[8894],{1218:(e,t,n)=>{var i=n(69610);const r="instancesDeclaration",s="#ifdef INSTANCES\nattribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;\n#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\n#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)\nattribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;\n#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)\nuniform mat4 previousWorld;\n#endif\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},3298:(e,t,n)=>{var i=n(69610);const r="instancesVertex",s="#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,\npreviousWorld2,previousWorld3);\n#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\n#endif\n#endif\n#else\nmat4 finalWorld=world;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY) || defined(PREPASS_VELOCITY_LINEAR) || defined(VELOCITY_LINEAR)\nmat4 finalPreviousWorld=previousWorld;\n#endif\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},3361:(e,t,n)=>{var i=n(69610);const r="bonesVertex",s="#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},6194:(e,t,n)=>{var i=n(69610);const r="clipPlaneFragmentDeclaration",s="#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},7412:(e,t,n)=>{var i=n(69610);const r="clipPlaneFragment",s="#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{discard;}\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},8334:(e,t,n)=>{var i=n(69610);const r="packingFunctions",s="vec4 pack(float depth)\n{const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\nfloat unpack(vec4 color)\n{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},9977:(e,t,n)=>{n.r(t),n.d(t,{depthVertexShader:()=>o});var i=n(69610);n(69707),n(18959),n(27999),n(90738),n(71636),n(1218);const r="pointCloudVertexDeclaration",s="#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s);n(48451),n(15060),n(3298),n(3361),n(65523),n(47314),n(91211);const a="depthVertexShader",d="attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;uniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;uniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform mat4 view;varying vec4 vViewPos;\n#endif\n#include<pointCloudVertexDeclaration>\nvarying float vDepthMetric;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef UV2\nvec2 uv2Updated=uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#include<clipPlaneVertex>\ngl_Position=viewProjection*worldPos;\n#ifdef STORE_CAMERASPACE_Z\nvViewPos=view*worldPos;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\n#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#endif\n#include<pointCloudVertex>\n}\n";i.l.ShadersStore[a]||(i.l.ShadersStore[a]=d);const o={name:a,shader:d}},14475:(e,t,n)=>{n.r(t),n.d(t,{minmaxReduxPixelShader:()=>a});var i=n(69610);const r="minmaxReduxPixelShader",s="varying vec2 vUV;uniform sampler2D textureSampler;\n#if defined(INITIAL)\nuniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(textureSampler,coord,0).r;float f2=texelFetch(textureSampler,coord+ivec2(1,0),0).r;float f3=texelFetch(textureSampler,coord+ivec2(1,1),0).r;float f4=texelFetch(textureSampler,coord+ivec2(0,1),0).r;\n#ifdef DEPTH_REDUX\n#ifdef VIEW_DEPTH\nfloat minz=3.4e38;if (f1 != 0.0) { minz=f1; }\nif (f2 != 0.0) { minz=min(minz,f2); }\nif (f3 != 0.0) { minz=min(minz,f3); }\nif (f4 != 0.0) { minz=min(minz,f4); }\nfloat maxz=max(max(max(f1,f2),f3),f4);\n#else\nfloat minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#endif\n#else\nfloat minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(f1,f2),f3),f4);\n#endif\nglFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\nvoid main(void)\n{glFragColor=vec4(0.);if (true) { \ndiscard;}}\n#endif\n";i.l.ShadersStore[r]||(i.l.ShadersStore[r]=s);const a={name:r,shader:s}},15060:(e,t,n)=>{var i=n(69610);const r="morphTargetsVertex",s="#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\n#if {X}==0\nfor (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (float(i)>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;\n#ifdef MORPHTARGETS_POSITION\npositionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];\n#endif\n#ifdef MORPHTARGETTEXTURE_HASPOSITIONS\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];\n#endif\n#ifdef MORPHTARGETTEXTURE_HASNORMALS\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];\n#endif\n#ifdef MORPHTARGETTEXTURE_HASUVS\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];\n#endif\n#ifdef MORPHTARGETTEXTURE_HASTANGENTS\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_UV2\nuv2Updated+=(readVector3FromRawSampler(i,vertexID).xy-uv2)*morphTargetInfluences[i];\n#endif\n#ifdef MORPHTARGETTEXTURE_HASUV2S\nvertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_COLOR\ncolorUpdated+=(readVector4FromRawSampler(i,vertexID)-color)*morphTargetInfluences[i];\n#endif\n}\n#endif\n#else\n#ifdef MORPHTARGETS_POSITION\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV2\nuv2Updated+=(uv2_{X}-uv2)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_COLOR\ncolorUpdated+=(color{X}-color)*morphTargetInfluences[{X}];\n#endif\n#endif\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},18959:(e,t,n)=>{var i=n(69610);const r="bakedVertexAnimationDeclaration",s="#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;\n#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\n#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\n{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},27999:(e,t,n)=>{var i=n(69610);const r="morphTargetsVertexGlobalDeclaration",s="#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#ifdef MORPHTARGETS_TEXTURE \nuniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)\n{ \nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}\nvec4 readVector4FromRawSampler(int targetIndex,float vertexIndex)\n{ \nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV);}\n#endif\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},28894:(e,t,n)=>{n.r(t),n.d(t,{ShadowGeneratorSceneComponent:()=>B});var i=n(79711),r=n(14037),s=n(96882),a=n(45503),d=n(42564),o=n(26041),c=n(95616),h=n(82781),f=n(30388),u=(n(88852),n(9977),n(30492)),l=n(80467),m=n(82565);class _{get shaderLanguage(){return this._shaderLanguage}setMaterialForRendering(e,t){this._depthMap.setMaterialForRendering(e,t)}constructor(e,t=1,n=null,i=!1,r=h.g.TRILINEAR_SAMPLINGMODE,a=!1,d){this._shaderLanguage=0,this.enabled=!0,this.forceDepthWriteTransparentMeshes=!1,this.useOnlyInActiveCamera=!1,this.reverseCulling=!1,this._shadersLoaded=!1,this._scene=e,this._storeNonLinearDepth=i,this._storeCameraSpaceZ=a,this.isPacked=0===t,this.isPacked?this.clearColor=new o.ov(1,1,1,1):this.clearColor=new o.ov(a?0:1,0,0,1),this._initShaderSourceAsync(),_._SceneComponentInitialization(this._scene);const c=e.getEngine();this._camera=n,r!==h.g.NEAREST_SAMPLINGMODE&&(1!==t||c._caps.textureFloatLinearFiltering||(r=h.g.NEAREST_SAMPLINGMODE),2!==t||c._caps.textureHalfFloatLinearFiltering||(r=h.g.NEAREST_SAMPLINGMODE));const m=this.isPacked||!c._features.supportExtendedTextureFormats?5:6;this._depthMap=new s.RenderTargetTexture(d??"DepthRenderer",{width:c.getRenderWidth(),height:c.getRenderHeight()},this._scene,!1,!0,t,!1,r,void 0,void 0,void 0,m),this._depthMap.wrapU=h.g.CLAMP_ADDRESSMODE,this._depthMap.wrapV=h.g.CLAMP_ADDRESSMODE,this._depthMap.refreshRate=1,this._depthMap.renderParticles=!1,this._depthMap.renderList=null,this._depthMap.noPrePassRenderer=!0,this._depthMap.activeCamera=this._camera,this._depthMap.ignoreCameraViewport=!0,this._depthMap.useCameraPostProcesses=!1,this._depthMap.onClearObservable.add(e=>{e.clear(this.clearColor,!0,!0,!0)}),this._depthMap.onBeforeBindObservable.add(()=>{c._debugPushGroup?.("depth renderer",1)}),this._depthMap.onAfterUnbindObservable.add(()=>{c._debugPopGroup?.(1)}),this._depthMap.customIsReadyFunction=(e,t,n)=>{if((n||0===t)&&e.subMeshes)for(let t=0;t<e.subMeshes.length;++t){const n=e.subMeshes[t],i=n.getRenderingMesh(),r=i._getInstancesRenderList(n._id,!!n.getReplacementMesh()),s=c.getCaps().instancedArrays&&(null!==r.visibleInstances[n._id]&&void 0!==r.visibleInstances[n._id]||i.hasThinInstances);if(!this.isReady(n,s))return!1}return!0};const p=e=>{const t=e.getRenderingMesh(),n=e.getEffectiveMesh(),i=this._scene,r=i.getEngine(),s=e.getMaterial();if(n._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!s||n.infiniteDistance||s.disableDepthWrite||0===e.verticesCount||e._renderId===i.getRenderId())return;const a=n._getWorldMatrixDeterminant()<0;let d=s._getEffectiveOrientation(t);a&&(d=0===d?1:0);const o=0===d;r.setState(s.backFaceCulling,0,!1,o,this.reverseCulling?!s.cullBackFaces:s.cullBackFaces);const c=t._getInstancesRenderList(e._id,!!e.getReplacementMesh());if(c.mustReturn)return;const h=r.getCaps().instancedArrays&&(null!==c.visibleInstances[e._id]&&void 0!==c.visibleInstances[e._id]||t.hasThinInstances),m=this._camera||i.activeCamera;if(this.isReady(e,h)&&m){e._renderId=i.getRenderId();const a=n._internalAbstractMeshDataInfo._materialForRenderPass?.[r.currentRenderPassId];let d=e._getDrawWrapper();!d&&a&&(d=a._getDrawWrapper());const o=m.mode===f.i.ORTHOGRAPHIC_CAMERA;if(!d)return;const _=d.effect;let p,x;if(r.enableEffect(d),h||t._bind(e,_,s.fillMode),a?a.bindForSubMesh(n.getWorldMatrix(),n,e):(_.setMatrix("viewProjection",i.getTransformMatrix()),_.setMatrix("world",n.getWorldMatrix()),this._storeCameraSpaceZ&&_.setMatrix("view",i.getViewMatrix())),o?(p=!r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:1,x=r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:1):(p=r.useReverseDepthBuffer&&r.isNDCHalfZRange?m.minZ:r.isNDCHalfZRange?0:m.minZ,x=r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:m.maxZ),_.setFloat2("depthValues",p,p+x),!a){if(s.needAlphaTestingForMesh(n)){const e=s.getAlphaTestTexture();e&&(_.setTexture("diffuseSampler",e),_.setMatrix("diffuseMatrix",e.getTextureMatrix()))}(0,l.f$)(t,_),(0,u.ij)(_,s,i),(0,l.nR)(t,_),t.morphTargetManager&&t.morphTargetManager.isUsingTextureForTargets&&t.morphTargetManager._bind(_);const r=e.getMesh().bakedVertexAnimationManager;r&&r.isEnabled&&r.bind(_,h),s.pointsCloud&&_.setFloat("pointSize",s.pointSize)}t._processRendering(n,e,_,s.fillMode,c,h,(e,t)=>_.setMatrix("world",t))}};this._depthMap.customRenderFunction=(e,t,n,i)=>{let r;if(i.length)for(r=0;r<i.length;r++)p(i.data[r]);for(r=0;r<e.length;r++)p(e.data[r]);for(r=0;r<t.length;r++)p(t.data[r]);if(this.forceDepthWriteTransparentMeshes)for(r=0;r<n.length;r++)p(n.data[r]);else for(r=0;r<n.length;r++)n.data[r].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}}async _initShaderSourceAsync(e=!1){!this._scene.getEngine().isWebGPU||e||_.ForceGLSL?await Promise.all([Promise.resolve().then(n.bind(n,9977)),Promise.resolve().then(n.bind(n,88852))]):(this._shaderLanguage=1,await Promise.all([n.e(8453).then(n.bind(n,48453)),n.e(8939).then(n.bind(n,38939))])),this._shadersLoaded=!0}isReady(e,t){if(!this._shadersLoaded)return!1;const n=this._scene.getEngine(),i=e.getMesh(),r=i.getScene(),s=i._internalAbstractMeshDataInfo._materialForRenderPass?.[n.currentRenderPassId];if(s)return s.isReadyForSubMesh(i,e,t);const a=e.getMaterial();if(!a||a.disableDepthWrite)return!1;const d=[],o=[c.R.PositionKind];let h=!1,f=!1;a.needAlphaTestingForMesh(i)&&a.getAlphaTestTexture()&&(d.push("#define ALPHATEST"),i.isVerticesDataPresent(c.R.UVKind)&&(o.push(c.R.UVKind),d.push("#define UV1"),h=!0),i.isVerticesDataPresent(c.R.UV2Kind)&&(o.push(c.R.UV2Kind),d.push("#define UV2"),f=!0));const _=new m.J;if(i.useBones&&i.computeBonesUsingShaders&&i.skeleton){o.push(c.R.MatricesIndicesKind),o.push(c.R.MatricesWeightsKind),i.numBoneInfluencers>4&&(o.push(c.R.MatricesIndicesExtraKind),o.push(c.R.MatricesWeightsExtraKind)),d.push("#define NUM_BONE_INFLUENCERS "+i.numBoneInfluencers),i.numBoneInfluencers>0&&_.addCPUSkinningFallback(0,i);const e=i.skeleton;e.isUsingTextureForMatrices?d.push("#define BONETEXTURE"):d.push("#define BonesPerMesh "+(e.bones.length+1))}else d.push("#define NUM_BONE_INFLUENCERS 0");const p=i.morphTargetManager?(0,l.Dk)(i.morphTargetManager,d,o,i,!0,!1,!1,h,f,!1):0;a.pointsCloud&&d.push("#define POINTSIZE"),t&&(d.push("#define INSTANCES"),(0,l.te)(o),e.getRenderingMesh().hasThinInstances&&d.push("#define THIN_INSTANCES"));const x=i.bakedVertexAnimationManager;x&&x.isEnabled&&(d.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&o.push("bakedVertexAnimationSettingsInstanced")),this._storeNonLinearDepth&&d.push("#define NONLINEARDEPTH"),this._storeCameraSpaceZ&&d.push("#define STORE_CAMERASPACE_Z"),this.isPacked&&d.push("#define PACKED"),(0,u.r4)(a,r,d);const S=e._getDrawWrapper(void 0,!0),g=S.defines,E=d.join("\n");if(g!==E){const e=["world","mBones","boneTextureWidth","pointSize","viewProjection","view","diffuseMatrix","depthValues","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],t=["diffuseSampler","morphTargets","boneSampler","bakedVertexAnimationTexture"];(0,u.Ll)(e),S.setEffect(n.createEffect("depth",{attributes:o,uniformsNames:e,uniformBuffersNames:[],samplers:t,defines:E,fallbacks:_,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:p},shaderLanguage:this._shaderLanguage},n),E)}return S.effect.isReady()}getDepthMap(){return this._depthMap}dispose(){const e=[];for(const t in this._scene._depthRenderer){this._scene._depthRenderer[t]===this&&e.push(t)}if(e.length>0){this._depthMap.dispose();for(const t of e)delete this._scene._depthRenderer[t]}}}_.ForceGLSL=!1,_._SceneComponentInitialization=e=>{throw(0,a.n)("DepthRendererSceneComponent")};var p,x=n(77891),S=n(36096),g=n(99848),E=n(84255),T=n(18800);!function(e){e[e.NormalizedViewDepth=0]="NormalizedViewDepth",e[e.ViewDepth=1]="ViewDepth",e[e.ScreenDepth=2]="ScreenDepth"}(p||(p={}));class C extends E.${_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.resolve().then(n.bind(n,55300)))):t.push(Promise.resolve().then(n.bind(n,14475)))}constructor(e,t=null,n="",i){super({...i,name:e,engine:t||T.Engine.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:C.FragmentUrl,uniforms:C.Uniforms,defines:n}),this.textureWidth=0,this.textureHeight=0}bind(e=!1){super.bind(e);const t=this.drawWrapper.effect;1===this.textureWidth||1===this.textureHeight?t.setInt2("texSize",this.textureWidth,this.textureHeight):t.setFloat2("texSize",this.textureWidth,this.textureHeight)}}C.FragmentUrl="minmaxRedux",C.Uniforms=["texSize"];const v=new Float32Array(4),M=new Uint8Array(4),R={min:0,max:0};class A{get depthRedux(){return this._depthRedux}set depthRedux(e){this._depthRedux!==e&&(this._depthRedux=e,this._recreatePostProcesses())}get textureWidth(){return this._textureWidth}get textureHeight(){return this._textureHeight}constructor(e,t=!0){this.onAfterReductionPerformed=new g.cP,this._textureWidth=0,this._textureHeight=0,this._scene=e,this._depthRedux=t,this.reductionSteps=[]}setTextureDimensions(e,t,n=0){return(e!==this._textureWidth||t!==this._textureHeight||n!==this._depthTextureType)&&(this._textureWidth=e,this._textureHeight=t,this._depthTextureType=n,this._recreatePostProcesses(),!0)}readMinMax(e){const t=e.type===T.Engine.TEXTURETYPE_FLOAT||e.type===T.Engine.TEXTURETYPE_HALF_FLOAT,n=t?v:M;this._scene.getEngine()._readTexturePixels(e,1,1,-1,0,n,!1),R.min=n[0],R.max=n[1],t||(R.min=R.min/255,R.max=R.max/255),R.min>=R.max&&(R.min=0,R.max=1),this.onAfterReductionPerformed.notifyObservers(R)}dispose(e=!0){e&&(this.onAfterReductionPerformed.clear(),this._textureWidth=0,this._textureHeight=0);for(let e=0;e<this.reductionSteps.length;++e)this.reductionSteps[e].dispose();this.reductionSteps.length=0}_recreatePostProcesses(){this.dispose(!1);const e=this._scene;let t=this.textureWidth,n=this.textureHeight;const i=new C("Initial reduction phase",e.getEngine(),"#define INITIAL"+(this._depthRedux?"\n#define DEPTH_REDUX":"")+(1===this._depthTextureType?"\n#define VIEW_DEPTH":""));i.textureWidth=t,i.textureHeight=n,this.reductionSteps.push(i);let r=1;for(;t>1||n>1;){t=Math.max(Math.round(t/2),1),n=Math.max(Math.round(n/2),1);const i=new C("Reduction phase "+r,e.getEngine(),"#define "+(1==t&&1==n?"LAST":1==t||1==n?"ONEBEFORELAST":"MAIN"));i.textureWidth=t,i.textureHeight=n,this.reductionSteps.push(i),r++}}}n(14475),n(55300);class I{get onAfterReductionPerformed(){return this._thinMinMaxReducer.onAfterReductionPerformed}constructor(e){this._onAfterUnbindObserver=null,this._forceFullscreenViewport=!0,this._activated=!1,this._camera=e,this._postProcessManager=new S.X(e.getScene()),this._thinMinMaxReducer=new A(e.getScene()),this._reductionSteps=[],this._onContextRestoredObserver=e.getEngine().onContextRestoredObservable.add(()=>{this._postProcessManager._rebuild()})}get sourceTexture(){return this._sourceTexture}setSourceTexture(e,t,n=2,i=!0){if(e!==this._sourceTexture&&(this._thinMinMaxReducer.depthRedux=t,this.deactivate(),this._sourceTexture=e,this._forceFullscreenViewport=i,this._thinMinMaxReducer.setTextureDimensions(e.getRenderWidth(),e.getRenderHeight()))){this._disposePostProcesses();const e=this._thinMinMaxReducer.reductionSteps;for(let t=0;t<e.length;++t){const r=e[t],s=new x.w(r.name,C.FragmentUrl,{effectWrapper:r,samplingMode:1,engine:this._camera.getScene().getEngine(),textureType:n,textureFormat:7,size:{width:r.textureWidth,height:r.textureHeight}});this._reductionSteps.push(s),s.autoClear=!1,s.forceFullscreenViewport=i,0===t&&(s.externalTextureSamplerBinding=!0,s.onApplyObservable.add(e=>{e.setTexture("textureSampler",this._sourceTexture)})),t===e.length-1&&this._reductionSteps[t-1].onAfterRenderObservable.add(()=>{this._thinMinMaxReducer.readMinMax(s.inputTexture.texture)})}}}get refreshRate(){return this._sourceTexture?this._sourceTexture.refreshRate:-1}set refreshRate(e){this._sourceTexture&&(this._sourceTexture.refreshRate=e)}get activated(){return this._activated}activate(){!this._onAfterUnbindObserver&&this._sourceTexture&&(this._onAfterUnbindObserver=this._sourceTexture.onAfterUnbindObservable.add(()=>{const e=this._camera.getScene().getEngine();e._debugPushGroup?.("min max reduction",1),this._reductionSteps[0].activate(this._camera),this._postProcessManager.directRender(this._reductionSteps,this._reductionSteps[0].inputTexture,this._forceFullscreenViewport,0,0,!0,this._reductionSteps.length-1),e.unBindFramebuffer(this._reductionSteps[this._reductionSteps.length-1].inputTexture,!1),e._debugPopGroup?.(1)}),this._activated=!0)}deactivate(){this._onAfterUnbindObserver&&this._sourceTexture&&(this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=null,this._activated=!1)}dispose(e=!0){e&&(this.onAfterReductionPerformed.clear(),this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=void 0,this._disposePostProcesses(),this._postProcessManager.dispose(),this._postProcessManager=void 0,this._thinMinMaxReducer.dispose(),this._thinMinMaxReducer=void 0,this._sourceTexture=null)}_disposePostProcesses(){for(let e=0;e<this._reductionSteps.length;++e)this._reductionSteps[e].dispose();this._reductionSteps.length=0}}class P extends I{get depthRenderer(){return this._depthRenderer}constructor(e){super(e)}setDepthRenderer(e=null,t=2,n=!0){const i=this._camera.getScene();this._depthRenderer&&(delete i._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null),null===e&&(i._depthRenderer||(i._depthRenderer={}),this._depthRendererId="minmax_"+this._camera.id,(e=this._depthRenderer=new _(i,t,this._camera,!1,1,!1,`DepthRenderer ${this._depthRendererId}`)).enabled=!1,i._depthRenderer[this._depthRendererId]=e),super.setSourceTexture(e.getDepthMap(),!0,t,n)}setSourceTexture(e,t,n=2,i=!0){super.setSourceTexture(e,t,n,i)}activate(){this._depthRenderer&&(this._depthRenderer.enabled=!0),super.activate()}deactivate(){super.deactivate(),this._depthRenderer&&(this._depthRenderer.enabled=!1)}dispose(e=!0){super.dispose(e),this._depthRenderer&&e&&(this._depthRenderer.dispose(),this._depthRenderer=null)}}var N=n(51137),b=n(6315);const D=r.Pq.Up(),w=r.Pq.Zero(),L=new r.Pq,F=new r.Pq,O=new r.uq;class V extends i.ShadowGenerator{_validateFilter(e){return e===i.ShadowGenerator.FILTER_NONE||e===i.ShadowGenerator.FILTER_PCF||e===i.ShadowGenerator.FILTER_PCSS?e:(N.V.Error('Unsupported filter "'+e+'"!'),i.ShadowGenerator.FILTER_NONE)}get numCascades(){return this._numCascades}set numCascades(e){(e=Math.min(Math.max(e,V.MIN_CASCADES_COUNT),V.MAX_CASCADES_COUNT))!==this._numCascades&&(this._numCascades=e,this.recreateShadowMap(),this._recreateSceneUBOs())}get freezeShadowCastersBoundingInfo(){return this._freezeShadowCastersBoundingInfo}set freezeShadowCastersBoundingInfo(e){this._freezeShadowCastersBoundingInfoObservable&&e&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._freezeShadowCastersBoundingInfoObservable||e||(this._freezeShadowCastersBoundingInfoObservable=this._scene.onBeforeRenderObservable.add(()=>this._computeShadowCastersBoundingInfo())),this._freezeShadowCastersBoundingInfo=e,e&&this._computeShadowCastersBoundingInfo()}_computeShadowCastersBoundingInfo(){if(this._scbiMin.copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._scbiMax.copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._shadowMap&&this._shadowMap.renderList){const e=this._shadowMap.renderList;for(let t=0;t<e.length;t++){const n=e[t];if(!n)continue;const i=n.getBoundingInfo().boundingBox;this._scbiMin.minimizeInPlace(i.minimumWorld),this._scbiMax.maximizeInPlace(i.maximumWorld)}}this._shadowCastersBoundingInfo.reConstruct(this._scbiMin,this._scbiMax)}get shadowCastersBoundingInfo(){return this._shadowCastersBoundingInfo}set shadowCastersBoundingInfo(e){this._shadowCastersBoundingInfo=e}setMinMaxDistance(e,t){this._minDistance===e&&this._maxDistance===t||(e>t&&(e=0,t=1),e<0&&(e=0),t>1&&(t=1),this._minDistance=e,this._maxDistance=t,this._breaksAreDirty=!0)}get minDistance(){return this._minDistance}get maxDistance(){return this._maxDistance}getClassName(){return V.CLASSNAME}getCascadeMinExtents(e){return e>=0&&e<this._numCascades?this._cascadeMinExtents[e]:null}getCascadeMaxExtents(e){return e>=0&&e<this._numCascades?this._cascadeMaxExtents[e]:null}get shadowMaxZ(){return this._getCamera()?this._shadowMaxZ:0}set shadowMaxZ(e){const t=this._getCamera();t?this._shadowMaxZ===e||e<t.minZ||e>t.maxZ&&0!==t.maxZ||(this._shadowMaxZ=e,this._light._markMeshesAsLightDirty(),this._breaksAreDirty=!0):this._shadowMaxZ=e}get debug(){return this._debug}set debug(e){this._debug=e,this._light._markMeshesAsLightDirty()}get depthClamp(){return this._depthClamp}set depthClamp(e){this._depthClamp=e}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(e){this._cascadeBlendPercentage=e,this._light._markMeshesAsLightDirty()}get lambda(){return this._lambda}set lambda(e){const t=Math.min(Math.max(e,0),1);this._lambda!=t&&(this._lambda=t,this._breaksAreDirty=!0)}getCascadeViewMatrix(e){return e>=0&&e<this._numCascades?this._viewMatrices[e]:null}getCascadeProjectionMatrix(e){return e>=0&&e<this._numCascades?this._projectionMatrices[e]:null}getCascadeTransformMatrix(e){return e>=0&&e<this._numCascades?this._transformMatrices[e]:null}setDepthRenderer(e){this._depthRenderer=e,this._depthReducer&&this._depthReducer.setDepthRenderer(this._depthRenderer)}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(e){const t=this._getCamera();if(t){if(this._autoCalcDepthBounds=e,!e)return this._depthReducer&&this._depthReducer.deactivate(),void this.setMinMaxDistance(0,1);this._depthReducer||(this._depthReducer=new P(t),this._depthReducer.onAfterReductionPerformed.add(e=>{let t=e.min,n=e.max;t>=n&&(t=0,n=1),t==this._minDistance&&n==this._maxDistance||this.setMinMaxDistance(t,n)}),this._depthReducer.setDepthRenderer(this._depthRenderer)),this._depthReducer.activate()}}get autoCalcDepthBoundsRefreshRate(){return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate??-1}set autoCalcDepthBoundsRefreshRate(e){this._depthReducer?.depthRenderer&&(this._depthReducer.depthRenderer.getDepthMap().refreshRate=e)}splitFrustum(){this._breaksAreDirty=!0}_splitFrustum(){const e=this._getCamera();if(!e)return;const t=e.minZ,n=e.maxZ||this._shadowMaxZ,i=n-t,r=this._minDistance,s=t+r*i,a=t+(this._shadowMaxZ<n&&this._shadowMaxZ>=t?Math.min((this._shadowMaxZ-t)/(n-t),this._maxDistance):this._maxDistance)*i,d=a-s,o=a/s;for(let e=0;e<this._cascades.length;++e){const n=(e+1)/this._numCascades,a=s*o**n,c=s+d*n,h=this._lambda*(a-c)+c;this._cascades[e].prevBreakDistance=0===e?r:this._cascades[e-1].breakDistance,this._cascades[e].breakDistance=(h-t)/i,this._viewSpaceFrustumsZ[e]=h,this._frustumLengths[e]=(this._cascades[e].breakDistance-this._cascades[e].prevBreakDistance)*i}this._breaksAreDirty=!1}_computeMatrices(){const e=this._scene;if(!this._getCamera())return;r.Pq.NormalizeToRef(this._light.getShadowDirection(0),this._lightDirection),1===Math.abs(r.Pq.Dot(this._lightDirection,r.Pq.Up()))&&(this._lightDirection.z=1e-13),this._cachedDirection.copyFrom(this._lightDirection);const t=e.getEngine().useReverseDepthBuffer;for(let n=0;n<this._numCascades;++n){this._computeFrustumInWorldSpace(n),this._computeCascadeFrustum(n),this._cascadeMaxExtents[n].subtractToRef(this._cascadeMinExtents[n],L),this._frustumCenter[n].addToRef(this._lightDirection.scale(this._cascadeMinExtents[n].z),this._shadowCameraPos[n]),r.uq.LookAtLHToRef(this._shadowCameraPos[n],this._frustumCenter[n],D,this._viewMatrices[n]);let s=0,a=L.z;const d=this._shadowCastersBoundingInfo;d.update(this._viewMatrices[n]);const o=d.boundingBox.minimumWorld.z,c=d.boundingBox.maximumWorld.z;o>a||(this._depthClamp&&this.filter!==i.ShadowGenerator.FILTER_PCSS?(a=Math.min(a,c),s=Math.max(s,o),a=Math.max(s+1,a)):(s=Math.min(s,o),this.filter!==i.ShadowGenerator.FILTER_PCSS&&(a=Math.min(a,c)))),r.uq.OrthoOffCenterLHToRef(this._cascadeMinExtents[n].x,this._cascadeMaxExtents[n].x,this._cascadeMinExtents[n].y,this._cascadeMaxExtents[n].y,t?a:s,t?s:a,this._projectionMatrices[n],e.getEngine().isNDCHalfZRange),this._cascadeMinExtents[n].z=s,this._cascadeMaxExtents[n].z=a,this._viewMatrices[n].multiplyToRef(this._projectionMatrices[n],this._transformMatrices[n]),r.Pq.TransformCoordinatesToRef(w,this._transformMatrices[n],L),L.scaleInPlace(this._mapSize/2),F.copyFromFloats(Math.round(L.x),Math.round(L.y),Math.round(L.z)),F.subtractInPlace(L).scaleInPlace(2/this._mapSize),r.uq.TranslationToRef(F.x,F.y,0,O),this._projectionMatrices[n].multiplyToRef(O,this._projectionMatrices[n]),this._viewMatrices[n].multiplyToRef(this._projectionMatrices[n],this._transformMatrices[n]),this._transformMatrices[n].copyToArray(this._transformMatricesAsArray,16*n)}}_computeFrustumInWorldSpace(e){const t=this._getCamera();if(!t)return;const n=this._cascades[e].prevBreakDistance,i=this._cascades[e].breakDistance,s=this._scene.getEngine().isNDCHalfZRange;t.getViewMatrix();const a=0===t.maxZ,d=t.maxZ;a&&(t.maxZ=this._shadowMaxZ,t.getProjectionMatrix(!0));const o=r.uq.Invert(t.getTransformationMatrix());a&&(t.maxZ=d,t.getProjectionMatrix(!0));const c=this._scene.getEngine().useReverseDepthBuffer?4:0;for(let t=0;t<V._FrustumCornersNdcSpace.length;++t)L.copyFrom(V._FrustumCornersNdcSpace[(t+c)%V._FrustumCornersNdcSpace.length]),s&&-1===L.z&&(L.z=0),r.Pq.TransformCoordinatesToRef(L,o,this._frustumCornersWorldSpace[e][t]);for(let t=0;t<V._FrustumCornersNdcSpace.length/2;++t)L.copyFrom(this._frustumCornersWorldSpace[e][t+4]).subtractInPlace(this._frustumCornersWorldSpace[e][t]),F.copyFrom(L).scaleInPlace(n),L.scaleInPlace(i),L.addInPlace(this._frustumCornersWorldSpace[e][t]),this._frustumCornersWorldSpace[e][t+4].copyFrom(L),this._frustumCornersWorldSpace[e][t].addInPlace(F)}_computeCascadeFrustum(e){this._cascadeMinExtents[e].copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cascadeMaxExtents[e].copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._frustumCenter[e].copyFromFloats(0,0,0);if(this._getCamera()){for(let t=0;t<this._frustumCornersWorldSpace[e].length;++t)this._frustumCenter[e].addInPlace(this._frustumCornersWorldSpace[e][t]);if(this._frustumCenter[e].scaleInPlace(1/this._frustumCornersWorldSpace[e].length),this.stabilizeCascades){let t=0;for(let n=0;n<this._frustumCornersWorldSpace[e].length;++n){const i=this._frustumCornersWorldSpace[e][n].subtractToRef(this._frustumCenter[e],L).length();t=Math.max(t,i)}t=Math.ceil(16*t)/16,this._cascadeMaxExtents[e].copyFromFloats(t,t,t),this._cascadeMinExtents[e].copyFromFloats(-t,-t,-t)}else{const t=this._frustumCenter[e];this._frustumCenter[e].addToRef(this._lightDirection,L),r.uq.LookAtLHToRef(t,L,D,O);for(let t=0;t<this._frustumCornersWorldSpace[e].length;++t)r.Pq.TransformCoordinatesToRef(this._frustumCornersWorldSpace[e][t],O,L),this._cascadeMinExtents[e].minimizeInPlace(L),this._cascadeMaxExtents[e].maximizeInPlace(L)}}}_recreateSceneUBOs(){if(this._disposeSceneUBOs(),this._sceneUBOs)for(let e=0;e<this._numCascades;++e)this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${e})`))}static get IsSupported(){const e=b.q.LastCreatedEngine;return!!e&&e._features.supportCSM}constructor(e,t,n,i,r=!0){V.IsSupported?(super(e,t,n,i,r),this.usePercentageCloserFiltering=!0):N.V.Error("CascadedShadowMap is not supported by the current engine.")}_initializeGenerator(){this.penumbraDarkness=this.penumbraDarkness??1,this._numCascades=this._numCascades??V.DEFAULT_CASCADES_COUNT,this.stabilizeCascades=this.stabilizeCascades??!1,this._freezeShadowCastersBoundingInfoObservable=this._freezeShadowCastersBoundingInfoObservable??null,this.freezeShadowCastersBoundingInfo=this.freezeShadowCastersBoundingInfo??!1,this._scbiMin=this._scbiMin??new r.Pq(0,0,0),this._scbiMax=this._scbiMax??new r.Pq(0,0,0),this._shadowCastersBoundingInfo=this._shadowCastersBoundingInfo??new d.j(new r.Pq(0,0,0),new r.Pq(0,0,0)),this._breaksAreDirty=this._breaksAreDirty??!0,this._minDistance=this._minDistance??0,this._maxDistance=this._maxDistance??1,this._currentLayer=this._currentLayer??0,this._shadowMaxZ=this._shadowMaxZ??this._getCamera()?.maxZ??1e4,this._debug=this._debug??!1,this._depthClamp=this._depthClamp??!0,this._cascadeBlendPercentage=this._cascadeBlendPercentage??.1,this._lambda=this._lambda??.5,this._autoCalcDepthBounds=this._autoCalcDepthBounds??!1,this._recreateSceneUBOs(),super._initializeGenerator()}_createTargetRenderTexture(){const e=this._scene.getEngine(),t={width:this._mapSize,height:this._mapSize,layers:this.numCascades};this._shadowMap=new s.RenderTargetTexture(this._light.name+"_CSMShadowMap",t,this._scene,!1,!0,this._textureType,!1,void 0,!1,!1,void 0,this._useRedTextureType?6:5),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?516:513,!0,void 0,void 0,void 0,`DepthStencilForCSMShadowGenerator-${this._light.name}`),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(super._initializeShadowMap(),null===this._shadowMap)return;this._transformMatricesAsArray=new Float32Array(16*this._numCascades),this._viewSpaceFrustumsZ=new Array(this._numCascades),this._frustumLengths=new Array(this._numCascades),this._lightSizeUVCorrection=new Array(2*this._numCascades),this._depthCorrection=new Array(this._numCascades),this._cascades=[],this._viewMatrices=[],this._projectionMatrices=[],this._transformMatrices=[],this._cascadeMinExtents=[],this._cascadeMaxExtents=[],this._frustumCenter=[],this._shadowCameraPos=[],this._frustumCornersWorldSpace=[];for(let e=0;e<this._numCascades;++e){this._cascades[e]={prevBreakDistance:0,breakDistance:0},this._viewMatrices[e]=r.uq.Zero(),this._projectionMatrices[e]=r.uq.Zero(),this._transformMatrices[e]=r.uq.Zero(),this._cascadeMinExtents[e]=new r.Pq,this._cascadeMaxExtents[e]=new r.Pq,this._frustumCenter[e]=new r.Pq,this._shadowCameraPos[e]=new r.Pq,this._frustumCornersWorldSpace[e]=new Array(V._FrustumCornersNdcSpace.length);for(let t=0;t<V._FrustumCornersNdcSpace.length;++t)this._frustumCornersWorldSpace[e][t]=new r.Pq}const e=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.clear(),this._shadowMap.onBeforeRenderObservable.clear(),this._shadowMap.onBeforeRenderObservable.add(t=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[t]),this._currentLayer=t,this._filter===i.ShadowGenerator.FILTER_PCF&&e.setColorWrite(!1),this._scene.setTransformMatrix(this.getCascadeViewMatrix(t),this.getCascadeProjectionMatrix(t)),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onBeforeBindObservable.add(()=>{this._currentSceneUBO=this._scene.getSceneUniformBuffer(),e._debugPushGroup?.(`cascaded shadow map generation for pass id ${e.currentRenderPassId}`,1),this._breaksAreDirty&&this._splitFrustum(),this._computeMatrices()}),this._splitFrustum()}_bindCustomEffectForRenderSubMeshForShadowMap(e,t){t.setMatrix("viewProjection",this.getCascadeTransformMatrix(this._currentLayer))}_isReadyCustomDefines(e){e.push("#define SM_DEPTHCLAMP "+(this._depthClamp&&this._filter!==i.ShadowGenerator.FILTER_PCSS?"1":"0"))}prepareDefines(e,t){super.prepareDefines(e,t);const n=this._scene,i=this._light;if(!n.shadowsEnabled||!i.shadowEnabled)return;e["SHADOWCSM"+t]=!0,e["SHADOWCSMDEBUG"+t]=this.debug,e["SHADOWCSMNUM_CASCADES"+t]=this.numCascades,e["SHADOWCSM_RIGHTHANDED"+t]=n.useRightHandedSystem;const r=this._getCamera();r&&this._shadowMaxZ<=(r.maxZ||this._shadowMaxZ)&&(e["SHADOWCSMUSESHADOWMAXZ"+t]=!0),0===this.cascadeBlendPercentage&&(e["SHADOWCSMNOBLEND"+t]=!0)}bindShadowLight(e,t){const n=this._light;if(!this._scene.shadowsEnabled||!n.shadowEnabled)return;const r=this._getCamera();if(!r)return;const s=this.getShadowMap();if(!s)return;const a=s.getSize().width;if(t.setMatrices("lightMatrix"+e,this._transformMatricesAsArray),t.setArray("viewFrustumZ"+e,this._viewSpaceFrustumsZ),t.setFloat("cascadeBlendFactor"+e,0===this.cascadeBlendPercentage?1e4:1/this.cascadeBlendPercentage),t.setArray("frustumLengths"+e,this._frustumLengths),this._filter===i.ShadowGenerator.FILTER_PCF)t.setDepthStencilTexture("shadowTexture"+e,s),n._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),a,1/a,this.frustumEdgeFalloff,e);else if(this._filter===i.ShadowGenerator.FILTER_PCSS){for(let e=0;e<this._numCascades;++e)this._lightSizeUVCorrection[2*e+0]=0===e?1:(this._cascadeMaxExtents[0].x-this._cascadeMinExtents[0].x)/(this._cascadeMaxExtents[e].x-this._cascadeMinExtents[e].x),this._lightSizeUVCorrection[2*e+1]=0===e?1:(this._cascadeMaxExtents[0].y-this._cascadeMinExtents[0].y)/(this._cascadeMaxExtents[e].y-this._cascadeMinExtents[e].y),this._depthCorrection[e]=0===e?1:(this._cascadeMaxExtents[e].z-this._cascadeMinExtents[e].z)/(this._cascadeMaxExtents[0].z-this._cascadeMinExtents[0].z);t.setDepthStencilTexture("shadowTexture"+e,s),t.setTexture("depthTexture"+e,s),t.setArray2("lightSizeUVCorrection"+e,this._lightSizeUVCorrection),t.setArray("depthCorrection"+e,this._depthCorrection),t.setFloat("penumbraDarkness"+e,this.penumbraDarkness),n._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/a,this._contactHardeningLightSizeUVRatio*a,this.frustumEdgeFalloff,e)}else t.setTexture("shadowTexture"+e,s),n._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),a,1/a,this.frustumEdgeFalloff,e);n._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(r),this.getLight().getDepthMinZ(r)+this.getLight().getDepthMaxZ(r),e)}getTransformMatrix(){return this.getCascadeTransformMatrix(0)}dispose(){super.dispose(),this._freezeShadowCastersBoundingInfoObservable&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._depthReducer&&(this._depthReducer.dispose(),this._depthReducer=null)}serialize(){const e=super.serialize(),t=this.getShadowMap();if(!t)return e;if(e.numCascades=this._numCascades,e.debug=this._debug,e.stabilizeCascades=this.stabilizeCascades,e.lambda=this._lambda,e.cascadeBlendPercentage=this.cascadeBlendPercentage,e.depthClamp=this._depthClamp,e.autoCalcDepthBounds=this.autoCalcDepthBounds,e.shadowMaxZ=this._shadowMaxZ,e.penumbraDarkness=this.penumbraDarkness,e.freezeShadowCastersBoundingInfo=this._freezeShadowCastersBoundingInfo,e.minDistance=this.minDistance,e.maxDistance=this.maxDistance,e.renderList=[],t.renderList)for(let n=0;n<t.renderList.length;n++){const i=t.renderList[n];e.renderList.push(i.id)}return e}static Parse(e,t){const n=i.ShadowGenerator.Parse(e,t,(e,t,n)=>new V(e,t,void 0,n));return void 0!==e.numCascades&&(n.numCascades=e.numCascades),void 0!==e.debug&&(n.debug=e.debug),void 0!==e.stabilizeCascades&&(n.stabilizeCascades=e.stabilizeCascades),void 0!==e.lambda&&(n.lambda=e.lambda),void 0!==e.cascadeBlendPercentage&&(n.cascadeBlendPercentage=e.cascadeBlendPercentage),void 0!==e.depthClamp&&(n.depthClamp=e.depthClamp),void 0!==e.autoCalcDepthBounds&&(n.autoCalcDepthBounds=e.autoCalcDepthBounds),void 0!==e.shadowMaxZ&&(n.shadowMaxZ=e.shadowMaxZ),void 0!==e.penumbraDarkness&&(n.penumbraDarkness=e.penumbraDarkness),void 0!==e.freezeShadowCastersBoundingInfo&&(n.freezeShadowCastersBoundingInfo=e.freezeShadowCastersBoundingInfo),void 0!==e.minDistance&&void 0!==e.maxDistance&&n.setMinMaxDistance(e.minDistance,e.maxDistance),n}}V._FrustumCornersNdcSpace=[new r.Pq(-1,1,-1),new r.Pq(1,1,-1),new r.Pq(1,-1,-1),new r.Pq(-1,-1,-1),new r.Pq(-1,1,1),new r.Pq(1,1,1),new r.Pq(1,-1,1),new r.Pq(-1,-1,1)],V.CLASSNAME="CascadedShadowGenerator",V.DEFAULT_CASCADES_COUNT=4,V.MIN_CASCADES_COUNT=2,V.MAX_CASCADES_COUNT=4,V._SceneComponentInitialization=e=>{throw(0,a.n)("ShadowGeneratorSceneComponent")};var U=n(16945);(0,n(93084).ji)(U.v.NAME_SHADOWGENERATOR,(e,t)=>{if(void 0!==e.shadowGenerators&&null!==e.shadowGenerators)for(let n=0,r=e.shadowGenerators.length;n<r;n++){const r=e.shadowGenerators[n];r.className===V.CLASSNAME?V.Parse(r,t):i.ShadowGenerator.Parse(r,t)}});class B{constructor(e){this.name=U.v.NAME_SHADOWGENERATOR,this.scene=e}register(){this.scene._gatherRenderTargetsStage.registerStep(U.v.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR,this,this._gatherRenderTargets)}rebuild(){}serialize(e){e.shadowGenerators=[];const t=this.scene.lights;for(const n of t){if(n.doNotSerialize)continue;const t=n.getShadowGenerators();if(t){const n=t.values();for(let t=n.next();!0!==t.done;t=n.next()){const n=t.value;n.doNotSerialize||e.shadowGenerators.push(n.serialize())}}}}addFromContainer(e){}removeFromContainer(e,t){}dispose(){}_gatherRenderTargets(e){const t=this.scene;if(this.scene.shadowsEnabled)for(let n=0;n<t.lights.length;n++){const i=t.lights[n],r=i.getShadowGenerators();if(i.isEnabled()&&i.shadowEnabled&&r){const n=r.values();for(let i=n.next();!0!==i.done;i=n.next()){const n=i.value.getShadowMap();-1!==t.textures.indexOf(n)&&e.push(n)}}}}}i.ShadowGenerator._SceneComponentInitialization=e=>{let t=e._getComponent(U.v.NAME_SHADOWGENERATOR);t||(t=new B(e),e._addComponent(t))}},47314:(e,t,n)=>{var i=n(69610);const r="clipPlaneVertex",s="#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},48451:(e,t,n)=>{var i=n(69610);const r="morphTargetsVertexGlobal",s="#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nfloat vertexID;\n#endif\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},55300:(e,t,n)=>{n.r(t),n.d(t,{minmaxReduxPixelShaderWGSL:()=>a});var i=n(69610);const r="minmaxReduxPixelShader",s="varying vUV: vec2f;var textureSampler: texture_2d<f32>;\n#if defined(INITIAL)\nuniform texSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).r;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).r;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).r;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).r;\n#ifdef DEPTH_REDUX\n#ifdef VIEW_DEPTH\nvar minz=3.4e38;if (f1 != 0.0) { minz=f1; }\nif (f2 != 0.0) { minz=min(minz,f2); }\nif (f3 != 0.0) { minz=min(minz,f3); }\nif (f4 != 0.0) { minz=min(minz,f4); }\nlet maxz=max(max(max(f1,f2),f3),f4);\n#else\nlet minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#endif\n#else\nlet minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(f1,f2),f3),f4);\n#endif\nfragmentOutputs.color=vec4f(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform texSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).rg;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).rg;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).rg;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform texSize: vec2i;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*vec2f(uniforms.texSize-1));let f1=textureLoad(textureSampler,coord % uniforms.texSize,0).rg;let f2=textureLoad(textureSampler,(coord+vec2i(1,0)) % uniforms.texSize,0).rg;let f3=textureLoad(textureSampler,(coord+vec2i(1,1)) % uniforms.texSize,0).rg;let f4=textureLoad(textureSampler,(coord+vec2i(0,1)) % uniforms.texSize,0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(0.);if (true) { \ndiscard;}}\n#endif\n";i.l.ShadersStoreWGSL[r]||(i.l.ShadersStoreWGSL[r]=s);const a={name:r,shader:s}},65523:(e,t,n)=>{var i=n(69610);const r="bakedVertexAnimation",s="#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\nfloat VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;}\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},69707:(e,t,n)=>{var i=n(69610);const r="bonesDeclaration",s="#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;attribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform highp sampler2D boneSampler;uniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#endif\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}\n#endif\n#endif\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},71636:(e,t,n)=>{var i=n(69610);const r="clipPlaneVertexDeclaration",s="#ifdef CLIPPLANE\nuniform vec4 vClipPlane;varying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;varying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;varying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;varying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;varying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;varying float fClipDistance6;\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},88852:(e,t,n)=>{n.r(t),n.d(t,{depthPixelShader:()=>a});var i=n(69610);n(6194),n(8334),n(7412);const r="depthPixelShader",s="#ifdef ALPHATEST\nvarying vec2 vUV;uniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvarying float vDepthMetric;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\n#ifdef STORE_CAMERASPACE_Z\nvarying vec4 vViewPos;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#ifdef STORE_CAMERASPACE_Z\n#ifdef PACKED\ngl_FragColor=pack(vViewPos.z);\n#else\ngl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);\n#endif\n#else\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\n#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n#endif\n}";i.l.ShadersStore[r]||(i.l.ShadersStore[r]=s);const a={name:r,shader:s}},90738:(e,t,n)=>{var i=n(69610);const r="morphTargetsVertexDeclaration",s="#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\n#ifdef MORPHTARGETS_POSITION\nattribute vec3 position{X};\n#endif\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#ifdef MORPHTARGETS_UV2\nattribute vec2 uv2_{X};\n#endif\n#ifdef MORPHTARGETS_COLOR\nattribute vec4 color{X};\n#endif\n#elif {X}==0\nuniform float morphTargetCount;\n#endif\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},91211:(e,t,n)=>{var i=n(69610);const r="pointCloudVertex",s="#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n";i.l.IncludesShadersStore[r]||(i.l.IncludesShadersStore[r]=s)},93084:(e,t,n)=>{n.d(t,{ji:()=>r});const i={};function r(e,t){i[e]=t}}}]);