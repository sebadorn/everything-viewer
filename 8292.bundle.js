"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[6041,8292],{2215:(e,n,t)=>{const i="logDepthVertex",o="#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n";t(69610).l.IncludesShadersStore[i]=o},2360:(e,n,t)=>{const i="fogFragment",o="#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n";t(69610).l.IncludesShadersStore[i]=o},6194:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneFragmentDeclaration:()=>a});const i="clipPlaneFragmentDeclaration",o="#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n";t(69610).l.IncludesShadersStore[i]=o;const a={name:i,shader:o}},6874:(e,n,t)=>{const i="meshUboDeclaration",o="struct Mesh {world : mat4x4<f32>,\nvisibility : f32,};var<uniform> mesh : Mesh;\n#define WORLD_UBO\n";t(69610).l.IncludesShadersStoreWGSL[i]=o},7412:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneFragment:()=>a});const i="clipPlaneFragment",o="#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{discard;}\n#endif\n";t(69610).l.IncludesShadersStore[i]=o;const a={name:i,shader:o}},7806:(e,n,t)=>{t.r(n),t.d(n,{fogFragmentDeclaration:()=>a});const i="fogFragmentDeclaration",o="#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()\n{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n";t(69610).l.IncludesShadersStore[i]=o;const a={name:i,shader:o}},16470:(e,n,t)=>{const i="fogVertex",o="#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n";t(69610).l.IncludesShadersStore[i]=o},28764:(e,n,t)=>{const i="sceneUboDeclaration",o="layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif \nmat4 view;mat4 projection;vec4 vEyePosition;};\n";t(69610).l.IncludesShadersStore[i]=o},29741:(e,n,t)=>{const i="logDepthFragment",o="#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n";t(69610).l.IncludesShadersStore[i]=o},34581:(e,n,t)=>{const i="logDepthDeclaration",o="#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;varying float vFragmentDepth;\n#endif\n";t(69610).l.IncludesShadersStore[i]=o},38780:(e,n,t)=>{const i="logDepthFragment",o="#ifdef LOGARITHMICDEPTH\nfragmentOutputs.fragDepth=log2(fragmentInputs.vFragmentDepth)*uniforms.logarithmicDepthConstant*0.5;\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o},39759:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneFragmentDeclarationWGSL:()=>a});const i="clipPlaneFragmentDeclaration",o="#ifdef CLIPPLANE\nvarying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nvarying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nvarying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nvarying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nvarying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nvarying fClipDistance6: f32;\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o;const a={name:i,shader:o}},47314:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneVertex:()=>a});const i="clipPlaneVertex",o="#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n";t(69610).l.IncludesShadersStore[i]=o;const a={name:i,shader:o}},59013:(e,n,t)=>{const i="fogVertex",o="#ifdef FOG\n#ifdef SCENE_UBO\nvertexOutputs.vFogDistance=(scene.view*worldPos).xyz;\n#else\nvertexOutputs.vFogDistance=(uniforms.view*worldPos).xyz;\n#endif\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o},66407:(e,n,t)=>{t.r(n),t.d(n,{fogFragmentDeclarationWGSL:()=>a});const i="fogFragmentDeclaration",o="#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\nconst E=2.71828;uniform vFogInfos: vec4f;uniform vFogColor: vec3f;varying vFogDistance: vec3f;fn CalcFogFactor()->f32\n{var fogCoeff: f32=1.0;var fogStart: f32=uniforms.vFogInfos.y;var fogEnd: f32=uniforms.vFogInfos.z;var fogDensity: f32=uniforms.vFogInfos.w;var fogDistance: f32=length(fragmentInputs.vFogDistance);if (FOGMODE_LINEAR==uniforms.vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==uniforms.vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==uniforms.vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o;const a={name:i,shader:o}},71636:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneVertexDeclaration:()=>a});const i="clipPlaneVertexDeclaration",o="#ifdef CLIPPLANE\nuniform vec4 vClipPlane;varying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;varying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;varying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;varying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;varying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;varying float fClipDistance6;\n#endif\n";t(69610).l.IncludesShadersStore[i]=o;const a={name:i,shader:o}},73325:(e,n,t)=>{t.r(n),t.d(n,{helperFunctions:()=>a});const i="helperFunctions",o="const float PI=3.1415926535897932384626433832795;const float TWO_PI=6.283185307179586;const float HALF_PI=1.5707963267948966;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float RECIPROCAL_PI4=0.07957747154594767;const float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nmat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}\n#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\n{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\n#else\nreturn\nvec3(\ncolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\nvec3 toGammaSpaceExact(vec3 color)\n{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\n#else\nreturn\nvec3(\ncolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\n#endif\nfloat toLinearSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nvec3 toLinearSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\n#endif\n}\nvec4 toLinearSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfloat toGammaSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,GammaEncodePowerApprox);\n#endif\n}\nvec3 toGammaSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\n#endif\n}\nvec4 toGammaSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfloat square(float value)\n{return value*value;}\nvec3 square(vec3 value)\n{return value*value;}\nfloat pow5(float value) {float sq=value*value;return sq*sq*value;}\nfloat getLuminance(vec3 color)\n{return saturate(dot(color,LuminanceEncodeApprox));}\nfloat getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}\nfloat dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}\nconst float rgbdMaxRange=255.;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =saturate(floor(D)/255.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(saturate(rgb),D);}\nvec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\nvec3 equirectangularToCubemapDirection(vec2 uv) {float longitude=uv.x*TWO_PI-PI;float latitude=HALF_PI-uv.y*PI;vec3 direction;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}\nfloat sqrtClamped(float value) {return sqrt(max(value,0.));}\nfloat avg(vec3 value) {return dot(value,vec3(0.333333333));}";t(69610).l.IncludesShadersStore[i]=o;const a={name:i,shader:o}},75757:(e,n,t)=>{const i="fogVertexDeclaration",o="#ifdef FOG\nvarying vFogDistance: vec3f;\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o},76391:(e,n,t)=>{t.d(n,{SPLATFileLoader:()=>v});var i,o=t(15909),a=t(31612),r=t(98058),s=t(97889),f=t(76595),c=t(51137),l=t(79923),d=t(13833),u=t(26041),p=t(36803),g=t(62128);!function(e){e[e.Splat=0]="Splat",e[e.PointCloud=1]="PointCloud",e[e.Mesh=2]="Mesh",e[e.Reject=3]="Reject"}(i||(i={}));class v{constructor(e=v._DefaultLoadingOptions){this.name=a.B.name,this._assetContainer=null,this.extensions=a.B.extensions,this._loadingOptions=e}createPlugin(e){return new v(e[a.B.name])}async importMeshAsync(e,n,t,i,o,a){return this._parse(e,n,t,i).then((e=>({meshes:e,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})))}static _BuildPointCloud(e,n){if(!n.byteLength)return!1;const t=new Uint8Array(n),i=new Float32Array(n),o=t.length/32;return e.addPoints(o,(function(e,n){const o=i[8*n+0],a=i[8*n+1],r=i[8*n+2];e.position=new l.Pq(o,a,r);const s=t[32*n+24+0]/255,f=t[32*n+24+1]/255,c=t[32*n+24+2]/255;e.color=new u.ov(s,f,c,1)})),!0}static _BuildMesh(e,n){const t=new f.e("PLYMesh",e),i=new Uint8Array(n.data),o=new Float32Array(n.data),a=i.length/32,r=[],s=new p.P;for(let e=0;e<a;e++){const n=o[8*e+0],t=o[8*e+1],i=o[8*e+2];r.push(n,t,i)}if(n.hasVertexColors){const e=new Float32Array(4*a);for(let n=0;n<a;n++){const t=i[32*n+24+0]/255,o=i[32*n+24+1]/255,a=i[32*n+24+2]/255;e[4*n+0]=t,e[4*n+1]=o,e[4*n+2]=a,e[4*n+3]=1}s.colors=e}return s.positions=r,s.indices=n.faces,s.applyToMesh(t),t}_parseSPZ(e,n){const t=new Uint8Array(e),i=new Uint32Array(e),o=i[2],a=t[12],r=t[13];if(t[15]||1347635022!=i[0]||2!=i[1])return new Promise((e=>{e({mode:3,data:s,hasVertexColors:!1})}));const s=new ArrayBuffer(32*o),f=1/(1<<r),c=new Int32Array(1),l=new Uint8Array(c.buffer),d=function(e,n){return l[0]=e[n+0],l[1]=e[n+1],l[2]=e[n+2],l[3]=128&e[n+2]?255:0,c[0]*f};let u=16;const p=new Float32Array(s),v=new Float32Array(s),P=new Uint8ClampedArray(s),m=new Uint8ClampedArray(s);let C=1,h=0;this._loadingOptions.flipY||(C=-1,h=255);for(let e=0;e<o;e++)p[8*e+0]=d(t,u+0),p[8*e+1]=C*d(t,u+3),p[8*e+2]=C*d(t,u+6),u+=9;for(let e=0;e<o;e++){for(let n=0;n<3;n++){const i=(t[u+o+3*e+n]-127.5)/38.25;P[32*e+24+n]=g.X.Clamp(255*(.5+.282*i),0,255)}P[32*e+24+3]=t[u+e]}u+=4*o;for(let e=0;e<o;e++)v[8*e+3+0]=Math.exp(t[u+0]/16-10),v[8*e+3+1]=Math.exp(t[u+1]/16-10),v[8*e+3+2]=Math.exp(t[u+2]/16-10),u+=3;for(let e=0;e<o;e++){const n=t[u+0],i=t[u+1]*C+h,o=t[u+2]*C+h,a=n/127.5-1,r=i/127.5-1,s=o/127.5-1;m[32*e+28+1]=n,m[32*e+28+2]=i,m[32*e+28+3]=o;const f=1-(a*a+r*r+s*s);m[32*e+28+0]=127.5+127.5*Math.sqrt(f<0?0:f),u+=3}if(a){const e=3*((a+1)*(a+1)-1),i=Math.ceil(e/16);let r=u;const f=[],c=n.getEngine().getCaps().maxTextureSize,l=Math.ceil(o/c);for(let e=0;e<i;e++){const e=new Uint8Array(l*c*4*4);f.push(e)}for(let n=0;n<o;n++)for(let i=0;i<e;i++){const e=t[r++],o=Math.floor(i/16);f[o][i%16+16*n]=e}return new Promise((e=>{e({mode:0,data:s,hasVertexColors:!1,sh:f})}))}return new Promise((e=>{e({mode:0,data:s,hasVertexColors:!1})}))}_parse(e,n,t,i){const o=[],a=new ReadableStream({start(e){e.enqueue(new Uint8Array(t)),e.close()}}),s=new DecompressionStream("gzip"),f=a.pipeThrough(s);return new Promise((e=>{new Response(f).arrayBuffer().then((t=>{this._parseSPZ(t,n).then((e=>{const t=new r.t("GaussianSplatting",null,n,this._loadingOptions.keepInRam);t._parentContainer=this._assetContainer,o.push(t),t.updateData(e.data,e.sh)})),e(o)})).catch((()=>{v._ConvertPLYToSplat(t).then((async t=>{switch(t.mode){case 0:{const e=new r.t("GaussianSplatting",null,n,this._loadingOptions.keepInRam);e._parentContainer=this._assetContainer,o.push(e),e.updateData(t.data)}break;case 1:{const e=new d.y("PointCloud",1,n);v._BuildPointCloud(e,t.data)?await e.buildMeshAsync().then((e=>{o.push(e)})):e.dispose()}break;case 2:if(!t.faces)throw new Error("PLY mesh doesn't contain face informations.");o.push(v._BuildMesh(n,t));break;default:throw new Error("Unsupported Splat mode")}e(o)}))}))}))}loadAssetContainerAsync(e,n,t){const i=new s.WZ(e);return this._assetContainer=i,this.importMeshAsync(null,e,n,t).then((e=>(e.meshes.forEach((e=>i.meshes.push(e))),this._assetContainer=null,i))).catch((e=>{throw this._assetContainer=null,e}))}loadAsync(e,n,t){return this.importMeshAsync(null,e,n,t).then((()=>{}))}static _ConvertPLYToSplat(e){const n=new Uint8Array(e),t=(new TextDecoder).decode(n.slice(0,10240)),i="end_header\n",o=t.indexOf(i);if(o<0||!t)return new Promise((n=>{n({mode:0,data:e})}));const a=parseInt(/element vertex (\d+)\n/.exec(t)[1]),s=/element face (\d+)\n/.exec(t);let f=0;s&&(f=parseInt(s[1]));const l=/element chunk (\d+)\n/.exec(t);let d=0;l&&(d=parseInt(l[1]));let u=0,p=0;const g={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let v;!function(e){e[e.Vertex=0]="Vertex",e[e.Chunk=1]="Chunk"}(v||(v={}));let P=1;const m=[],C=[],h=t.slice(0,o).split("\n");for(const e of h)if(e.startsWith("property ")){const[,n,t]=e.split(" ");1==P?(C.push({name:t,type:n,offset:p}),p+=g[n]):0==P&&(m.push({name:t,type:n,offset:u}),u+=g[n]),g[n]||c.V.Warn(`Unsupported property type: ${n}.`)}else if(e.startsWith("element ")){const[,n]=e.split(" ");"chunk"==n?P=1:"vertex"==n&&(P=0)}const L=u,S=p;return r.t.ConvertPLYWithSHToSplatAsync(e).then((n=>{const t=new DataView(e,o+11);let i=S*d+L*a;const r=[];if(f)for(let e=0;e<f;e++){const e=t.getUint8(i);if(3==e){i+=1;for(let n=0;n<e;n++){const e=t.getUint32(i+4*(2-n),!0);r.push(e)}i+=12}}if(d)return new Promise((e=>{e({mode:0,data:n.buffer,sh:n.sh,faces:r,hasVertexColors:!1})}));let s=0,c=0;const l=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],u=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let e=0;e<m.length;e++){const n=m[e];l.includes(n.name)&&s++,u.includes(n.name)&&c++}const p=s==l.length&&3==c,g=f?2:p?0:1;return new Promise((e=>{e({mode:g,data:n.buffer,sh:n.sh,faces:r,hasVertexColors:!!c})}))}))}}v._DefaultLoadingOptions={keepInRam:!1,flipY:!1},(0,o.qS)(new v)},77029:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneVertexDeclarationWGSL:()=>a});const i="clipPlaneVertexDeclaration",o="#ifdef CLIPPLANE\nuniform vClipPlane: vec4<f32>;varying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nuniform vClipPlane2: vec4<f32>;varying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nuniform vClipPlane3: vec4<f32>;varying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nuniform vClipPlane4: vec4<f32>;varying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nuniform vClipPlane5: vec4<f32>;varying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nuniform vClipPlane6: vec4<f32>;varying fClipDistance6: f32;\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o;const a={name:i,shader:o}},81482:(e,n,t)=>{const i="logDepthVertex",o="#ifdef LOGARITHMICDEPTH\nvertexOutputs.vFragmentDepth=1.0+vertexOutputs.position.w;vertexOutputs.position.z=log2(max(0.000001,vertexOutputs.vFragmentDepth))*uniforms.logarithmicDepthConstant;\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o},85197:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneVertexWGSL:()=>a});const i="clipPlaneVertex",o="#ifdef CLIPPLANE\nvertexOutputs.fClipDistance=dot(worldPos,uniforms.vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nvertexOutputs.fClipDistance2=dot(worldPos,uniforms.vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nvertexOutputs.fClipDistance3=dot(worldPos,uniforms.vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nvertexOutputs.fClipDistance4=dot(worldPos,uniforms.vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nvertexOutputs.fClipDistance5=dot(worldPos,uniforms.vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nvertexOutputs.fClipDistance6=dot(worldPos,uniforms.vClipPlane6);\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o;const a={name:i,shader:o}},86560:(e,n,t)=>{const i="fogVertexDeclaration",o="#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n";t(69610).l.IncludesShadersStore[i]=o},93226:(e,n,t)=>{const i="logDepthDeclaration",o="#ifdef LOGARITHMICDEPTH\nuniform logarithmicDepthConstant: f32;varying vFragmentDepth: f32;\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o},93243:(e,n,t)=>{const i="fogFragment",o="#ifdef FOG\nvar fog: f32=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor= vec4f(mix(uniforms.vFogColor,color.rgb,fog),color.a);\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o},96041:(e,n,t)=>{t.d(n,{I:()=>o});var i=t(7481);class o extends i.g{constructor(e,n,t,o,a,r=!0,s=!1,f=3,c=0,l,d,u){super(null,a,!r,s,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,l),this.format=o,this._engine&&(this._engine._caps.textureFloatLinearFiltering||1!==c||(f=1),this._engine._caps.textureHalfFloatLinearFiltering||2!==c||(f=1),this._texture=this._engine.createRawTexture(e,n,t,o,r,s,f,null,c,l??0,d??!1),this.wrapU=i.g.CLAMP_ADDRESSMODE,this.wrapV=i.g.CLAMP_ADDRESSMODE,this._waitingForData=!!u&&!e)}update(e){this._getEngine().updateRawTexture(this._texture,e,this._texture.format,this._texture.invertY,null,this._texture.type,this._texture._useSRGBBuffer),this._waitingForData=!1}clone(){if(!this._texture)return super.clone();const e=new o(null,this.getSize().width,this.getSize().height,this.format,this.getScene(),this._texture.generateMipMaps,this._invertY,this.samplingMode,this._texture.type,this._texture._creationFlags,this._useSRGBBuffer);return e._texture=this._texture,this._texture.incrementReferences(),e}isReady(){return super.isReady()&&!this._waitingForData}static CreateLuminanceTexture(e,n,t,i,a=!0,r=!1,s=3){return new o(e,n,t,1,i,a,r,s)}static CreateLuminanceAlphaTexture(e,n,t,i,a=!0,r=!1,s=3){return new o(e,n,t,2,i,a,r,s)}static CreateAlphaTexture(e,n,t,i,a=!0,r=!1,s=3){return new o(e,n,t,0,i,a,r,s)}static CreateRGBTexture(e,n,t,i,a=!0,r=!1,s=3,f=0,c=0,l=!1){return new o(e,n,t,4,i,a,r,s,f,c,l)}static CreateRGBATexture(e,n,t,i,a=!0,r=!1,s=3,f=0,c=0,l=!1,d=!1){return new o(e,n,t,5,i,a,r,s,f,c,l,d)}static CreateRGBAStorageTexture(e,n,t,i,a=!0,r=!1,s=3,f=0,c=!1){return new o(e,n,t,5,i,a,r,s,f,1,c)}static CreateRTexture(e,n,t,a,r=!0,s=!1,f=i.g.TRILINEAR_SAMPLINGMODE,c=1){return new o(e,n,t,6,a,r,s,f,c)}static CreateRStorageTexture(e,n,t,a,r=!0,s=!1,f=i.g.TRILINEAR_SAMPLINGMODE,c=1){return new o(e,n,t,6,a,r,s,f,c,1)}}},96467:(e,n,t)=>{const i="meshUboDeclaration",o="#ifdef WEBGL2\nuniform mat4 world;uniform float visibility;\n#else\nlayout(std140,column_major) uniform;uniform Mesh\n{mat4 world;float visibility;};\n#endif\n#define WORLD_UBO\n";t(69610).l.IncludesShadersStore[i]=o},97715:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneFragmentWGSL:()=>a});const i="clipPlaneFragment",o="#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fragmentInputs.fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fragmentInputs.fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fragmentInputs.fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fragmentInputs.fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fragmentInputs.fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fragmentInputs.fClipDistance6>0.0)\n{discard;}\n#endif\n";t(69610).l.IncludesShadersStoreWGSL[i]=o;const a={name:i,shader:o}},98327:(e,n,t)=>{const i="sceneUboDeclaration",o="struct Scene {viewProjection : mat4x4<f32>,\n#ifdef MULTIVIEW\nviewProjectionR : mat4x4<f32>,\n#endif \nview : mat4x4<f32>,\nprojection : mat4x4<f32>,\nvEyePosition : vec4<f32>,};\n#define SCENE_UBO\nvar<uniform> scene : Scene;\n";t(69610).l.IncludesShadersStoreWGSL[i]=o}}]);