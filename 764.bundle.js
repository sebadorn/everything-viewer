"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[764],{5186:(e,t,n)=>{n.d(t,{A:()=>a});const a=new class{constructor(){this.listeners={},this.debouncedListeners={}}reset(){this.listeners={},this.debouncedListeners={}}addEventListenerOnce(e,t){const n=a=>{this.removeEventListener(e,n),t.call(this,a)};this.addEventListener(e,n)}addEventListener(e,t){this.listeners[e]||(this.listeners[e]=[]),-1===this.listeners[e].indexOf(t)&&this.listeners[e].push(t)}addEventListenerDebounced(e,t,n){this.debouncedListeners[e]=this.debouncedListeners[e]||{};const a=this.debouncedListeners[e];if(!a[t]){const i=e=>{a[t]&&clearTimeout(a[t].timeoutId),a[t].timeoutId=setTimeout(()=>{t.call(this,e)},n)};a[t]={original:t,handle:i,timeoutId:null},this.addEventListener(e,i)}}removeEventListenerDebounced(e,t){if(this.debouncedListeners[e]?.[t]){const n=this.debouncedListeners[e][t];this.removeEventListener(e,n.handle),clearTimeout(n.timeoutId),delete this.debouncedListeners[e][t]}}removeEventListener(e,t){if(!this.listeners[e])return;const n=this.listeners[e],a=n.length;for(let e=0;e<a;e++)if(n[e]===t)return void n.splice(e,1)}dispatchEvent(e){if(!this.listeners[e.type])return!e.defaultPrevented;const t=this.listeners[e.type].slice(),n=t.length;for(let a=0;a<n;a++)try{t[a].call(this,e)}catch(t){console.error(`error in event listener of type:  ${e.type}`,t)}return!e.defaultPrevented}}},6885:(e,t,n)=>{n.d(t,{A:()=>a});class a{constructor(e){this.name=e||"unknown"}static as(e){if(e.iterator)return e.iterator;const t=new a("as iterator");return e.then(e=>{try{t.add(e,!0)}catch(e){t.reject(e)}},e=>{t.reject(e)}),t}add(e,t=!1){this.nextValue=e,this.done||=t,this.waiting&&(this.waiting.resolve(e),this.waiting=void 0)}resolve(){this.done=!0,this.waiting&&(this.waiting.resolve(this.nextValue),this.waiting=void 0)}reject(e){this.rejectReason=e,this.waiting?.reject(e)}getRecent(){if(this.rejectReason)throw this.rejectReason;return this.nextValue}async*[Symbol.asyncIterator](){for(;!this.done;){if(this.rejectReason)throw this.rejectReason;if(void 0!==this.nextValue&&(yield this.nextValue,this.done))break;this.waiting||(this.waiting={},this.waiting.promise=new Promise((e,t)=>{this.waiting.resolve=e,this.waiting.reject=t})),await this.waiting.promise}yield this.nextValue}async forEach(e,t){let n=0;try{for await(const a of this){const{done:i}=this;try{await e(a,i,n),n++}catch(e){if(!i){console.warn("Caught exception in intermediate value",e);continue}if(!t)throw e;t(e,i)}}}catch(e){if(!t)throw e;t(e,!0)}}generate(e,t){return e(this,this.reject.bind(this)).then(()=>{this.done||this.resolve()},e=>{this.reject(e),t?t(e):console.warn("Couldn't process because",e)})}async nextPromise(){for await(const e of this)if(e)return e;return this.nextValue}async donePromise(){for await(const e of this);return this.nextValue}getNextPromise(){const e=this.nextPromise();return e.iterator=this,e}getDonePromise(){const e=this.donePromise();return e.iterator=this,e}}},11226:(e,t,n)=>{n.r(t),n.d(t,{toLowHighRange:()=>o,toWindowLevel:()=>r});var a=n(59127),i=n(76367);function r(e,t){return{windowWidth:Math.abs(t-e)+1,windowCenter:(e+t+1)/2}}function o(e,t,n=a.A.LINEAR){if(n===a.A.LINEAR)return{lower:t-.5-(e-1)/2,upper:t-.5+(e-1)/2};if(n===a.A.LINEAR_EXACT)return{lower:t-e/2,upper:t+e/2};if(n===a.A.SAMPLED_SIGMOID){return{lower:(0,i.i)(.01,t,e),upper:(0,i.i)(.99,t,e)}}throw new Error("Invalid VOI LUT function")}},14916:(e,t,n)=>{var a;n.d(t,{A:()=>i}),function(e){e.CALIBRATION="calibrationModule",e.CINE="cineModule",e.GENERAL_IMAGE="generalImageModule",e.GENERAL_SERIES="generalSeriesModule",e.GENERAL_STUDY="generalStudyModule",e.IMAGE_PIXEL="imagePixelModule",e.IMAGE_PLANE="imagePlaneModule",e.IMAGE_URL="imageUrlModule",e.MODALITY_LUT="modalityLutModule",e.MULTIFRAME="multiframeModule",e.NM_MULTIFRAME_GEOMETRY="nmMultiframeGeometryModule",e.OVERLAY_PLANE="overlayPlaneModule",e.PATIENT="patientModule",e.PATIENT_STUDY="patientStudyModule",e.PET_IMAGE="petImageModule",e.PET_ISOTOPE="petIsotopeModule",e.PET_SERIES="petSeriesModule",e.SOP_COMMON="sopCommonModule",e.ULTRASOUND_ENHANCED_REGION="ultrasoundEnhancedRegionModule",e.VOI_LUT="voiLutModule",e.WADO_WEB_CLIENT="wadoWebClient"}(a||(a={}));const i=a},17823:(e,t,n)=>{n.d(t,{DF:()=>o,p8:()=>a,tb:()=>i});var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var r=Math.PI/180;function o(e){return e*r}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)})},29845:(e,t,n)=>{var a;n.d(t,{A:()=>i}),function(e){e.ERROR_EVENT="CORNERSTONE_ERROR",e.CACHE_SIZE_EXCEEDED="CACHE_SIZE_EXCEEDED",e.IMAGE_LOAD_ERROR="IMAGE_LOAD_ERROR",e.CAMERA_MODIFIED="CORNERSTONE_CAMERA_MODIFIED",e.CAMERA_RESET="CORNERSTONE_CAMERA_RESET",e.VOI_MODIFIED="CORNERSTONE_VOI_MODIFIED",e.PRESET_MODIFIED="CORNERSTONE_VIEWPORT_RENDERING_PRESET_MODIFIED",e.DISPLAY_AREA_MODIFIED="CORNERSTONE_DISPLAY_AREA_MODIFIED",e.ELEMENT_DISABLED="CORNERSTONE_ELEMENT_DISABLED",e.ELEMENT_ENABLED="CORNERSTONE_ELEMENT_ENABLED",e.IMAGE_RENDERED="CORNERSTONE_IMAGE_RENDERED",e.IMAGE_VOLUME_MODIFIED="CORNERSTONE_IMAGE_VOLUME_MODIFIED",e.IMAGE_VOLUME_LOADING_COMPLETED="CORNERSTONE_IMAGE_VOLUME_LOADING_COMPLETED",e.IMAGE_LOADED="CORNERSTONE_IMAGE_LOADED",e.IMAGE_RETRIEVAL_STAGE="CORNERSTONE_IMAGE_RETRIEVAL_STAGE",e.IMAGE_LOAD_FAILED="CORNERSTONE_IMAGE_LOAD_FAILED",e.VOLUME_VIEWPORT_NEW_VOLUME="CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME",e.VOLUME_LOADED="CORNERSTONE_VOLUME_LOADED",e.VOLUME_LOADED_FAILED="CORNERSTONE_VOLUME_LOADED_FAILED",e.IMAGE_CACHE_IMAGE_ADDED="CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED",e.IMAGE_CACHE_IMAGE_REMOVED="CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED",e.VOLUME_CACHE_VOLUME_ADDED="CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED",e.VOLUME_CACHE_VOLUME_REMOVED="CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED",e.STACK_NEW_IMAGE="CORNERSTONE_STACK_NEW_IMAGE",e.VOLUME_NEW_IMAGE="CORNERSTONE_VOLUME_NEW_IMAGE",e.PRE_STACK_NEW_IMAGE="CORNERSTONE_PRE_STACK_NEW_IMAGE",e.IMAGE_SPACING_CALIBRATED="CORNERSTONE_IMAGE_SPACING_CALIBRATED",e.VIEWPORT_NEW_IMAGE_SET="CORNERSTONE_VIEWPORT_NEW_IMAGE_SET",e.STACK_VIEWPORT_SCROLL="CORNERSTONE_STACK_VIEWPORT_SCROLL",e.STACK_SCROLL_OUT_OF_BOUNDS="STACK_SCROLL_OUT_OF_BOUNDS",e.GEOMETRY_CACHE_GEOMETRY_ADDED="CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED",e.GEOMETRY_CACHE_GEOMETRY_REMOVED="CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_REMOVED",e.VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS="VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS",e.VOLUME_VIEWPORT_SCROLL="VOLUME_VIEWPORT_SCROLL",e.CLIPPING_PLANES_UPDATED="CORNERSTONE_CLIPPING_PLANES_UPDATED",e.WEB_WORKER_PROGRESS="CORNERSTONE_WEB_WORKER_PROGRESS",e.COLORMAP_MODIFIED="CORNERSTONE_COLORMAP_MODIFIED",e.DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED="DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED",e.DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED="DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED",e.DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED="DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED",e.DYNAMIC_VOLUME_TIME_POINT_LOADED="DYNAMIC_VOLUME_TIME_POINT_LOADED",e.GEOMETRY_LOADED="GEOMETRY_LOADED",e.GEOMETRY_LOAD_PROGRESS="GEOMETRY_LOAD_PROGRESS",e.GEOMETRY_LOADED_FAILED="GEOMETRY_LOADED_FAILED",e.ACTORS_CHANGED="CORNERSTONE_ACTORS_CHANGED"}(a||(a={}));const i=a},30329:(e,t,n)=>{n.d(t,{$A:()=>A,Bw:()=>o,C:()=>c,DI:()=>f,Il:()=>b,Io:()=>E,Ln:()=>g,Om:()=>p,Qr:()=>u,Re:()=>d,S8:()=>I,WQ:()=>l,Z0:()=>O,aI:()=>y,ei:()=>M,fA:()=>s,g7:()=>C,hZ:()=>h,hs:()=>m,jb:()=>v,lK:()=>L,o8:()=>r,t2:()=>S,v_:()=>D,vt:()=>i,ze:()=>_});var a=n(17823);function i(){var e=new a.tb(3);return a.tb!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function r(e){var t=new a.tb(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function o(e){var t=e[0],n=e[1],a=e[2];return Math.hypot(t,n,a)}function s(e,t,n){var i=new a.tb(3);return i[0]=e,i[1]=t,i[2]=n,i}function c(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}function h(e,t,n,a){return e[0]=t,e[1]=n,e[2]=a,e}function l(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function d(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function u(e,t,n){return e[0]=t[0]/n[0],e[1]=t[1]/n[1],e[2]=t[2]/n[2],e}function m(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function g(e,t,n,a){return e[0]=t[0]+n[0]*a,e[1]=t[1]+n[1]*a,e[2]=t[2]+n[2]*a,e}function E(e,t){var n=t[0]-e[0],a=t[1]-e[1],i=t[2]-e[2];return Math.hypot(n,a,i)}function _(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e}function f(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function I(e,t){var n=t[0],a=t[1],i=t[2],r=n*n+a*a+i*i;return r>0&&(r=1/Math.sqrt(r)),e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}function p(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function A(e,t,n){var a=t[0],i=t[1],r=t[2],o=n[0],s=n[1],c=n[2];return e[0]=i*c-r*s,e[1]=r*o-a*c,e[2]=a*s-i*o,e}function O(e,t,n){var a=t[0],i=t[1],r=t[2],o=n[3]*a+n[7]*i+n[11]*r+n[15];return o=o||1,e[0]=(n[0]*a+n[4]*i+n[8]*r+n[12])/o,e[1]=(n[1]*a+n[5]*i+n[9]*r+n[13])/o,e[2]=(n[2]*a+n[6]*i+n[10]*r+n[14])/o,e}function M(e,t,n){var a=t[0],i=t[1],r=t[2];return e[0]=a*n[0]+i*n[3]+r*n[6],e[1]=a*n[1]+i*n[4]+r*n[7],e[2]=a*n[2]+i*n[5]+r*n[8],e}function C(e,t){var n=e[0],a=e[1],i=e[2],r=t[0],o=t[1],s=t[2],c=Math.sqrt(n*n+a*a+i*i)*Math.sqrt(r*r+o*o+s*s),h=c&&p(e,t)/c;return Math.acos(Math.min(Math.max(h,-1),1))}function D(e){return e[0]=0,e[1]=0,e[2]=0,e}function S(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function y(e,t){var n=e[0],i=e[1],r=e[2],o=t[0],s=t[1],c=t[2];return Math.abs(n-o)<=a.p8*Math.max(1,Math.abs(n),Math.abs(o))&&Math.abs(i-s)<=a.p8*Math.max(1,Math.abs(i),Math.abs(s))&&Math.abs(r-c)<=a.p8*Math.max(1,Math.abs(r),Math.abs(c))}var w,v=d,L=function(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e},b=o;w=i()},33700:(e,t,n)=>{var a;n.d(t,{A:()=>i}),function(e){e[e.FAR_REPLICATE=1]="FAR_REPLICATE",e[e.ADJACENT_REPLICATE=3]="ADJACENT_REPLICATE",e[e.SUBRESOLUTION=6]="SUBRESOLUTION",e[e.LOSSY=7]="LOSSY",e[e.FULL_RESOLUTION=8]="FULL_RESOLUTION"}(a||(a={}));const i=a},37743:(e,t,n)=>{function a(e){const t=e.indexOf(":");return e.substring(t+1)}n.d(t,{A:()=>a})},43296:(e,t,n)=>{function a(e,t,n){return Math.abs(e-t)<=n}function i(e){return"number"==typeof e}function r(e){return e&&"object"==typeof e&&"length"in e&&"number"==typeof e.length&&e.length>0&&"number"==typeof e[0]}function o(e,t,n=1e-5){return typeof e==typeof t&&null!==e&&null!==t&&(i(e)&&i(t)?a(e,t,n):!(!r(e)||!r(t))&&function(e,t,n=1e-5){if(e.length!==t.length)return!1;for(let i=0;i<e.length;i++)if(!a(e[i],t[i],n))return!1;return!0}(e,t,n))}n.d(t,{Ay:()=>d,Ph:()=>l,WC:()=>h,n4:()=>o});const s=e=>"number"==typeof e?-e:e?.map?e.map(s):!e,c=e=>"number"==typeof e?Math.abs(e):e?.map?e.map(c):e,h=(e,t,n=void 0)=>o(e,s(t),n),l=(e,t,n=void 0)=>o(c(e),c(t),n);const d=o},45630:(e,t,n)=>{n.d(t,{A:()=>i});var a=n(5186);function i(e=a.A,t,n=null){if(!t)throw new Error("Event type was not defined");const i=new CustomEvent(t,{detail:n,cancelable:!0});return e?.dispatchEvent(i)}},50893:(e,t,n)=>{n.d(t,{A:()=>o});var a=n(74374);let i={};const r={add:(e,t)=>{r.addRaw(e,{...t,metadata:structuredClone(t.metadata)})},addRaw:(e,t)=>{const n=t.type;i[e]||(i[e]={}),i[e][n]=t.metadata},get:(e,t)=>i[t]?.[e],clear:()=>{i={}}};(0,a.addProvider)(r.get);const o=r},59127:(e,t,n)=>{var a;n.d(t,{A:()=>i}),function(e){e.LINEAR="LINEAR",e.SAMPLED_SIGMOID="SIGMOID",e.LINEAR_EXACT="LINEAR_EXACT"}(a||(a={}));const i=a},74374:(e,t,n)=>{n.r(t),n.d(t,{addProvider:()=>i,get:()=>s,removeAllProviders:()=>o,removeProvider:()=>r});const a=[];function i(e,t=0){let n;for(n=0;n<a.length&&!(a[n].priority<=t);n++);a.splice(n,0,{priority:t,provider:e})}function r(e){for(let t=0;t<a.length;t++)if(a[t].provider===e){a.splice(t,1);break}}function o(){for(;a.length>0;)a.pop()}function s(e,...t){for(let n=0;n<a.length;n++){const i=a[n].provider(e,...t);if(void 0!==i)return i}}},76367:(e,t,n)=>{n.d(t,{i:()=>a});const a=(e,t,n)=>t-n/4*Math.log((1-e)/e)},86468:(e,t,n)=>{n.d(t,{X6:()=>s,ii:()=>o});var a=n(30329);class i{constructor(e={}){this._dimensions=3,this._length=0,this._byteSize=4,this.growSize=128;const{initialSize:t=1024,dimensions:n=3,growSize:a=128}=e,i=t*n;this.growSize=a,this.array=new ArrayBuffer(i*this._byteSize),this.data=new Float32Array(this.array),this._dimensions=n}forEach(e){for(let t=0;t<this._length;t++)e(this.getPoint(t),t)}get length(){return this._length}get dimensions(){return this._dimensions}get dimensionLength(){return this._length*this._dimensions}getPoint(e){if(e<0&&(e+=this._length),e<0||e>=this._length)return;const t=this._dimensions*e;return this.data.subarray(t,t+this._dimensions)}getPointArray(e){const t=[];if(e<0&&(e+=this._length),e<0||e>=this._length)return;const n=this._dimensions*e;for(let e=0;e<this._dimensions;e++)t.push(this.data[e+n]);return t}grow(e=1,t=this.growSize){if(this.dimensionLength+e*this._dimensions<=this.data.length)return;const n=this.data.length+t,a=new ArrayBuffer(n*this._dimensions*this._byteSize),i=new Float32Array(a);i.set(this.data),this.data=i,this.array=a}reverse(){const e=Math.floor(this._length/2);for(let t=0;t<e;t++){const e=t*this._dimensions,n=(this._length-1-t)*this._dimensions;for(let t=0;t<this._dimensions;t++){const a=this.data[e+t];this.data[e+t]=this.data[n+t],this.data[n+t]=a}}}getTypedArray(){return this.data}push(e){this.grow(1);const t=this.length*this._dimensions;for(let n=0;n<this._dimensions;n++)this.data[n+t]=e[n];this._length++}map(e){const t=[];for(let n=0;n<this._length;n++)t.push(e(this.getPoint(n),n));return t}get points(){return this.map(e=>e)}toXYZ(){const e={x:[],y:[]};this._dimensions>=3&&(e.z=[]);const{x:t,y:n,z:a}=e;return this.forEach(e=>{t.push(e[0]),n.push(e[1]),a&&a.push(e[2])}),e}static fromXYZ({x:e,y:t,z:n}){const a=i.create3(e.length);let r=0;for(let i=0;i<e.length;i++)a.data[r++]=e[i],a.data[r++]=t[i],a.data[r++]=n?n[i]:0;return a._length=e.length,a}subselect(e=10,t=0){const n=new i({initialSize:e,dimensions:this._dimensions});for(let a=0;a<e;a++){const i=(t+Math.floor(this.length*a/e))%this.length;n.push(this.getPoint(i))}return n}static create3(e=128,t){e=Math.max(e,t?.length||0);const n=new i({initialSize:e,dimensions:3});return t&&t.forEach(e=>n.push(e)),n}static create2(e=128){return new i({initialSize:e,dimensions:2})}}function r(e){const t=a.vt(),n=e.getDimensions(),r=i.create3(n[0]),o=i.create3(n[1]),s=i.create3(n[2]),c=e.getDirection(),h=c.slice(0,3),l=c.slice(3,6),d=c.slice(6,9),u=e.getSpacing(),[m,g,E]=u,_=e.indexToWorld([0,0,0]),f=a.fA(h[0]*m,h[1]*m,h[2]*m),I=a.fA(l[0]*g,l[1]*g,l[2]*g),p=a.fA(d[0]*E,d[1]*E,d[2]*E),A=a.vt();for(let e=0;e<n[0];e++)r.push(a.WQ(A,_,a.hs(A,f,e)));for(let e=0;e<n[1];e++)o.push(a.hs(A,I,e));for(let e=0;e<n[2];e++)s.push(a.hs(A,p,e));const O=r.getTypedArray(),M=o.getTypedArray(),C=s.getTypedArray();return(e,n=t)=>{const[a,i,r]=e,o=3*a,s=3*i,c=3*r;return n[0]=O[o]+M[s]+C[c],n[1]=O[o+1]+M[s+1]+C[c+1],n[2]=O[o+2]+M[s+2]+C[c+2],n}}function o(e,t){const{pointInShapeFn:n,callback:a,boundsIJK:i,returnPoints:o=!1}=t;let s;if(e.getScalarData)s=e.getScalarData();else{const t=e.getPointData().getScalars();if(t)s=t.getData();else{const{voxelManager:t}=e.get("voxelManager")||{};t&&(s=t.getCompleteScalarDataArray())}}const c=e.getDimensions(),h=[[0,c[0]],[0,c[1]],[0,c[2]]],l=function({imageData:e,bounds:t,scalarData:n,pointInShapeFn:a,callback:i}){const[[o,s],[c,h],[l,d]]=t,{numComps:u}=e,m=e.getDimensions(),g=r(e),E=[0,0,0],_=u||n.length/m[2]/m[1]/m[0],f=m[0]*_,I=m[1]*f,p=[];for(let e=l;e<=d;e++){E[2]=e;const t=e*I;for(let e=c;e<=h;e++){E[1]=e;const r=t+e*f;for(let e=o;e<=s;e++){E[0]=e;const t=g(E);if(a(t,E)){const a=r+e*_;let o;o=_>2?[n[a],n[a+1],n[a+2]]:n[a],p.push({value:o,index:a,pointIJK:E,pointLPS:t.slice()}),i({value:o,index:a,pointIJK:E,pointLPS:t})}}}}return p}({imageData:e,bounds:i||h,scalarData:s,pointInShapeFn:n,callback:a});return o?l:void 0}function s({voxelManager:e,bounds:t,imageData:n,pointInShapeFn:a,callback:i,returnPoints:o}){const[[s,c],[h,l],[d,u]]=t,m=r(n),g=[0,0,0],E=[];for(let t=d;t<=u;t++){g[2]=t;for(let t=h;t<=l;t++){g[1]=t;for(let t=s;t<=c;t++){g[0]=t;const n=m(g);if(a(n,g)){const t=e.toIndex(g),a=e.getAtIndex(t);o&&E.push({value:a,index:t,pointIJK:[...g],pointLPS:n.slice()}),i?.({value:a,index:t,pointIJK:g,pointLPS:n})}}}}return E}},95254:(e,t,n)=>{n.d(t,{A:()=>d});var a=n(95816);const i=[[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],r=[[0,-1,0],[0,1,0]],o=[[0,-1,0],[0,1,0],[0,0,-1]],s=[[0,-1,0],[0,1,0],[0,0,1]];class c{static copyMap(e,t){for(const[n,a]of t.rows)e.rows.set(n,structuredClone(a))}constructor(e,t,n=1){this.rows=new Map,this.height=1,this.width=1,this.depth=1,this.jMultiple=1,this.kMultiple=1,this.numComps=1,this.pixelDataConstructor=Uint8Array,this.updateScalarData=function(e){e.fill(0);this.forEach((t,n,a)=>{const{start:i,end:r,value:o}=n;for(let n=i;n<r;n++)e[t+n]=o})},this.get=e=>{const t=e%this.jMultiple,n=(e-t)/this.jMultiple,a=this.getRLE(t,n);return a?.value??this.defaultValue},this.getRun=(e,t)=>{const n=e+t*this.height;return this.rows.get(n)},this.set=(e,t)=>{if(void 0===t)return;const n=e%this.width,a=(e-n)/this.width,i=this.rows.get(a);if(!i)return void this.rows.set(a,[{start:n,end:n+1,value:t}]);const r=this.findIndex(i,n),o=i[r],s=i[r-1];if(!o)return s&&s.value===t&&s.end===n?void s.end++:void(i[r]={start:n,end:n+1,value:t});const{start:c,end:h,value:l}=o;if(t===l&&n>=c)return;const d={start:n,end:n+1,value:t},u=n>c,m=u?r+1:r,g=u?o:s;let E=u?i[r+1]:o;if(g?.value===t&&g?.end===n)return g.end++,void(E?.value===t&&E.start===n+1?(g.end=E.end,i.splice(r,1)):E?.start===n&&(E.start++,E.start===E.end&&(i.splice(r,1),E=i[r],E?.start===n+1&&E.value===t&&(g.end=E.end,i.splice(r,1)))));if(E?.value===t&&E.start===n+1)return E.start--,void(g?.end>n&&(g.end=n,g.end===g.start&&i.splice(r,1)));if(E?.start===n&&E.end===n+1){E.value=t;const e=i[r+1];return void(e?.start==n+1&&e.value===t&&(i.splice(r+1,1),E.end=e.end))}n===E?.start&&E.start++,u&&h>n+1?i.splice(m,0,d,{start:n+1,end:g.end,value:g.value}):i.splice(m,0,d),g?.end>n&&(g.end=n)},this.width=e,this.height=t,this.depth=n,this.jMultiple=e,this.kMultiple=this.jMultiple*t}static{this.getScalarData=function(e=Uint8ClampedArray){const t=new e(this.frameSize);return this.map.updateScalarData(t),t}}toIJK(e){const t=e%this.jMultiple;return[t,(e-t)/this.jMultiple%this.height,Math.floor(e/this.kMultiple)]}toIndex([e,t,n]){return e+n*this.kMultiple+t*this.jMultiple}getRLE(e,t,n=0){const a=this.rows.get(t+n*this.height);if(!a)return;const i=a[this.findIndex(a,e)];return e>=i?.start?i:void 0}has(e){const t=e%this.jMultiple,n=(e-t)/this.jMultiple,a=this.getRLE(t,n);return void 0!==a?.value}delete(e){const t=e%this.width,n=(e-t)/this.width,a=this.rows.get(n);if(!a)return;const i=this.findIndex(a,t),r=a[i];if(!r||r.start>t)return;if(r.end===t+1)return r.end--,void(r.start>=r.end&&(a.splice(i,1),a.length||this.rows.delete(n)));if(r.start===t)return void r.start++;const o={value:r.value,start:t+1,end:r.end};r.end=t,a.splice(i+1,0,o)}findIndex(e,t){for(let n=0;n<e.length;n++){const{end:a}=e[n];if(t<a)return n}return e.length}forEach(e,t){const n=t?.rowModified;for(const[t,a]of this.rows){const i=n?[...a]:a;for(const n of i)e(t*this.width,n,a)}}forEachRow(e){for(const[t,n]of this.rows)e(t*this.width,n)}clear(){this.rows.clear()}keys(){return[...this.rows.keys()]}getPixelData(e=0,t){t?t.fill(0):t=new this.pixelDataConstructor(this.width*this.height*this.numComps);const{width:n,height:a,numComps:i}=this;for(let r=0;r<a;r++){const a=this.getRun(r,e);if(a)if(1===i)for(const e of a){const a=r*n,{start:i,end:o,value:s}=e;for(let e=i;e<o;e++)t[a+e]=s}else for(const e of a){const a=r*n*i,{start:o,end:s,value:c}=e;for(let e=o;e<s;e+=i)for(let n=0;n<i;n++)t[a+e+n]=c[n]}}return t}floodFill(e,t,n,a,i){const r=this.getRLE(e,t,n);if(!r)throw new Error(`Initial point ${e},${t},${n} isn't in the RLE`);const o=[[r,t,n]],s=r.value;if(s===a)throw new Error(`source (${s}) and destination (${a}) are identical`);return this.flood(o,s,a,i)}flood(e,t,n,a){let i=0;const{planar:r=!0,diagonals:o=!0,singlePlane:s=!1}=a||{},c={planar:r,diagonals:o,singlePlane:s};for(;e.length;){const a=e.pop(),[r]=a;if(r.value!==t)continue;r.value=n,i+=r.end-r.start;const o=this.findAdjacents(a,c).filter(e=>e&&e[0].value===t);e.push(...o)}return i}fillFrom(e,t){for(let n=t[2][0];n<=t[2][1];n++)for(let a=t[1][0];a<=t[1][1];a++){let i,r;for(let o=t[0][0];o<=t[0][1];o++){const t=e(o,a,n);void 0!==t?(r||(r=[],this.rows.set(a+n*this.height,r)),i&&i.value!==t&&(i=void 0),i||(i={start:o,end:o,value:t},r.push(i)),i.end++):i=void 0}}}findAdjacents(e,{diagonals:t=!0,planar:n=!0,singlePlane:a=!1}){const[c,h,l,d]=e,{start:u,end:m}=c,g=u>0&&this.getRLE(u-1,h,l),E=m<this.width&&this.getRLE(m,h,l),_=t?[u>0?u-1:u,m<this.width?m+1:m]:[u,m],f=[];g&&f.push([g,h,l]),E&&f.push([E,h,l]);for(const e of d||(a?r:i)){const[,t,c]=e,u=t+h,m=c+l;if(u<0||u>=this.height)continue;if(m<0||m>=this.depth)continue;const g=this.getRun(u,m);if(g)for(const e of g){const t=d||a&&r||n&&c>0&&s||n&&c<0&&o||i;e.end<=_[0]||e.start>=_[1]||f.push([e,u,m,t])}}return f}}var h=n(43296),l=n(86468);class d{get id(){return this._id}constructor(e,t){this.modifiedSlices=new Set,this.boundsIJK=[[1/0,-1/0],[1/0,-1/0],[1/0,-1/0]],this.scalarData=null,this._sliceDataCache=null,this.getAtIJK=(e,t,n)=>{const a=this.toIndex([e,t,n]);return this._get(a)},this.setAtIJK=(e,t,n,a)=>{const i=this.toIndex([e,t,n]),r=this._set(i,a);return!1!==r&&(this.modifiedSlices.add(n),d.addBounds(this.boundsIJK,[e,t,n])),r},this.getAtIJKPoint=([e,t,n])=>this.getAtIJK(e,t,n),this.setAtIJKPoint=([e,t,n],a)=>{this.setAtIJK(e,t,n,a)},this.getAtIndex=e=>this._get(e),this.setAtIndex=(e,t)=>{const n=this._set(e,t);if(!1!==n){const t=this.toIJK(e);this.modifiedSlices.add(t[2]),d.addBounds(this.boundsIJK,t)}return n},this.getMiddleSliceData=()=>{const e=Math.floor(this.dimensions[2]/2);return this.getSliceData({sliceIndex:e,slicePlane:2})},this.forEach=(e,t={})=>{const n=t.boundsIJK||this.getBoundsIJK(),a=t.isInObject||this.isInObject||(()=>!0),i=t.returnPoints||!1,r=t.imageData,o=Math.min(n[0][0],n[0][1]),s=Math.max(n[0][0],n[0][1]),h=Math.min(n[1][0],n[1][1]),d=Math.max(n[1][0],n[1][1]),u=Math.min(n[2][0],n[2][1]),m=Math.max(n[2][0],n[2][1]),g=[];if(r){return(0,l.X6)({voxelManager:this,imageData:t.imageData,bounds:[[o,s],[h,d],[u,m]],pointInShapeFn:a,callback:e,returnPoints:i})}if(this.map){if(this.map instanceof c)return this.rleForEach(e,t);for(const t of this.map.keys()){const n=this.toIJK(t);if(!a(null,n))continue;const r=this._get(t);i&&g.push({value:r,index:t,pointIJK:n,pointLPS:null}),e({value:r,index:t,pointIJK:n,pointLPS:null})}return g}for(let t=u;t<=m;t++){const n=t*this.frameSize;for(let r=h;r<=d;r++){for(let c=o,h=n+r*this.width+c;c<=s;c++,h++){const n=this.getAtIndex(h),o=[c,r,t];a(null,o)&&(i&&g.push({value:n,index:h,pointIJK:o,pointLPS:null}),e({value:n,index:h,pointIJK:[c,r,t],pointLPS:null}))}}}return g},this.getSliceData=({sliceIndex:e,slicePlane:t})=>{const[n,a,i]=this.dimensions,r=n*a,o=e*r;let s;const c=this.getConstructor();if("function"!=typeof c)return new Uint8Array(0);let h;switch(t){case 0:s=a*i,h=new c(s);for(let t=0;t<a;t++)for(let a=0;a<i;a++){const o=e+t*n+a*r;this.setSliceDataValue(h,t*i+a,this._get(o))}break;case 1:s=n*i,h=new c(s);for(let t=0;t<n;t++)for(let a=0;a<i;a++){const i=t+e*n+a*r;this.setSliceDataValue(h,t+a*n,this._get(i))}break;case 2:s=n*a,h=new c(s);for(let e=0;e<s;e++)this.setSliceDataValue(h,e,this._get(o+e));break;default:throw new Error("Oblique plane - todo - implement as ortho normal vector")}return h},this.dimensions=e,this.width=e[0],this.frameSize=this.width*e[1],this._get=t._get,this._set=t._set,this._id=t._id||"",this._getConstructor=t._getConstructor,this.numberOfComponents=this.numberOfComponents||1,this.scalarData=t.scalarData,this._getScalarData=t._getScalarData,this._updateScalarData=t._updateScalarData}getMinMax(){let e,t;return this.forEach(({value:n})=>{const a=Array.isArray(n);if(void 0===e&&(e=a?[...n]:n,t=a?[...n]:n),a)for(let a=0;a<n.length;a++)e[a]=Math.min(e[a],n[a]),t[a]=Math.max(t[a],n[a]);else e=Math.min(e,n),t=Math.max(t,n)},{boundsIJK:this.getDefaultBounds()}),{min:e,max:t}}toIJK(e){return[e%this.width,Math.floor(e%this.frameSize/this.width),Math.floor(e/this.frameSize)]}toIndex(e){return e[0]+e[1]*this.width+e[2]*this.frameSize}getDefaultBounds(){return this.dimensions.map(e=>[0,e-1])}getBoundsIJK(){return this.boundsIJK[0][0]<this.dimensions[0]?this.boundsIJK:this.getDefaultBounds()}rleForEach(e,t){const n=t?.boundsIJK||this.getBoundsIJK(),{isWithinObject:a}=t||{},i=this.map;if(i){i.defaultValue=void 0;for(let t=n[2][0];t<=n[2][1];t++)for(let r=n[1][0];r<=n[1][1];r++){const n=i.getRun(r,t);if(n)for(const i of n){const{start:n,end:o,value:s}=i,c=this.toIndex([0,r,t]);for(let i=n;i<o;i++){const n={value:s,index:c+i,pointIJK:[i,r,t]};!1!==a?.(n)&&e(n)}}}}else console.warn("No map found, you need to use a map voxel manager to use rleForEach")}getScalarData(e=!1){if(this.scalarData)return this._updateScalarData?.(this.scalarData),this.scalarData;if(this._getScalarData){const t=this._getScalarData();return e&&console.log("Not transient, should store value",t),t}throw new Error("No scalar data available")}setScalarData(e){this.scalarData=e}getScalarDataLength(){if(this.scalarData)return this.scalarData.length;if(this._getScalarDataLength)return this._getScalarDataLength();throw new Error("No scalar data available")}get sizeInBytes(){return this.getScalarDataLength()*this.bytePerVoxel}get bytePerVoxel(){if(this.scalarData)return this.scalarData.BYTES_PER_ELEMENT;return this._get(0).BYTES_PER_ELEMENT}clearBounds(){this.boundsIJK.map(e=>{e[0]=1/0,e[1]=-1/0})}clear(){this.map?.clear(),this.clearBounds(),this.modifiedSlices.clear(),this.points?.clear()}getConstructor(){return this.scalarData?this.scalarData.constructor:this._getConstructor?this._getConstructor():(console.warn("No scalar data available or can be used to get the constructor"),Float32Array)}getArrayOfModifiedSlices(){return Array.from(this.modifiedSlices)}resetModifiedSlices(){this.modifiedSlices.clear()}setBounds(e){this.boundsIJK=e}static addBounds(e,t){e||(e=[[1/0,-1/0],[1/0,-1/0],[1/0,-1/0]]),e[0][0]=Math.min(t[0],e[0][0]),e[0][1]=Math.max(t[0],e[0][1]),e[1][0]=Math.min(t[1],e[1][0]),e[1][1]=Math.max(t[1],e[1][1]),e[2][0]=Math.min(t[2],e[2][0]),e[2][1]=Math.max(t[2],e[2][1])}addPoint(e){const t=Array.isArray(e)?e[0]+this.width*e[1]+this.frameSize*e[2]:e;this.points||(this.points=new Set),this.points.add(t)}getPoints(){return this.points?[...this.points].map(e=>this.toIJK(e)):[]}setSliceDataValue(e,t,n){if(Array.isArray(n))for(let a=0;a<n.length;a++)e[t*n.length+a]=this.toNumber(n[a]);else e[t]=this.toNumber(n)}toNumber(e){return"number"==typeof e?e:Array.isArray(e)&&e[0]||0}static _createRGBScalarVolumeVoxelManager({dimensions:e,scalarData:t,numberOfComponents:n=3,id:a}){const i=new d(e,{_get:e=>(e*=n,[t[e++],t[e++],t[e++]]),_id:a||"_createRGBScalarVolumeVoxelManager",_set:(e,n)=>{e*=3;const a=!(0,h.Ay)(t[e],n);return t[e++]=n[0],t[e++]=n[1],t[e++]=n[2],a},numberOfComponents:n,scalarData:t});return i.clear=()=>{t.fill(0)},i}static createImageVolumeVoxelManager({dimensions:e,imageIds:t,numberOfComponents:n=1,id:i}){const r=e[0]*e[1];function o(n){const i=Math.floor(n/r);if(i<0||i>=e[2])return{};const o=t[i];if(!o)return console.warn(`ImageId not found for sliceIndex: ${i}`),{pixelData:null,pixelIndex:null};const s=a.Ay.getImage(o);if(!s)return console.warn(`Image not found for imageId: ${o}`),{pixelData:null,pixelIndex:null};return{voxelManager:s.voxelManager,pixelIndex:n%r}}const s=new d(e,{_get:function(e){const{voxelManager:t,pixelIndex:n}=o(e);return t&&null!==n?t.getAtIndex(n):null},_set:function(e,t){const{voxelManager:n,pixelIndex:a}=o(e);if(!n||null===a)return!1;const i=n.getAtIndex(a),r=!(0,h.Ay)(t,i);return r?(n.setAtIndex(a,t),!0):r},numberOfComponents:n,_getConstructor:()=>{const{voxelManager:e,pixelIndex:t}=o(0);return e&&null!==t?e.getConstructor():null},_id:i||"createImageVolumeVoxelManager"});return s.getMiddleSliceData=()=>{const t=Math.floor(e[2]/2);return s.getSliceData({sliceIndex:t,slicePlane:2})},s.clear=()=>{for(const e of t){a.Ay.getImage(e).voxelManager.clear()}},s.getRange=()=>{let e=1/0,n=-1/0;for(const i of t){const t=a.Ay.getImage(i);t&&(t.minPixelValue<e&&(e=t.minPixelValue),t.maxPixelValue>n&&(n=t.maxPixelValue))}return e===1/0&&n===-1/0?[0,0]:[e,n]},s._getScalarDataLength=()=>{const{voxelManager:t,pixelIndex:n}=o(0);return t&&null!==n?t.getScalarDataLength()*e[2]:0},s.getCompleteScalarDataArray=()=>{const t=s._getConstructor();if(!t)return new Uint8Array(0);const a=new t(s.getScalarDataLength()),i=e[0]*e[1]*n;for(let t=0;t<e[2];t++){const{voxelManager:e,pixelIndex:r}=o(t*i/n);if(e&&null!==r){const r=t*i,o=e.getScalarData();if(1===n)a.set(o,r);else for(let e=0;e<o.length;e+=n)for(let t=0;t<n;t++)a[r+e+t]=o[e+t]}}return a},s.setCompleteScalarDataArray=i=>{const r=e[0]*e[1]*n,c=s._getConstructor();let h=1/0,l=-1/0;for(let s=0;s<e[2];s++){const{voxelManager:e}=o(s*r/n);if(e&&c){const n=s*r,o=n+r,d=new c(r);if(d.set(i.subarray(n,o)),e.scalarData)e.scalarData.set(d),e.modifiedSlices.add(s);else for(let t=0;t<r;t++)e.setAtIndex(t,d[t]);for(let e=0;e<d.length;e++){const t=d[e];h=Math.min(h,t),l=Math.max(l,t)}const u=t[s],m=a.Ay.getImage(u);m&&(m.minPixelValue=h,m.maxPixelValue=l)}}for(let t=0;t<e[2];t++)s.modifiedSlices.add(t);s.boundsIJK=[[0,e[0]-1],[0,e[1]-1],[0,e[2]-1]]},s}static createScalarVolumeVoxelManager({dimensions:e,scalarData:t,numberOfComponents:n,id:a}){if(3!==e.length)throw new Error("Dimensions must be provided as [number, number, number] for [width, height, depth]");if(!n&&((n=t.length/e[0]/e[1]/e[2])>4||n<1||2===n))throw new Error(`Number of components ${n} must be 1, 3 or 4`);return n>1?d._createRGBScalarVolumeVoxelManager({dimensions:e,scalarData:t,numberOfComponents:n,id:a}):d._createNumberVolumeVoxelManager({dimensions:e,scalarData:t,id:a})}static createScalarDynamicVolumeVoxelManager({imageIdGroups:e,dimensions:t,dimensionGroupNumber:n=1,timePoint:i=0,numberOfComponents:r=1,id:o}){let s=0;if(void 0!==n?s=n-1:void 0!==i&&(console.warn("Warning: timePoint parameter is deprecated. Please use dimensionGroupNumber instead. timePoint is zero-based while dimensionGroupNumber starts at 1."),s=i),!r){const n=a.Ay.getImage(e[0][0]);if(!n)throw new Error("Unable to determine number of components: No image found");if((r=n.getPixelData().length/(t[0]*t[1]))>4||r<1||2===r)throw new Error(`Number of components ${r} must be 1, 3 or 4`)}const c=e.map(e=>d.createImageVolumeVoxelManager({dimensions:t,imageIds:e,numberOfComponents:r,id:o})),h=new d(t,{_get:e=>c[s]._get(e),_set:(e,t)=>c[s]._set(e,t),numberOfComponents:r,_id:o||"createScalarDynamicVolumeVoxelManager"});return h.getScalarDataLength=()=>c[s].getScalarDataLength(),h.getConstructor=()=>c[s].getConstructor(),h.getRange=()=>c[s].getRange(),h.getMiddleSliceData=()=>c[s].getMiddleSliceData(),h.setTimePoint=e=>{console.warn("Warning: setTimePoint is deprecated. Please use setDimensionGroupNumber instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1."),h.setDimensionGroupNumber(e+1)},h.setDimensionGroupNumber=e=>{s=e-1,h._get=e=>c[s]._get(e),h._set=(e,t)=>c[s]._set(e,t)},h.getAtIndexAndTimePoint=(e,t)=>(console.warn("Warning: getAtIndexAndTimePoint is deprecated. Please use getAtIndexAndDimensionGroup instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1."),h.getAtIndexAndDimensionGroup(e,t+1)),h.getAtIndexAndDimensionGroup=(e,t)=>c[t-1]._get(e),h.getTimePointScalarData=e=>(console.warn("Warning: getTimePointScalarData is deprecated. Please use getDimensionGroupScalarData instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1."),h.getDimensionGroupScalarData(e+1)),h.getDimensionGroupScalarData=e=>c[e-1].getCompleteScalarDataArray(),h.getCurrentTimePointScalarData=()=>(console.warn("Warning: getCurrentTimePointScalarData is deprecated. Please use getCurrentDimensionGroupScalarData instead."),h.getCurrentDimensionGroupScalarData()),h.getCurrentDimensionGroupScalarData=()=>c[s].getCompleteScalarDataArray(),h.getCurrentTimePoint=()=>(console.warn("Warning: getCurrentTimePoint is deprecated. Please use getCurrentDimensionGroupNumber instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1."),s),h.getCurrentDimensionGroupNumber=()=>s+1,h}static createImageVoxelManager({width:e,height:t,scalarData:n,numberOfComponents:a=1,id:i}){const r=[e,t,1];if(!a&&((a=n.length/e/t)>4||a<1||2===a))throw new Error(`Number of components ${a} must be 1, 3 or 4`);return a>1?d._createRGBScalarVolumeVoxelManager({dimensions:r,scalarData:n,numberOfComponents:a,id:i}):d._createNumberVolumeVoxelManager({dimensions:r,scalarData:n,id:i})}static _createNumberVolumeVoxelManager({dimensions:e,scalarData:t,id:n}){const a=new d(e,{_get:e=>t[e],_set:(e,n)=>{const a=t[e]!==n;return t[e]=n,a},_getConstructor:()=>t.constructor,_id:n||"_createNumberVolumeVoxelManager"});return a.scalarData=t,a.clear=()=>{a.scalarData.fill(0)},a.getMiddleSliceData=()=>{const t=Math.floor(e[2]/2);return a.getSliceData({sliceIndex:t,slicePlane:2})},a}static createMapVoxelManager({dimension:e,id:t}){const n=new Map,a=new d(e,{_get:n.get.bind(n),_set:(e,t)=>n.set(e,t)&&!0,_id:t||"createMapVoxelManager"});return a.map=n,a}static createHistoryVoxelManager(e,t){const n=new Map,{dimensions:a}=e,i=new d(a,{_get:e=>n.get(e),_set:function(e,t){if(n.has(e))t===n.get(e)&&n.delete(e);else{const a=this.sourceVoxelManager.getAtIndex(e);if(a===t)return!1;n.set(e,a)}this.sourceVoxelManager.setAtIndex(e,t)},_id:t||"createHistoryVoxelManager"});return i.map=n,i.scalarData=e.scalarData,i.sourceVoxelManager=e,i}static createRLEHistoryVoxelManager(e,t){const{dimensions:n}=e,a=new c(n[0],n[1],n[2]),i=new d(n,{_get:e=>a.get(e),_set:function(e,t){const n=a.get(e);if(void 0===n){const n=this.sourceVoxelManager.getAtIndex(e);if(n===t||void 0===n&&0===t||null===t)return!1;a.set(e,n??0)}else t!==n&&null!==t||(a.delete(e),t=n);this.sourceVoxelManager.setAtIndex(e,t)},_getScalarData:c.getScalarData,_updateScalarData:e=>(a.updateScalarData(e),e),_id:t||"createRLEHistoryVoxelManager"});return i.map=a,i.sourceVoxelManager=e,i}static createLazyVoxelManager({dimensions:e,planeFactory:t,id:n}){const a=new Map,[i,r]=e,o=i*r,s=new d(e,{_get:e=>a.get(Math.floor(e/o))[e%o],_set:(e,n)=>{const s=Math.floor(e/o);let c=a.get(s);return c||(c=t(i,r),a.set(s,c)),c[e%o]=n,!0},_id:n||"createLazyVoxelManager"});return s.map=a,s}static createRLEVolumeVoxelManager({dimensions:e,id:t}){const[n,a,i]=e,r=new c(n,a,i),o=new d(e,{_get:e=>r.get(e),_set:(e,t)=>(r.set(e,t),!0),_getScalarData:c.getScalarData,_updateScalarData:e=>(r.updateScalarData(e),e),_id:t||"createRLEVolumeVoxelManager"});return o.map=r,o.getPixelData=r.getPixelData.bind(r),o}static createRLEImageVoxelManager({dimensions:e,id:t}){const[n,a]=e;return d.createRLEVolumeVoxelManager({dimensions:[n,a,1],id:t})}static addInstanceToImage(e){const{width:t,height:n}=e,a=e.voxelManager.getScalarData();a.length>=t*n?e.voxelManager=d.createScalarVolumeVoxelManager({dimensions:[t,n,1],scalarData:a}):(e.voxelManager=d.createRLEVolumeVoxelManager({dimensions:[t,n,1]}),e.getPixelData=e.voxelManager.getPixelData,e.sizeInBytes=5120)}}},95816:(e,t,n)=>{n.d(t,{Ay:()=>h});var a=n(45630),i=n(37743),r=n(5186),o=n(29845),s=n(33700);function c(e){let t=2166136261;for(let n=0;n<e.length;n++)t^=e.charCodeAt(n),t+=(t<<1)+(t<<4)+(t<<7)+(t<<8)+(t<<24);return(t>>>0).toString(36)}const h=new class{constructor(){this._imageCache=new Map,this._volumeCache=new Map,this._imageIdsToVolumeIdCache=new Map,this._referencedImageIdToImageIdCache=new Map,this._geometryCache=new Map,this._imageCacheSize=0,this._maxCacheSize=3221225472,this._geometryCacheSize=0,this.setMaxCacheSize=e=>{if(!e||"number"!=typeof e){const e=`New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;throw new Error(e)}this._maxCacheSize=e},this.isCacheable=e=>this.getBytesAvailable()+Array.from(this._imageCache.values()).reduce((e,t)=>t.sharedCacheKey?e:e+t.sizeInBytes,0)>=e,this.getMaxCacheSize=()=>this._maxCacheSize,this.getCacheSize=()=>this._imageCacheSize,this._decacheImage=(e,t=!1)=>{const n=this._imageCache.get(e);if(!n)return;if(n.sharedCacheKey&&!t)throw new Error("Cannot decache an image with a shared cache key. You need to manually decache the volume first.");const{imageLoadObject:a}=n;n.image?.referencedImageId&&this._referencedImageIdToImageIdCache.delete(n.image.referencedImageId),a?.cancelFn&&a.cancelFn(),a?.decache&&a.decache(),this._imageCache.delete(e)},this._decacheVolume=e=>{const t=this._volumeCache.get(e);if(!t)return;const{volumeLoadObject:n,volume:a}=t;a&&(a.cancelLoading&&a.cancelLoading(),a.imageData&&a.imageData.delete(),n.cancelFn&&n.cancelFn(),a.imageIds&&a.imageIds.forEach(t=>{const n=this._imageCache.get(t);n&&n.sharedCacheKey===e&&(n.sharedCacheKey=void 0)}),this._volumeCache.delete(e))},this.purgeCache=()=>{const e=this._imageCache.keys();for(this.purgeVolumeCache();;){const{value:t,done:n}=e.next();if(n)break;this.removeImageLoadObject(t,{force:!0}),(0,a.A)(r.A,o.A.IMAGE_CACHE_IMAGE_REMOVED,{imageId:t})}},this.purgeVolumeCache=()=>{const e=this._volumeCache.keys();for(;;){const{value:t,done:n}=e.next();if(n)break;this.removeVolumeLoadObject(t),(0,a.A)(r.A,o.A.VOLUME_CACHE_VOLUME_REMOVED,{volumeId:t})}},this.getVolumeLoadObject=e=>{if(void 0===e)throw new Error("getVolumeLoadObject: volumeId must not be undefined");const t=this._volumeCache.get(e);if(t)return t.timeStamp=Date.now(),t.volumeLoadObject},this.putGeometryLoadObject=(e,t)=>{if(void 0===e)throw new Error("putGeometryLoadObject: geometryId must not be undefined");if(void 0===t.promise)throw new Error("putGeometryLoadObject: geometryLoadObject.promise must not be undefined");if(this._geometryCache.has(e))throw new Error("putGeometryLoadObject: geometryId already present in geometryCache");if(t.cancelFn&&"function"!=typeof t.cancelFn)throw new Error("putGeometryLoadObject: geometryLoadObject.cancel must be a function");const n={loaded:!1,geometryId:e,geometryLoadObject:t,timeStamp:Date.now(),sizeInBytes:0};return this._geometryCache.set(e,n),t.promise.then(t=>{try{this._putGeometryCommon(e,t,n)}catch(t){throw console.debug(`Error in _putGeometryCommon for geometry ${e}:`,t),t}}).catch(t=>{throw console.debug(`Error caching geometry ${e}:`,t),this._geometryCache.delete(e),t})},this.getGeometry=e=>{if(void 0===e)throw new Error("getGeometry: geometryId must not be undefined");const t=this._geometryCache.get(e);if(t)return t.timeStamp=Date.now(),t.geometry},this.removeGeometryLoadObject=e=>{if(void 0===e)throw new Error("removeGeometryLoadObject: geometryId must not be undefined");const t=this._geometryCache.get(e);if(!t)throw new Error("removeGeometryLoadObject: geometryId was not present in geometryCache");this.decrementGeometryCacheSize(t.sizeInBytes);const n={geometry:t,geometryId:e};(0,a.A)(r.A,o.A.GEOMETRY_CACHE_GEOMETRY_REMOVED,n),this._decacheGeometry(e)},this._decacheGeometry=e=>{const t=this._geometryCache.get(e);if(!t)return;const{geometryLoadObject:n}=t;n.cancelFn&&n.cancelFn(),n.decache&&n.decache(),this._geometryCache.delete(e)},this.incrementGeometryCacheSize=e=>{this._geometryCacheSize+=e},this.decrementGeometryCacheSize=e=>{this._geometryCacheSize-=e},this.getImageByReferencedImageId=e=>{const t=this._referencedImageIdToImageIdCache.get(e);if(t)return this._imageCache.get(t)?.image},this.getImage=(e,t=s.A.FAR_REPLICATE)=>{if(void 0===e)throw new Error("getImage: imageId must not be undefined");const n=this._imageCache.get(e);if(n&&(n.timeStamp=Date.now(),!(n.image?.imageQualityStatus<t)))return n.image},this.getVolume=(e,t=!1)=>{if(void 0===e)throw new Error("getVolume: volumeId must not be undefined");const n=this._volumeCache.get(e);return n?(n.timeStamp=Date.now(),n.volume):t?[...this._volumeCache.values()].find(t=>t.volumeId.includes(e))?.volume:void 0},this.getVolumes=()=>Array.from(this._volumeCache.values()).map(e=>e.volume),this.filterVolumesByReferenceId=e=>this.getVolumes().filter(t=>t.referencedVolumeId===e),this.removeImageLoadObject=(e,{force:t=!1}={})=>{if(void 0===e)throw new Error("removeImageLoadObject: imageId must not be undefined");const n=this._imageCache.get(e);if(!n)throw new Error("removeImageLoadObject: imageId was not present in imageCache");this._decacheImage(e,t),this.incrementImageCacheSize(-n.sizeInBytes);const i={image:n,imageId:e};(0,a.A)(r.A,o.A.IMAGE_CACHE_IMAGE_REMOVED,i)},this.removeVolumeLoadObject=e=>{if(void 0===e)throw new Error("removeVolumeLoadObject: volumeId must not be undefined");const t=this._volumeCache.get(e);if(!t)throw new Error("removeVolumeLoadObject: volumeId was not present in volumeCache");const n={volume:t,volumeId:e};(0,a.A)(r.A,o.A.VOLUME_CACHE_VOLUME_REMOVED,n),this._decacheVolume(e)},this.incrementImageCacheSize=e=>{this._imageCacheSize+=e},this.decrementImageCacheSize=e=>{this._imageCacheSize-=e},this.getGeometryLoadObject=e=>{if(void 0===e)throw new Error("getGeometryLoadObject: geometryId must not be undefined");const t=this._geometryCache.get(e);if(t)return t.timeStamp=Date.now(),t.geometryLoadObject}}generateVolumeId(e){const t=e.map(i.A).sort();let n=2166136261;for(const e of t){const t=c(e);for(let e=0;e<t.length;e++)n^=t.charCodeAt(e),n+=(n<<1)+(n<<4)+(n<<7)+(n<<8)+(n<<24)}return`volume-${(n>>>0).toString(36)}`}getImageIdsForVolumeId(e){return Array.from(this._imageIdsToVolumeIdCache.entries()).filter(([t,n])=>n===e).map(([e])=>e)}getBytesAvailable(){return this.getMaxCacheSize()-this.getCacheSize()}decacheIfNecessaryUntilBytesAvailable(e,t){let n=this.getBytesAvailable();if(n>=e)return n;const i=Array.from(this._imageCache.values()).filter(e=>!e.sharedCacheKey);i.sort(function(e,t){return e.timeStamp>t.timeStamp?1:e.timeStamp<t.timeStamp?-1:0});const s=i.map(e=>e.imageId);let c=s;t&&(c=s.filter(e=>!t.includes(e)));for(const t of c)if(this.removeImageLoadObject(t),(0,a.A)(r.A,o.A.IMAGE_CACHE_IMAGE_REMOVED,{imageId:t}),n=this.getBytesAvailable(),n>=e)return n;for(const t of s)if(this.removeImageLoadObject(t),(0,a.A)(r.A,o.A.IMAGE_CACHE_IMAGE_REMOVED,{imageId:t}),n=this.getBytesAvailable(),n>=e)return n}_putImageCommon(e,t,n){if(!this._imageCache.has(e))return void console.warn("The image was purged from the cache before it completed loading.");if(!t)return void console.warn("Image is undefined");if(void 0===t.sizeInBytes||Number.isNaN(t.sizeInBytes))throw new Error("_putImageCommon: image.sizeInBytes must not be undefined");if(void 0===t.sizeInBytes.toFixed)throw new Error("_putImageCommon: image.sizeInBytes is not a number");if(!this.isCacheable(t.sizeInBytes))throw new Error(o.A.CACHE_SIZE_EXCEEDED);this.decacheIfNecessaryUntilBytesAvailable(t.sizeInBytes),n.loaded=!0,n.image=t,n.sizeInBytes=t.sizeInBytes,this.incrementImageCacheSize(n.sizeInBytes);const i={image:n};t.referencedImageId&&this._referencedImageIdToImageIdCache.set(t.referencedImageId,e),(0,a.A)(r.A,o.A.IMAGE_CACHE_IMAGE_ADDED,i),n.sharedCacheKey=t.sharedCacheKey}async putImageLoadObject(e,t){if(void 0===e)throw console.error("putImageLoadObject: imageId must not be undefined"),new Error("putImageLoadObject: imageId must not be undefined");if(void 0===t.promise)throw console.error("putImageLoadObject: imageLoadObject.promise must not be undefined"),new Error("putImageLoadObject: imageLoadObject.promise must not be undefined");const n=this._imageCache.get(e);if(n?.imageLoadObject)throw console.warn(`putImageLoadObject: imageId ${e} already in cache`),new Error("putImageLoadObject: imageId already in cache");if(t.cancelFn&&"function"!=typeof t.cancelFn)throw console.error("putImageLoadObject: imageLoadObject.cancel must be a function"),new Error("putImageLoadObject: imageLoadObject.cancel must be a function");const a={...n,loaded:!1,imageId:e,sharedCacheKey:void 0,imageLoadObject:t,timeStamp:Date.now(),sizeInBytes:0};return this._imageCache.set(e,a),t.promise.then(t=>{try{this._putImageCommon(e,t,a)}catch(t){throw console.debug(`Error in _putImageCommon for image ${e}:`,t),t}}).catch(t=>{throw console.debug(`Error caching image ${e}:`,t),this._imageCache.delete(e),t})}putImageSync(e,t){if(void 0===e)throw new Error("putImageSync: imageId must not be undefined");if(this._imageCache.has(e))throw new Error("putImageSync: imageId already in cache");const n={loaded:!1,imageId:e,sharedCacheKey:void 0,imageLoadObject:{promise:Promise.resolve(t)},timeStamp:Date.now(),sizeInBytes:0};this._imageCache.set(e,n);try{this._putImageCommon(e,t,n)}catch(t){throw this._imageCache.delete(e),t}}getImageLoadObject(e){if(void 0===e)throw new Error("getImageLoadObject: imageId must not be undefined");const t=this._imageCache.get(e);if(t)return t.timeStamp=Date.now(),t.imageLoadObject}isLoaded(e){const t=this._imageCache.get(e);return!!t&&t.loaded}getVolumeContainingImageId(e){const t=Array.from(this._volumeCache.keys()),n=(0,i.A)(e);for(const e of t){const t=this._volumeCache.get(e);if(!t)return;const{volume:a}=t;if(!a.imageIds.length)return;const i=a.getImageURIIndex(n);if(i>-1)return{volume:a,imageIdIndex:i}}}getCachedImageBasedOnImageURI(e){const t=(0,i.A)(e),n=Array.from(this._imageCache.keys()).find(e=>(0,i.A)(e)===t);if(n)return this._imageCache.get(n)}_putVolumeCommon(e,t,n){if(!this._volumeCache.get(e))return void console.warn("The volume was purged from the cache before it completed loading.");n.loaded=!0,n.volume=t,t.imageIds?.forEach(t=>{const n=this._imageCache.get(t);n&&(n.sharedCacheKey=e)});const i={volume:n};(0,a.A)(r.A,o.A.VOLUME_CACHE_VOLUME_ADDED,i)}putVolumeSync(e,t){if(void 0===e)throw new Error("putVolumeSync: volumeId must not be undefined");if(this._volumeCache.has(e))throw new Error("putVolumeSync: volumeId already in cache");const n={loaded:!1,volumeId:e,volumeLoadObject:{promise:Promise.resolve(t)},timeStamp:Date.now(),sizeInBytes:0};this._volumeCache.set(e,n);try{this._putVolumeCommon(e,t,n)}catch(t){throw this._volumeCache.delete(e),t}}async putVolumeLoadObject(e,t){if(void 0===e)throw new Error("putVolumeLoadObject: volumeId must not be undefined");if(void 0===t.promise)throw new Error("putVolumeLoadObject: volumeLoadObject.promise must not be undefined");if(this._volumeCache.has(e))throw new Error(`putVolumeLoadObject: volumeId:${e} already in cache`);if(t.cancelFn&&"function"!=typeof t.cancelFn)throw new Error("putVolumeLoadObject: volumeLoadObject.cancel must be a function");const n={loaded:!1,volumeId:e,volumeLoadObject:t,timeStamp:Date.now(),sizeInBytes:0};return this._volumeCache.set(e,n),t.promise.then(t=>{try{this._putVolumeCommon(e,t,n)}catch(t){throw console.error(`Error in _putVolumeCommon for volume ${e}:`,t),this._volumeCache.delete(e),t}}).catch(t=>{throw this._volumeCache.delete(e),t})}_putGeometryCommon(e,t,n){if(!this._geometryCache.get(e))return void console.warn("The geometry was purged from the cache before it completed loading.");if(!t)return void console.warn("Geometry is undefined");if(void 0===t.sizeInBytes||Number.isNaN(t.sizeInBytes))throw new Error("_putGeometryCommon: geometry.sizeInBytes must not be undefined");if(void 0===t.sizeInBytes.toFixed)throw new Error("_putGeometryCommon: geometry.sizeInBytes is not a number");if(!this.isCacheable(t.sizeInBytes))throw new Error(o.A.CACHE_SIZE_EXCEEDED);this.decacheIfNecessaryUntilBytesAvailable(t.sizeInBytes),n.loaded=!0,n.geometry=t,n.sizeInBytes=t.sizeInBytes,this.incrementGeometryCacheSize(n.sizeInBytes);const i={geometry:n};(0,a.A)(r.A,o.A.GEOMETRY_CACHE_GEOMETRY_ADDED,i)}putGeometrySync(e,t){if(void 0===e)throw new Error("putGeometrySync: geometryId must not be undefined");if(this._geometryCache.has(e))throw new Error("putGeometrySync: geometryId already in cache");const n={loaded:!1,geometryId:e,geometryLoadObject:{promise:Promise.resolve(t)},timeStamp:Date.now(),sizeInBytes:0};this._geometryCache.set(e,n);try{this._putGeometryCommon(e,t,n)}catch(t){throw this._geometryCache.delete(e),t}}setPartialImage(e,t){const n=this._imageCache.get(e);n?n.loaded?(n.loaded=!1,n.imageLoadObject=null,this.incrementImageCacheSize(-n.sizeInBytes),n.sizeInBytes=0,n.image=t||n.image):n.image=t||n.image:t&&this._imageCache.set(e,{image:t,imageId:e,loaded:!1,timeStamp:Date.now(),sizeInBytes:0})}getImageQuality(e){const t=this._imageCache.get(e)?.image;return t?t.imageQualityStatus||s.A.FULL_RESOLUTION:void 0}}}}]);