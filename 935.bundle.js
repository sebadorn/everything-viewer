"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[935],{20935:(e,t,n)=>{n.d(t,{KHR_interactivity:()=>g});var o=n(84813),a=n(85048),r=n(37812),i=n(49532),s=n(48966),l=n(51137),c=n(38688);const p={float:{length:1,flowGraphType:"number",elementType:"number"},bool:{length:1,flowGraphType:"boolean",elementType:"boolean"},float2:{length:2,flowGraphType:"Vector2",elementType:"number"},float3:{length:3,flowGraphType:"Vector3",elementType:"number"},float4:{length:4,flowGraphType:"Vector4",elementType:"number"},float4x4:{length:16,flowGraphType:"Matrix",elementType:"number"},float2x2:{length:4,flowGraphType:"Matrix2D",elementType:"number"},float3x3:{length:9,flowGraphType:"Matrix3D",elementType:"number"},int:{length:1,flowGraphType:"FlowGraphInteger",elementType:"number"}};class u{constructor(e,t,n){this._interactivityGraph=e,this._gltf=t,this._loader=n,this._types=[],this._mappings=[],this._staticVariables=[],this._events=[],this._internalEventsCounter=0,this._nodes=[],this._parseTypes(),this._parseDeclarations(),this._parseVariables(),this._parseEvents(),this._parseNodes()}get arrays(){return{types:this._types,mappings:this._mappings,staticVariables:this._staticVariables,events:this._events,nodes:this._nodes}}_parseTypes(){if(this._interactivityGraph.types)for(const e of this._interactivityGraph.types)this._types.push(p[e.signature])}_parseDeclarations(){if(this._interactivityGraph.declarations)for(const e of this._interactivityGraph.declarations){const t=(0,s.KD)(e);if(!t)throw l.V.Error(["No mapping found for declaration",e]),new Error("Error parsing declarations");this._mappings.push({flowGraphMapping:t,fullOperationName:e.extension?e.op+":"+e.extension:e.op})}}_parseVariables(){if(this._interactivityGraph.variables)for(const e of this._interactivityGraph.variables){const t=this._parseVariable(e);this._staticVariables.push(t)}}_parseVariable(e,t){const n=this._types[e.type];if(!n)throw l.V.Error(["No type found for variable",e]),new Error("Error parsing variables");if(e.value&&e.value.length!==n.length)throw l.V.Error(["Invalid value length for variable",e,n]),new Error("Error parsing variables");const o=e.value||[];if(!o.length)switch(n.flowGraphType){case"boolean":o.push(!1);break;case"FlowGraphInteger":o.push(0);break;case"number":o.push(NaN);break;case"Vector2":o.push(NaN,NaN);break;case"Vector3":o.push(NaN,NaN,NaN);break;case"Vector4":case"Matrix2D":case"Quaternion":o.fill(NaN,0,4);break;case"Matrix":o.fill(NaN,0,16);break;case"Matrix3D":o.fill(NaN,0,9)}return{type:n.flowGraphType,value:t?t(o,this):o}}_parseEvents(){if(this._interactivityGraph.events)for(const e of this._interactivityGraph.events){const t={eventId:e.id||"internalEvent_"+this._internalEventsCounter++};e.values&&(t.eventData=Object.keys(e.values).map((t=>{const n=e.values?.[t];if(!n)throw l.V.Error(["No value found for event key",t]),new Error("Error parsing events");const o=this._types[n.type];if(!o)throw l.V.Error(["No type found for event value",n]),new Error("Error parsing events");const a=void 0!==n.value?this._parseVariable(n):void 0;return{id:t,type:o.flowGraphType,eventData:!0,value:a}}))),this._events.push(t)}}_parseNodes(){if(this._interactivityGraph.nodes)for(const e of this._interactivityGraph.nodes){if("number"!=typeof e.declaration)throw l.V.Error(["No declaration found for node",e]),new Error("Error parsing nodes");const t=this._mappings[e.declaration];if(!t)throw l.V.Error(["No mapping found for node",e]),new Error("Error parsing nodes");if(t.flowGraphMapping.validation&&!t.flowGraphMapping.validation(e,this._interactivityGraph,this._gltf))throw new Error(`Error validating interactivity node ${e}`);const n=[];for(const o of t.flowGraphMapping.blocks){const a=this._getEmptyBlock(o,t.fullOperationName);this._parseNodeConfiguration(e,a,t.flowGraphMapping,o),n.push(a)}this._nodes.push({blocks:n,fullOperationName:t.fullOperationName})}}_getEmptyBlock(e,t){return{uniqueId:(0,c.z)(),className:e,dataInputs:[],dataOutputs:[],signalInputs:[],signalOutputs:[],config:{},type:t,metadata:{}}}_parseNodeConfiguration(e,t,n,o){const a=t.config;e.configuration&&Object.keys(e.configuration).forEach((t=>{const r=e.configuration?.[t];if(!r)throw l.V.Error(["No value found for node configuration",t]),new Error("Error parsing node configuration");const i=n.configuration?.[t];if(i&&i.toBlock?i.toBlock===o:0===n.blocks.indexOf(o)){const e=i?.name||t;r&&void 0!==r.value||void 0===i?.defaultValue?r.value.length>=1?a[e]={value:1===r.value.length?r.value[0]:r.value}:l.V.Warn(["Invalid value for node configuration",r]):a[e]={value:i.defaultValue},i&&i.dataTransformer&&(a[e].value=i.dataTransformer([a[e].value],this)[0])}}))}_parseNodeConnections(e){for(let t=0;t<this._nodes.length;t++){const n=this._interactivityGraph.nodes?.[t];if(!n)throw l.V.Error(["No node found for interactivity node",this._nodes[t]]),new Error("Error parsing node connections");const o=this._nodes[t],a=this._mappings[n.declaration];if(!a)throw l.V.Error(["No mapping found for node",n]),new Error("Error parsing node connections");const r=n.flows||{},i=Object.keys(r).sort();for(const e of i){const t=r[e],n=a.flowGraphMapping.outputs?.flows?.[e],i=n?.name||e,c=this._createNewSocketConnection(i,!0);(n&&n.toBlock&&o.blocks.find((e=>e.className===n.toBlock))||o.blocks[0]).signalOutputs.push(c);const p=t.node,u=this._nodes[p];if(!u)throw l.V.Error(["No node found for input node id",p]),new Error("Error parsing node connections");const h=(0,s.X6)(u.fullOperationName);if(!h)throw l.V.Error(["No mapping found for input node",u]),new Error("Error parsing node connections");let f=h.inputs?.flows?.[t.socket||"in"],d=!1;if(!f)for(const e in h.inputs?.flows)e.startsWith("[")&&e.endsWith("]")&&(d=!0,f=h.inputs?.flows?.[e]);const g=f?d?f.name.replace("$1",t.socket||""):f.name:t.socket||"in",_=f&&f.toBlock&&u.blocks.find((e=>e.className===f.toBlock))||u.blocks[0];let v=_.signalInputs.find((e=>e.name===g));v||(v=this._createNewSocketConnection(g),_.signalInputs.push(v)),v.connectedPointIds.push(c.uniqueId),c.connectedPointIds.push(v.uniqueId)}const c=n.values||{},p=Object.keys(c);for(const t of p){const n=c[t];let r=a.flowGraphMapping.inputs?.values?.[t],i=!1;if(!r)for(const e in a.flowGraphMapping.inputs?.values)e.startsWith("[")&&e.endsWith("]")&&(i=!0,r=a.flowGraphMapping.inputs?.values?.[e]);const p=r?i?r.name.replace("$1",t):r.name:t,u=this._createNewSocketConnection(p);if((r&&r.toBlock&&o.blocks.find((e=>e.className===r.toBlock))||o.blocks[0]).dataInputs.push(u),void 0!==n.value){const t=this._parseVariable(n,r&&r.dataTransformer);e._connectionValues[u.uniqueId]=t}else{if(void 0===n.node)throw l.V.Error(["Invalid value for value connection",n]),new Error("Error parsing node connections");{const e=n.node,t=n.socket||"value",o=this._nodes[e];if(!o)throw l.V.Error(["No node found for output socket reference",n]),new Error("Error parsing node connections");const a=(0,s.X6)(o.fullOperationName);if(!a)throw l.V.Error(["No mapping found for output socket reference",n]),new Error("Error parsing node connections");let r=a.outputs?.values?.[t],i=!1;if(!r)for(const e in a.outputs?.values)e.startsWith("[")&&e.endsWith("]")&&(i=!0,r=a.outputs?.values?.[e]);const c=r?i?r.name.replace("$1",t):r?.name:t,p=r&&r.toBlock&&o.blocks.find((e=>e.className===r.toBlock))||o.blocks[0];let h=p.dataOutputs.find((e=>e.name===c));h||(h=this._createNewSocketConnection(c,!0),p.dataOutputs.push(h)),u.connectedPointIds.push(h.uniqueId),h.connectedPointIds.push(u.uniqueId)}}}if(a.flowGraphMapping.interBlockConnectors)for(const e of a.flowGraphMapping.interBlockConnectors){const t=e.input,n=e.output,a=e.isVariable;this._connectFlowGraphNodes(t,n,o.blocks[e.inputBlockIndex],o.blocks[e.outputBlockIndex],a)}if(a.flowGraphMapping.extraProcessor){const t=this._interactivityGraph.declarations?.[n.declaration];if(!t)throw l.V.Error(["No declaration found for extra processor",n]),new Error("Error parsing node connections");o.blocks=a.flowGraphMapping.extraProcessor(n,t,a.flowGraphMapping,this,o.blocks,e,this._gltf)}}}_createNewSocketConnection(e,t){return{uniqueId:(0,c.z)(),name:e,_connectionType:t?1:0,connectedPointIds:[]}}_connectFlowGraphNodes(e,t,n,o,a){const r=a?n.dataInputs:n.signalInputs,i=a?o.dataOutputs:o.signalOutputs,s=r.find((t=>t.name===e))||this._createNewSocketConnection(e),l=i.find((e=>e.name===t))||this._createNewSocketConnection(t,!0);r.find((t=>t.name===e))||r.push(s),i.find((e=>e.name===t))||i.push(l),s.connectedPointIds.push(l.uniqueId),l.connectedPointIds.push(s.uniqueId)}getVariableName(e){return"staticVariable_"+e}serializeToFlowGraph(){const e={uniqueId:(0,c.z)(),_userVariables:{},_connectionValues:{}};this._parseNodeConnections(e);for(let t=0;t<this._staticVariables.length;t++){const n=this._staticVariables[t];e._userVariables[this.getVariableName(t)]=n}return{rightHanded:!0,allBlocks:this._nodes.reduce(((e,t)=>e.concat(t.blocks)),[]),executionContexts:[e]}}}var h=n(85715),f=n(79923);const d="KHR_interactivity";class g{constructor(e){this._loader=e,this.name=d,this.enabled=this._loader.isExtensionUsed(d),this._pathConverter=(0,i.Wt)(this._loader.gltf),e._skipStartAnimationStep=!0;const t=e.babylonScene;t&&function(e){(0,i.oR)("/extensions/KHR_interactivity/?/activeCamera/rotation",{get:()=>e.activeCamera?f.PT.FromRotationMatrix(e.activeCamera.getWorldMatrix()).normalize():new f.PT(NaN,NaN,NaN,NaN),type:"Quaternion",getTarget:()=>e.activeCamera}),(0,i.oR)("/extensions/KHR_interactivity/?/activeCamera/position",{get:()=>e.activeCamera?e.activeCamera.position:new f.Pq(NaN,NaN,NaN),type:"Vector3",getTarget:()=>e.activeCamera}),(0,i.oR)("/animations/{}/extensions/KHR_interactivity/isPlaying",{get:e=>e._babylonAnimationGroup?.isPlaying??!1,type:"boolean",getTarget:e=>e._babylonAnimationGroup}),(0,i.oR)("/animations/{}/extensions/KHR_interactivity/minTime",{get:e=>(e._babylonAnimationGroup?.from??0)/60,type:"number",getTarget:e=>e._babylonAnimationGroup}),(0,i.oR)("/animations/{}/extensions/KHR_interactivity/maxTime",{get:e=>(e._babylonAnimationGroup?.to??0)/60,type:"number",getTarget:e=>e._babylonAnimationGroup}),(0,i.oR)("/animations/{}/extensions/KHR_interactivity/playhead",{get:e=>(e._babylonAnimationGroup?.getCurrentFrame()??0)/60,type:"number",getTarget:e=>e._babylonAnimationGroup}),(0,i.oR)("/animations/{}/extensions/KHR_interactivity/virtualPlayhead",{get:e=>(e._babylonAnimationGroup?.getCurrentFrame()??0)/60,type:"number",getTarget:e=>e._babylonAnimationGroup})}(t)}dispose(){this._loader=null,delete this._pathConverter}async onReady(){if(!this._loader.babylonScene||!this._pathConverter)return;const e=this._loader.babylonScene,t=this._loader.gltf.extensions?.KHR_interactivity;if(!t)return;const n=new o.x({scene:e}),r=t.graphs.map((e=>new u(e,this._loader.gltf,this._loader).serializeToFlowGraph()));await Promise.all(r.map((e=>(0,a.cB)(e,{coordinator:n,pathConverter:this._pathConverter})))),n.start()}}(0,h.Q)(d,"FlowGraphGLTFDataProvider",(async()=>(await n.e(1087).then(n.bind(n,31087))).FlowGraphGLTFDataProvider)),(0,r.Hg)(d),(0,r.Ye)(d,!0,(e=>new g(e)))}}]);