"use strict";(self.webpackChunkeverything_viewer=self.webpackChunkeverything_viewer||[]).push([[6041,7793],{2215:(e,n,t)=>{var r=t(69610);const a="logDepthVertex",o="#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o)},2360:(e,n,t)=>{var r=t(69610);const a="fogFragment",o="#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o)},6194:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneFragmentDeclaration:()=>i});var r=t(69610);const a="clipPlaneFragmentDeclaration",o="#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o);const i={name:a,shader:o}},6874:(e,n,t)=>{var r=t(69610);const a="meshUboDeclaration",o="struct Mesh {world : mat4x4<f32>,\nvisibility : f32,};var<uniform> mesh : Mesh;\n#define WORLD_UBO\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o)},7412:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneFragment:()=>i});var r=t(69610);const a="clipPlaneFragment",o="#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{discard;}\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o);const i={name:a,shader:o}},7806:(e,n,t)=>{t.r(n),t.d(n,{fogFragmentDeclaration:()=>i});var r=t(69610);const a="fogFragmentDeclaration",o="#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()\n{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o);const i={name:a,shader:o}},16470:(e,n,t)=>{var r=t(69610);const a="fogVertex",o="#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o)},28764:(e,n,t)=>{var r=t(69610);const a="sceneUboDeclaration",o="layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif \nmat4 view;mat4 projection;vec4 vEyePosition;};\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o)},29741:(e,n,t)=>{var r=t(69610);const a="logDepthFragment",o="#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o)},34581:(e,n,t)=>{var r=t(69610);const a="logDepthDeclaration",o="#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;varying float vFragmentDepth;\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o)},38780:(e,n,t)=>{var r=t(69610);const a="logDepthFragment",o="#ifdef LOGARITHMICDEPTH\nfragmentOutputs.fragDepth=log2(fragmentInputs.vFragmentDepth)*uniforms.logarithmicDepthConstant*0.5;\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o)},39759:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneFragmentDeclarationWGSL:()=>i});var r=t(69610);const a="clipPlaneFragmentDeclaration",o="#ifdef CLIPPLANE\nvarying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nvarying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nvarying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nvarying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nvarying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nvarying fClipDistance6: f32;\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o);const i={name:a,shader:o}},47314:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneVertex:()=>i});var r=t(69610);const a="clipPlaneVertex",o="#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o);const i={name:a,shader:o}},59013:(e,n,t)=>{var r=t(69610);const a="fogVertex",o="#ifdef FOG\n#ifdef SCENE_UBO\nvertexOutputs.vFogDistance=(scene.view*worldPos).xyz;\n#else\nvertexOutputs.vFogDistance=(uniforms.view*worldPos).xyz;\n#endif\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o)},66407:(e,n,t)=>{t.r(n),t.d(n,{fogFragmentDeclarationWGSL:()=>i});var r=t(69610);const a="fogFragmentDeclaration",o="#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\nconst E=2.71828;uniform vFogInfos: vec4f;uniform vFogColor: vec3f;varying vFogDistance: vec3f;fn CalcFogFactor()->f32\n{var fogCoeff: f32=1.0;var fogStart: f32=uniforms.vFogInfos.y;var fogEnd: f32=uniforms.vFogInfos.z;var fogDensity: f32=uniforms.vFogInfos.w;var fogDistance: f32=length(fragmentInputs.vFogDistance);if (FOGMODE_LINEAR==uniforms.vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==uniforms.vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==uniforms.vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o);const i={name:a,shader:o}},71636:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneVertexDeclaration:()=>i});var r=t(69610);const a="clipPlaneVertexDeclaration",o="#ifdef CLIPPLANE\nuniform vec4 vClipPlane;varying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;varying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;varying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;varying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;varying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;varying float fClipDistance6;\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o);const i={name:a,shader:o}},73325:(e,n,t)=>{t.r(n),t.d(n,{helperFunctions:()=>i});var r=t(69610);const a="helperFunctions",o="const float PI=3.1415926535897932384626433832795;const float TWO_PI=6.283185307179586;const float HALF_PI=1.5707963267948966;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float RECIPROCAL_PI4=0.07957747154594767;const float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nmat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}\n#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\n{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\n#else\nreturn\nvec3(\ncolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\nvec3 toGammaSpaceExact(vec3 color)\n{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\n#else\nreturn\nvec3(\ncolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\n#endif\nfloat toLinearSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nvec3 toLinearSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\n#endif\n}\nvec4 toLinearSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfloat toGammaSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,GammaEncodePowerApprox);\n#endif\n}\nvec3 toGammaSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\n#endif\n}\nvec4 toGammaSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfloat square(float value)\n{return value*value;}\nvec3 square(vec3 value)\n{return value*value;}\nfloat pow5(float value) {float sq=value*value;return sq*sq*value;}\nfloat getLuminance(vec3 color)\n{return saturate(dot(color,LuminanceEncodeApprox));}\nfloat getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}\nfloat dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}\nconst float rgbdMaxRange=255.;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =saturate(floor(D)/255.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(saturate(rgb),D);}\nvec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\nvec3 equirectangularToCubemapDirection(vec2 uv) {float longitude=uv.x*TWO_PI-PI;float latitude=HALF_PI-uv.y*PI;vec3 direction;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}\nfloat sqrtClamped(float value) {return sqrt(max(value,0.));}\nfloat avg(vec3 value) {return dot(value,vec3(0.333333333));}";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o);const i={name:a,shader:o}},75757:(e,n,t)=>{var r=t(69610);const a="fogVertexDeclaration",o="#ifdef FOG\nvarying vFogDistance: vec3f;\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o)},76391:(e,n,t)=>{t.d(n,{SPLATFileLoader:()=>g});var r,a=t(15909),o=t(31612),i=t(98058),c=t(97889),f=t(76595),s=t(51137),l=t(79923),d=t(13833),u=t(26041),v=t(36803),p=t(62128);!function(e){e[e.Splat=0]="Splat",e[e.PointCloud=1]="PointCloud",e[e.Mesh=2]="Mesh",e[e.Reject=3]="Reject"}(r||(r={}));class g{constructor(e=g._DefaultLoadingOptions){this.name=o.B.name,this._assetContainer=null,this.extensions=o.B.extensions,this._loadingOptions=e}createPlugin(e){return new g(e[o.B.name])}async importMeshAsync(e,n,t,r,a,o){return this._parse(e,n,t,r).then((e=>({meshes:e,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})))}static _BuildPointCloud(e,n){if(!n.byteLength)return!1;const t=new Uint8Array(n),r=new Float32Array(n),a=t.length/32;return e.addPoints(a,(function(e,n){const a=r[8*n+0],o=r[8*n+1],i=r[8*n+2];e.position=new l.Pq(a,o,i);const c=t[32*n+24+0]/255,f=t[32*n+24+1]/255,s=t[32*n+24+2]/255;e.color=new u.ov(c,f,s,1)})),!0}static _BuildMesh(e,n){const t=new f.e("PLYMesh",e),r=new Uint8Array(n.data),a=new Float32Array(n.data),o=r.length/32,i=[],c=new v.P;for(let e=0;e<o;e++){const n=a[8*e+0],t=a[8*e+1],r=a[8*e+2];i.push(n,t,r)}if(n.hasVertexColors){const e=new Float32Array(4*o);for(let n=0;n<o;n++){const t=r[32*n+24+0]/255,a=r[32*n+24+1]/255,o=r[32*n+24+2]/255;e[4*n+0]=t,e[4*n+1]=a,e[4*n+2]=o,e[4*n+3]=1}c.colors=e}return c.positions=i,c.indices=n.faces,c.applyToMesh(t),t}_parseSPZ(e,n){const t=new Uint8Array(e),r=new Uint32Array(e.slice(0,12)),a=r[2],o=t[12],i=t[13];if(t[15]||1347635022!=r[0]||2!=r[1])return new Promise((e=>{e({mode:3,data:c,hasVertexColors:!1})}));const c=new ArrayBuffer(32*a),f=1/(1<<i),s=new Int32Array(1),l=new Uint8Array(s.buffer),d=function(e,n){return l[0]=e[n+0],l[1]=e[n+1],l[2]=e[n+2],l[3]=128&e[n+2]?255:0,s[0]*f};let u=16;const v=new Float32Array(c),g=new Float32Array(c),S=new Uint8ClampedArray(c),m=new Uint8ClampedArray(c);let P=1,h=0;this._loadingOptions.flipY||(P=-1,h=255);for(let e=0;e<a;e++)v[8*e+0]=d(t,u+0),v[8*e+1]=P*d(t,u+3),v[8*e+2]=P*d(t,u+6),u+=9;for(let e=0;e<a;e++){for(let n=0;n<3;n++){const r=(t[u+a+3*e+n]-127.5)/38.25;S[32*e+24+n]=p.X.Clamp(255*(.5+.282*r),0,255)}S[32*e+24+3]=t[u+e]}u+=4*a;for(let e=0;e<a;e++)g[8*e+3+0]=Math.exp(t[u+0]/16-10),g[8*e+3+1]=Math.exp(t[u+1]/16-10),g[8*e+3+2]=Math.exp(t[u+2]/16-10),u+=3;for(let e=0;e<a;e++){const n=t[u+0],r=t[u+1]*P+h,a=t[u+2]*P+h,o=n/127.5-1,i=r/127.5-1,c=a/127.5-1;m[32*e+28+1]=n,m[32*e+28+2]=r,m[32*e+28+3]=a;const f=1-(o*o+i*i+c*c);m[32*e+28+0]=127.5+127.5*Math.sqrt(f<0?0:f),u+=3}if(o){const e=3*((o+1)*(o+1)-1),r=Math.ceil(e/16);let i=u;const f=[],s=n.getEngine().getCaps().maxTextureSize,l=Math.ceil(a/s);for(let e=0;e<r;e++){const e=new Uint8Array(l*s*4*4);f.push(e)}for(let n=0;n<a;n++)for(let r=0;r<e;r++){const e=t[i++],a=Math.floor(r/16);f[a][r%16+16*n]=e}return new Promise((e=>{e({mode:0,data:c,hasVertexColors:!1,sh:f})}))}return new Promise((e=>{e({mode:0,data:c,hasVertexColors:!1})}))}_parse(e,n,t,r){const a=[],o=new ReadableStream({start(e){e.enqueue(new Uint8Array(t)),e.close()}}),c=new DecompressionStream("gzip"),f=o.pipeThrough(c);return new Promise((e=>{new Response(f).arrayBuffer().then((t=>{this._parseSPZ(t,n).then((t=>{n._blockEntityCollection=!!this._assetContainer;const r=new i.t("GaussianSplatting",null,n,this._loadingOptions.keepInRam);r._parentContainer=this._assetContainer,a.push(r),r.updateData(t.data,t.sh),n._blockEntityCollection=!1,e(a)}))})).catch((()=>{g._ConvertPLYToSplat(t).then((async t=>{switch(n._blockEntityCollection=!!this._assetContainer,t.mode){case 0:{const e=new i.t("GaussianSplatting",null,n,this._loadingOptions.keepInRam);e._parentContainer=this._assetContainer,a.push(e),e.updateData(t.data,t.sh)}break;case 1:{const e=new d.y("PointCloud",1,n);g._BuildPointCloud(e,t.data)?await e.buildMeshAsync().then((e=>{a.push(e)})):e.dispose()}break;case 2:if(!t.faces)throw new Error("PLY mesh doesn't contain face informations.");a.push(g._BuildMesh(n,t));break;default:throw new Error("Unsupported Splat mode")}n._blockEntityCollection=!1,e(a)}))}))}))}loadAssetContainerAsync(e,n,t){const r=new c.WZ(e);return this._assetContainer=r,this.importMeshAsync(null,e,n,t).then((e=>(e.meshes.forEach((e=>r.meshes.push(e))),this._assetContainer=null,r))).catch((e=>{throw this._assetContainer=null,e}))}loadAsync(e,n,t){return this.importMeshAsync(null,e,n,t).then((()=>{}))}static _ConvertPLYToSplat(e){const n=new Uint8Array(e),t=(new TextDecoder).decode(n.slice(0,10240)),r="end_header\n",a=t.indexOf(r);if(a<0||!t)return new Promise((n=>{n({mode:0,data:e})}));const o=parseInt(/element vertex (\d+)\n/.exec(t)[1]),c=/element face (\d+)\n/.exec(t);let f=0;c&&(f=parseInt(c[1]));const l=/element chunk (\d+)\n/.exec(t);let d=0;l&&(d=parseInt(l[1]));let u=0,v=0;const p={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let g;!function(e){e[e.Vertex=0]="Vertex",e[e.Chunk=1]="Chunk"}(g||(g={}));let S=1;const m=[],P=[],h=t.slice(0,a).split("\n");for(const e of h)if(e.startsWith("property ")){const[,n,t]=e.split(" ");1==S?(P.push({name:t,type:n,offset:v}),v+=p[n]):0==S&&(m.push({name:t,type:n,offset:u}),u+=p[n]),p[n]||s.V.Warn(`Unsupported property type: ${n}.`)}else if(e.startsWith("element ")){const[,n]=e.split(" ");"chunk"==n?S=1:"vertex"==n&&(S=0)}const C=u,x=v;return i.t.ConvertPLYWithSHToSplatAsync(e).then((n=>{const t=new DataView(e,a+11);let r=x*d+C*o;const i=[];if(f)for(let e=0;e<f;e++){const e=t.getUint8(r);if(3==e){r+=1;for(let n=0;n<e;n++){const e=t.getUint32(r+4*(2-n),!0);i.push(e)}r+=12}}if(d)return new Promise((e=>{e({mode:0,data:n.buffer,sh:n.sh,faces:i,hasVertexColors:!1})}));let c=0,s=0;const l=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],u=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let e=0;e<m.length;e++){const n=m[e];l.includes(n.name)&&c++,u.includes(n.name)&&s++}const v=c==l.length&&3==s,p=f?2:v?0:1;return new Promise((e=>{e({mode:p,data:n.buffer,sh:n.sh,faces:i,hasVertexColors:!!s})}))}))}}g._DefaultLoadingOptions={keepInRam:!1,flipY:!1},(0,a.qS)(new g)},77029:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneVertexDeclarationWGSL:()=>i});var r=t(69610);const a="clipPlaneVertexDeclaration",o="#ifdef CLIPPLANE\nuniform vClipPlane: vec4<f32>;varying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nuniform vClipPlane2: vec4<f32>;varying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nuniform vClipPlane3: vec4<f32>;varying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nuniform vClipPlane4: vec4<f32>;varying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nuniform vClipPlane5: vec4<f32>;varying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nuniform vClipPlane6: vec4<f32>;varying fClipDistance6: f32;\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o);const i={name:a,shader:o}},79702:(e,n,t)=>{t.r(n),t.d(n,{helperFunctionsWGSL:()=>i});var r=t(69610);const a="helperFunctions",o="const PI: f32=3.1415926535897932384626433832795;const TWO_PI: f32=6.283185307179586;const HALF_PI: f32=1.5707963267948966;const RECIPROCAL_PI: f32=0.3183098861837907;const RECIPROCAL_PI2: f32=0.15915494309189535;const RECIPROCAL_PI4: f32=0.07957747154594767;const HALF_MIN: f32=5.96046448e-08; \nconst LinearEncodePowerApprox: f32=2.2;const GammaEncodePowerApprox: f32=1.0/LinearEncodePowerApprox;const LuminanceEncodeApprox: vec3f=vec3f(0.2126,0.7152,0.0722);const Epsilon:f32=0.0000001;fn square(x: f32)->f32 {return x*x;}\nfn saturate(x: f32)->f32 {return clamp(x,0.0,1.0);}\nfn saturateVec3(x: vec3f)->vec3f {return clamp(x,vec3f(),vec3f(1.0));}\nfn saturateEps(x: f32)->f32 {return clamp(x,Epsilon,1.0);}\nfn maxEps(x: f32)->f32 {return max(x,Epsilon);}\nfn maxEpsVec3(x: vec3f)->vec3f {return max(x,vec3f(Epsilon));}\nfn absEps(x: f32)->f32 {return abs(x)+Epsilon;}\nfn transposeMat3(inMatrix: mat3x3f)->mat3x3f {let i0: vec3f=inMatrix[0];let i1: vec3f=inMatrix[1];let i2: vec3f=inMatrix[2];let outMatrix:mat3x3f=mat3x3f(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nfn inverseMat3(inMatrix: mat3x3f)->mat3x3f {let a00: f32=inMatrix[0][0];let a01: f32=inMatrix[0][1];let a02: f32=inMatrix[0][2];let a10: f32=inMatrix[1][0];let a11: f32=inMatrix[1][1];let a12: f32=inMatrix[1][2];let a20: f32=inMatrix[2][0];let a21: f32=inMatrix[2][1];let a22: f32=inMatrix[2][2];let b01: f32=a22*a11-a12*a21;let b11: f32=-a22*a10+a12*a20;let b21: f32=a21*a10-a11*a20;let det: f32=a00*b01+a01*b11+a02*b21;return mat3x3f(b01/det,(-a22*a01+a02*a21)/det,(a12*a01-a02*a11)/det,\nb11/det,(a22*a00-a02*a20)/det,(-a12*a00+a02*a10)/det,\nb21/det,(-a21*a00+a01*a20)/det,(a11*a00-a01*a10)/det);}\n#if USE_EXACT_SRGB_CONVERSIONS\nfn toLinearSpaceExact(color: vec3f)->vec3f\n{let nearZeroSection: vec3f=0.0773993808*color;let remainingSection: vec3f=pow(0.947867299*(color+vec3f(0.055)),vec3f(2.4));return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3f(0.04045)));}\nfn toGammaSpaceExact(color: vec3f)->vec3f\n{let nearZeroSection: vec3f=12.92*color;let remainingSection: vec3f=1.055*pow(color,vec3f(0.41666))-vec3f(0.055);return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3f(0.0031308)));}\n#endif\nfn toLinearSpace(color: f32)->f32\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nvar nearZeroSection=0.0773993808*color;var remainingSection=pow(0.947867299*(color+0.055),2.4);return select(remainingSection,nearZeroSection,color<=0.04045);\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nfn toLinearSpaceVec3(color: vec3f)->vec3f\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3f(LinearEncodePowerApprox));\n#endif\n}\nfn toLinearSpaceVec4(color: vec4<f32>)->vec4<f32>\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4f(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4f(pow(color.rgb,vec3f(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfn toGammaSpace(color: vec4<f32>)->vec4<f32>\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4<f32>(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4<f32>(pow(color.rgb,vec3f(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfn toGammaSpaceVec3(color: vec3f)->vec3f\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3f(GammaEncodePowerApprox));\n#endif\n}\nfn squareVec3(value: vec3f)->vec3f\n{return value*value;}\nfn pow5(value: f32)->f32 {let sq: f32=value*value;return sq*sq*value;}\nfn getLuminance(color: vec3f)->f32\n{return saturate(dot(color,LuminanceEncodeApprox));}\nfn getRand(seed: vec2<f32>)->f32 {return fract(sin(dot(seed.xy ,vec2<f32>(12.9898,78.233)))*43758.5453);}\nfn dither(seed: vec2<f32>,varianceAmount: f32)->f32 {let rand: f32=getRand(seed);let normVariance: f32=varianceAmount/255.0;let dither: f32=mix(-normVariance,normVariance,rand);return dither;}\nconst rgbdMaxRange: f32=255.0;fn toRGBD(color: vec3f)->vec4<f32> {let maxRGB: f32=max(max(color.r,max(color.g,color.b)),Epsilon);var D: f32 =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);var rgb: vec3f =color.rgb*D;rgb=toGammaSpaceVec3(rgb);return vec4<f32>(saturateVec3(rgb),D);}\nfn fromRGBD(rgbd: vec4<f32>)->vec3f {let rgb=toLinearSpaceVec3(rgbd.rgb);return rgb/rgbd.a;}\nfn parallaxCorrectNormal(vertexPos: vec3f,origVec: vec3f,cubeSize: vec3f,cubePos: vec3f)->vec3f {let invOrigVec: vec3f=vec3f(1.)/origVec;let halfSize: vec3f=cubeSize*0.5;let intersecAtMaxPlane: vec3f=(cubePos+halfSize-vertexPos)*invOrigVec;let intersecAtMinPlane: vec3f=(cubePos-halfSize-vertexPos)*invOrigVec;let largestIntersec: vec3f=max(intersecAtMaxPlane,intersecAtMinPlane);let distance: f32=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);let intersectPositionWS: vec3f=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\nfn equirectangularToCubemapDirection(uv : vec2f)->vec3f {var longitude : f32=uv.x*TWO_PI-PI;var latitude : f32=HALF_PI-uv.y*PI;var direction : vec3f;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}\nfn sqrtClamped(value: f32)->f32 {return sqrt(max(value,0.));}\nfn avg(value: vec3f)->f32 {return dot(value,vec3f(0.333333333));}\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o);const i={name:a,shader:o}},81482:(e,n,t)=>{var r=t(69610);const a="logDepthVertex",o="#ifdef LOGARITHMICDEPTH\nvertexOutputs.vFragmentDepth=1.0+vertexOutputs.position.w;vertexOutputs.position.z=log2(max(0.000001,vertexOutputs.vFragmentDepth))*uniforms.logarithmicDepthConstant;\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o)},85197:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneVertexWGSL:()=>i});var r=t(69610);const a="clipPlaneVertex",o="#ifdef CLIPPLANE\nvertexOutputs.fClipDistance=dot(worldPos,uniforms.vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nvertexOutputs.fClipDistance2=dot(worldPos,uniforms.vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nvertexOutputs.fClipDistance3=dot(worldPos,uniforms.vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nvertexOutputs.fClipDistance4=dot(worldPos,uniforms.vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nvertexOutputs.fClipDistance5=dot(worldPos,uniforms.vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nvertexOutputs.fClipDistance6=dot(worldPos,uniforms.vClipPlane6);\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o);const i={name:a,shader:o}},86560:(e,n,t)=>{var r=t(69610);const a="fogVertexDeclaration",o="#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o)},93226:(e,n,t)=>{var r=t(69610);const a="logDepthDeclaration",o="#ifdef LOGARITHMICDEPTH\nuniform logarithmicDepthConstant: f32;varying vFragmentDepth: f32;\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o)},93243:(e,n,t)=>{var r=t(69610);const a="fogFragment",o="#ifdef FOG\nvar fog: f32=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor= vec4f(mix(uniforms.vFogColor,color.rgb,fog),color.a);\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o)},96041:(e,n,t)=>{t.d(n,{I:()=>a});var r=t(7481);class a extends r.g{constructor(e,n,t,a,o,i=!0,c=!1,f=3,s=0,l,d,u){super(null,o,!i,c,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,l),this.format=a,this._engine&&(this._engine._caps.textureFloatLinearFiltering||1!==s||(f=1),this._engine._caps.textureHalfFloatLinearFiltering||2!==s||(f=1),this._texture=this._engine.createRawTexture(e,n,t,a,i,c,f,null,s,l??0,d??!1),this.wrapU=r.g.CLAMP_ADDRESSMODE,this.wrapV=r.g.CLAMP_ADDRESSMODE,this._waitingForData=!!u&&!e)}update(e){this._getEngine().updateRawTexture(this._texture,e,this._texture.format,this._texture.invertY,null,this._texture.type,this._texture._useSRGBBuffer),this._waitingForData=!1}clone(){if(!this._texture)return super.clone();const e=new a(null,this.getSize().width,this.getSize().height,this.format,this.getScene(),this._texture.generateMipMaps,this._invertY,this.samplingMode,this._texture.type,this._texture._creationFlags,this._useSRGBBuffer);return e._texture=this._texture,this._texture.incrementReferences(),e}isReady(){return super.isReady()&&!this._waitingForData}static CreateLuminanceTexture(e,n,t,r,o=!0,i=!1,c=3){return new a(e,n,t,1,r,o,i,c)}static CreateLuminanceAlphaTexture(e,n,t,r,o=!0,i=!1,c=3){return new a(e,n,t,2,r,o,i,c)}static CreateAlphaTexture(e,n,t,r,o=!0,i=!1,c=3){return new a(e,n,t,0,r,o,i,c)}static CreateRGBTexture(e,n,t,r,o=!0,i=!1,c=3,f=0,s=0,l=!1){return new a(e,n,t,4,r,o,i,c,f,s,l)}static CreateRGBATexture(e,n,t,r,o=!0,i=!1,c=3,f=0,s=0,l=!1,d=!1){return new a(e,n,t,5,r,o,i,c,f,s,l,d)}static CreateRGBAStorageTexture(e,n,t,r,o=!0,i=!1,c=3,f=0,s=!1){return new a(e,n,t,5,r,o,i,c,f,1,s)}static CreateRTexture(e,n,t,o,i=!0,c=!1,f=r.g.TRILINEAR_SAMPLINGMODE,s=1){return new a(e,n,t,6,o,i,c,f,s)}static CreateRStorageTexture(e,n,t,o,i=!0,c=!1,f=r.g.TRILINEAR_SAMPLINGMODE,s=1){return new a(e,n,t,6,o,i,c,f,s,1)}}},96467:(e,n,t)=>{var r=t(69610);const a="meshUboDeclaration",o="#ifdef WEBGL2\nuniform mat4 world;uniform float visibility;\n#else\nlayout(std140,column_major) uniform;uniform Mesh\n{mat4 world;float visibility;};\n#endif\n#define WORLD_UBO\n";r.l.IncludesShadersStore[a]||(r.l.IncludesShadersStore[a]=o)},97715:(e,n,t)=>{t.r(n),t.d(n,{clipPlaneFragmentWGSL:()=>i});var r=t(69610);const a="clipPlaneFragment",o="#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fragmentInputs.fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fragmentInputs.fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fragmentInputs.fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fragmentInputs.fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fragmentInputs.fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fragmentInputs.fClipDistance6>0.0)\n{discard;}\n#endif\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o);const i={name:a,shader:o}},98327:(e,n,t)=>{var r=t(69610);const a="sceneUboDeclaration",o="struct Scene {viewProjection : mat4x4<f32>,\n#ifdef MULTIVIEW\nviewProjectionR : mat4x4<f32>,\n#endif \nview : mat4x4<f32>,\nprojection : mat4x4<f32>,\nvEyePosition : vec4<f32>,};\n#define SCENE_UBO\nvar<uniform> scene : Scene;\n";r.l.IncludesShadersStoreWGSL[a]||(r.l.IncludesShadersStoreWGSL[a]=o)}}]);